This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
functions-build/
  chatbot.js
netlify/
  functions/
    types/
      financial.ts
    adviser-chat.js
    chatbot.js
    chatbot.txt
    chatbotbackup.txt
    chatbotts.txt
    generate-suitability-report.js
    get-models.js
    parse-file-note.js
    test.ts
    tsconfig.functions.json
public/
  _redirects
  index.html
  manifest.json
  robots.txt
src/
  @types/
    auth.ts
    documents.ts
    fileNote.ts
    financial.js
    financial.ts
    forms.ts
    json2csv.d.ts
    transactions.ts
  api/
    chatbot.ts
  components/
    Adviser/
      Documents/
        AdviserDocumentsPage.tsx
      ClientDetails.tsx
      ClientList.tsx
      ClientSummary.tsx
      CreateClient.tsx
      Dashboard.tsx
      ExportClientData.tsx
      ExtractionPreviewComponent.tsx
      FileNote.tsx
      Insights.tsx
      Reports.tsx
      ReportViewer.tsx
      SuitabilityReportGenerator.tsx
    Auth/
      SignIn.tsx
      SignUp.tsx
    Chat/
      AdviserChat.tsx
      AdviserReports.tsx
      Bot.tsx
      Calculate.tsx
      Chat.tsx
      Fetch.tsx
    Client/
      Cards/
        FinancialItemsCard.tsx
        NetWorthCard.tsx
      Documents/
        DocumentsPage.tsx
      Risk/
        RiskAssessmentForm.tsx
        RiskProfileResults.tsx
      AssetsForm.tsx
      BaseForm.tsx
      Dashboard.tsx
      ExpenditureForm.tsx
      GoalsForm.tsx
      IncomeForm.tsx
      LiabilitiesForm.tsx
      ProfileForm.tsx
    Common/
      Documents/
        ClientDocumentList.tsx
        DocumentDetails.tsx
        DocumentList.tsx
        DocumentUpload.tsx
    Navbar.css
    Navbar.tsx
    ProtectedRoute.tsx
  config/
    openai.ts
  context/
    AuthContext.tsx
  hooks/
    useAuthRedirect.ts
    useFinancialData.ts
  migrations/
    migrateTo_v2_addFileNotes.ts
  services/
    DocumentService.ts
    supabaseClient.ts
    supabaseOps.ts
  styles/
    globals.css
  utils/
    riskAssessment/
      constants.ts
      index.ts
      questions.ts
      riskCalculations.ts
      types.ts
    fileNoteUtils.ts
    financialcalculationMetrics.ts
  App.css
  App.test.tsx
  App.tsx
  index.css
  index.tsx
  logo.svg
  react-app-env.d.ts
  reportWebVitals.ts
  setupTests.ts
  styles.css
.gitignore
.node-version
.nvmrc
netlify.toml
package.json
postcss.config.js
README.md
supabase.txt
supabaseaccescontrolpolicies.txt
tailwind.config.js
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="functions-build/chatbot.js">
/*

///

"use strict";
// netlify/functions/chatbot.ts
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const openai_1 = __importDefault(require("openai"));
const supabase_js_1 = require("@supabase/supabase-js");
const openai = new openai_1.default({
    apiKey: process.env.OPENAI_API_KEY
});
const supabase = (0, supabase_js_1.createClient)(process.env.REACT_APP_SUPABASE_DATABASE_URL, process.env.REACT_APP_SUPABASE_ANON_KEY);
const handler = async (event) => {
  console.log('Received event:', JSON.stringify(event, null, 2));
    if (event.httpMethod !== 'POST') {
        return {
            statusCode: 405,
            body: JSON.stringify({ error: 'Method not allowed' })
        };
    }
    try {
        const { userId, message } = JSON.parse(event.body || '{}');
        console.log('Parsed userId:', userId);
        console.log('Parsed message:', message);
        if (!userId || !message) {
            return {
                statusCode: 400,
                body: JSON.stringify({ error: 'Missing userId or message' })
            };
        }
        // Fetch user's profile and financial data
        const [profileResult, goalsResult, incomesResult, expendituresResult, assetsResult, liabilitiesResult] = await Promise.all([
            supabase.from('profiles').select('*').eq('id', userId).single(),
            supabase.from('goals').select('*').eq('client_id', userId),
            supabase.from('incomes').select('*').eq('client_id', userId),
            supabase.from('expenditures').select('*').eq('client_id', userId),
            supabase.from('assets').select('*').eq('client_id', userId),
            supabase.from('liabilities').select('*').eq('client_id', userId)
        ]);
        if (profileResult.error) {
            throw new Error(`Error fetching profile: ${profileResult.error.message}`);
        }
        const userProfile = profileResult.data;
        // Convert null to empty arrays
        const financialData = {
            goals: goalsResult.data || [],
            incomes: incomesResult.data || [],
            expenditures: expendituresResult.data || [],
            assets: assetsResult.data || [],
            liabilities: liabilitiesResult.data || []
        };
        // Calculate financial metrics
        const totalIncome = financialData.incomes.reduce((sum, income) => sum + Number(income.amount), 0);
        const totalExpenses = financialData.expenditures.reduce((sum, exp) => sum + Number(exp.amount), 0);
        const totalAssets = financialData.assets.reduce((sum, asset) => sum + Number(asset.value), 0);
        const totalLiabilities = financialData.liabilities.reduce((sum, liability) => sum + Number(liability.amount), 0);
        const netWorth = totalAssets - totalLiabilities;
        // Create context for the AI based on user's financial data
        const userContext = `
      User Profile: ${JSON.stringify(userProfile)}
      Financial Overview:
      - Goals: ${financialData.goals.length} financial goals set
      - Total Monthly Income: £${totalIncome}
      - Total Monthly Expenses: £${totalExpenses}
      - Net Worth: £${netWorth}
      - Total Assets: £${totalAssets}
      - Total Liabilities: £${totalLiabilities}

      Detailed Goals:
      ${financialData.goals.map(goal => `- ${goal.goal}: £${goal.target_amount} in ${goal.time_horizon} years`).join('\n')}
    `;
        // Generate chat response
        const completion = await openai.chat.completions.create({
            model: 'gpt-3.5-turbo',
            messages: [
                {
                    role: 'system',
                    content: `You are a financial advisor assistant. Your role is to provide helpful financial guidance based on the user's current financial situation. Here's the context about the user:\n${userContext}`
                },
                { role: 'user', content: message }
            ]
        });
        return {
            statusCode: 200,
            headers: {
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Headers': 'Content-Type',
                'Access-Control-Allow-Methods': 'POST'
            },
            body: JSON.stringify({
                response: completion.choices[0].message.content,
                userProfile,
                financialData,
                metrics: {
                    totalIncome,
                    totalExpenses,
                    totalAssets,
                    totalLiabilities,
                    netWorth
                }
            })
        };
    }
    catch (error) {
        console.error('Error:', error);
        return {
            statusCode: 500,
            body: JSON.stringify({
                error: 'Internal server error',
                details: error instanceof Error ? error.message : 'Unknown error'
            })
        };
    }
};
exports.handler = handler;

*/

///
/*
// netlify/functions/chat.ts

import { Handler } from '@netlify/functions';
import OpenAI from 'openai';
import { createClient } from '@supabase/supabase-js';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

const supabase = createClient(
  process.env.SUPABASE_DATABASE_URL!,
  process.env.SUPABASE_ANON_KEY!
);

// Ensure the handler function is correctly exported and contains all your logic
export const handler: Handler = async (event) => {
  console.log('Function triggered', {
    method: event.httpMethod,
    body: event.body,
    headers: event.headers,
  });

  let message: string | undefined;
  let userId: string | undefined;

  try {
    const body = JSON.parse(event.body || '{}');
    message = body.message;
    userId = body.userId;

    if (!message) {
        console.error('No message provided in the request body.');
      return {
        statusCode: 400,
        body: JSON.stringify({ error: 'Message is required' }),
      };
    }
    if (!userId) {
        console.error('No userId provided in the request body.');
        return {
          statusCode: 400,
          body: JSON.stringify({ error: 'User ID is required' }),
        };
      }

    const { data: profileData, error: profileError } = await supabase
       .from('profiles')
       .select('*')
       .eq('id', userId)
       .single();


       if (profileError || !profileData) {
        console.error('Error fetching user data from Supabase:', profileError);
        return {
          statusCode: 404,
          body: JSON.stringify({ error: 'User not found in profiles table' }),
        };
      }
  
      // Fetch additional data if needed, e.g., goals, incomes
      // Example:
      const { data: goals, error: goalsError } = await supabase
        .from('goals')
        .select('*')
        .eq('client_id', userId);
  
      if (goalsError) {
        console.error('Error fetching goals data from Supabase:', goalsError);
        // Optional: Return partial data or handle gracefully
      }
  

    const completion = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [
        { role: 'system', content: 'You are a helpful financial advisor assistant.' },
        { role: 'user', content: message },
      ],
    });

    console.log('OpenAI API response:', completion);

    return {
      statusCode: 200,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*', // Consider setting this to your domain for security
      },
      body: JSON.stringify({
        response: completion.choices[0].message?.content,
        userProfile: profileData, // Include fetched profile data if needed
        userGoals: goals || [],
      }),
    };
  } catch (error: any) {
    console.error('Detailed error:', {
      name: error.name,
      message: error.message,
      stack: error.stack,
    });
    return {
      statusCode: 500,
      body: JSON.stringify({ error: 'Internal server error', details: error.message }),
    };
  }

};

*/
</file>

<file path="netlify/functions/types/financial.ts">
// netlify/functions/types/financial.ts

// Base interface for all entries
export interface BaseEntry {
  id: string;
  client_id: string;
  created_at?: string;
}

// Capacity for Loss Types
export interface CapacityFactor {
  factor: string;
  score: number;
  explanation: string;
}

export interface CapacityScore {
  score: number;
  category: string;
  factors: CapacityFactor[];
}

// Risk Assessment Types
export interface RiskScores {
  knowledgeScore: number;
  attitudeScore: number;
  capacityScore: number;
  timeframeScore: number;
  overallScore: number;
  riskCategory: string;
  capacityForLoss: CapacityScore;
}

export interface RiskAssessmentEntry extends BaseEntry {
  responses: Record<string, string>;
  calculated_scores: {
    knowledgeScore: number;
    attitudeScore: number;
    capacityScore: number;
    timeframeScore: number;
    overallScore: number;
    riskCategory: string;
    knowledge_score: number | null;
  }
  attitude_score: number | null;
  capacity_score: number | null;
  timeframe_score: number | null;
  overall_score: number | null;
  risk_category: string | null;
}

// Financial Data Types
export interface Income extends BaseEntry {
  type: string;
  amount: number;
  frequency: string;
}

export interface Expenditure extends BaseEntry {
  category: string;
  amount: number;
  frequency: string;
}

export interface Asset extends BaseEntry {
  type: string;
  description: string;
  value: number;
}

export interface Liability extends BaseEntry {
  type: string;
  description?: string;
  amount: number;
  interest_rate?: number;
}

export interface Goal extends BaseEntry {
  goal: string;
  target_amount: number;
  time_horizon: number;
}

// Metrics Types
export interface FinancialMetrics {
  monthlyIncome: number;
  monthlyExpenses: number;
  totalAssets: number;
  totalLiabilities: number;
  liquidAssets: number;
  age: number;
  yearsToRetirement: number | null;
}

export interface FinancialData {
  incomes: Income[];
  expenditures: Expenditure[];
  assets: Asset[];
  liabilities: Liability[];
  goals: Goal[];
}

// Form Types
export interface FormFields {
  retirement_age: string | number;
  planned_expenditures: string;
  retirement_type: string;
  time_horizon: string | number;
  type: string;
  description: string;
  value: number;
  amount: number;
  interest_rate: number;
  category: string;
  frequency: string;
}

export interface FormField {
  name: keyof FormFields;
  type: 'text' | 'number' | 'select';
  label: string;
  options?: { value: string; label: string }[];
}

export interface FinancialFormProps {
  formType: 'expenditures' | 'assets' | 'goals' | 'liabilities' | 'risk_assessments';
  nextRoute: string;
  stepNumber: number;
  fields: FormField[];
  defaultEntry: Record<string, any>;
}
</file>

<file path="netlify/functions/adviser-chat.js">
// netlify/functions/adviser-chat.js

// netlify/functions/adviserChat.js

const OpenAI = require('openai');

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

const generateSystemPrompt = (clientData) => {
  // Calculate key financial metrics
  const monthlyIncome = clientData.incomes.reduce((sum, inc) => 
    sum + (inc.frequency === 'Monthly' ? inc.amount : inc.amount / 12), 0);
  const annualIncome = monthlyIncome * 12;
  
  const monthlyExpenditure = clientData.expenditures.reduce((sum, exp) => 
    sum + (exp.frequency === 'Monthly' ? exp.amount : exp.amount / 12), 0);
  const annualExpenditure = monthlyExpenditure * 12;

  const totalAssets = clientData.assets.reduce((sum, asset) => sum + asset.value, 0);
  const totalLiabilities = clientData.liabilities.reduce((sum, liability) => 
    sum + liability.amount, 0);
  const netWorth = totalAssets - totalLiabilities;

  // KYC information
  const kycInfo = clientData.kyc_data ? `
    Date of Birth: ${clientData.kyc_data.date_of_birth}
    Address: ${clientData.kyc_data.address_line1}, ${clientData.kyc_data.city}
    National Insurance Number: ${clientData.kyc_data.national_insurance_number}
  ` : 'KYC data not available';

  const basePrompt = `You are a professional financial adviser in the UK analyzing client data. Use the following information to provide advice}:

  FINANCIAL SUMMARY
  ================
  Monthly Income: £${monthlyIncome.toFixed(2)}
  Annual Income: £${annualIncome.toFixed(2)}
  Monthly Expenditure: £${monthlyExpenditure.toFixed(2)}
  Annual Expenditure: £${annualExpenditure.toFixed(2)}
  Total Assets: £${totalAssets.toFixed(2)}
  Total Liabilities: £${totalLiabilities.toFixed(2)}
  Net Worth: £${netWorth.toFixed(2)}

  KYC INFORMATION
  ==============
  ${kycInfo}

  INCOME SOURCES
  =============
  ${clientData.incomes.map(inc => 
    `- ${inc.type}: £${inc.amount} (${inc.frequency})`
  ).join('\n')}

  EXPENDITURES
  ===========
  ${clientData.expenditures.map(exp => 
    `- ${exp.category}: £${exp.amount} (${exp.frequency})`
  ).join('\n')}

  ASSETS
  ======
  ${clientData.assets.map(asset => 
    `- ${asset.type}: £${asset.value} - ${asset.description}`
  ).join('\n')}

  LIABILITIES
  ==========
  ${clientData.liabilities.map(liability => 
    `- ${liability.type}: £${liability.amount} at ${liability.interest_rate}% interest`
  ).join('\n')}

  FINANCIAL GOALS
  =============
  ${clientData.goals.map(goal => 
    `- ${goal.goal}: Target £${goal.target_amount} in ${goal.time_horizon} years`
  ).join('\n')}`;

  return `${basePrompt}\n\nProvide detailed advice considering...`;

};

exports.handler = async (event) => {

    // Add CORS headers
    const headers = {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Headers': 'Content-Type',
      'Access-Control-Allow-Methods': 'POST, OPTIONS',
      'Content-Type': 'application/json'
    };

    // Handle preflight requests
    if (event.httpMethod === 'OPTIONS') {
      return {
        statusCode: 204,
        headers
      };
    }

  if (event.httpMethod !== 'POST') {
    return { statusCode: 405, body: JSON.stringify({ error: 'Method not allowed' }) };
  }

  try {
    const {
      message,
      clientData,
      messageHistory = [],
      // userId,
      // clientId
    } = JSON.parse(event.body);

    if (!message || !clientData) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: 'Missing required fields: message or clientData' })
      };
    }

    const systemPrompt = generateSystemPrompt(clientData);

    const completion = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: systemPrompt },
        ...messageHistory.map(msg => ({
          role: msg.role,
          content: msg.content
        })),
        { role: "user", content: message }
      ],
      temperature: 0.3,
      max_tokens: 1000,
    });

    return {
      statusCode: 200,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*'
      },
      body: JSON.stringify({
        response: completion.choices[0].message.content
      })
    };
  } catch (error) {
    console.error('Error:', error);
    return {
      statusCode: 500,
      body: JSON.stringify({ error: error.message })
    };
  }
};



/*

const OpenAI = require('openai');

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

const generateSystemPrompt = (clientData) => {
  // Calculate key financial metrics
  const monthlyIncome = clientData.incomes.reduce((sum, inc) => 
    sum + (inc.frequency === 'Monthly' ? inc.amount : inc.amount / 12), 0);
  const annualIncome = monthlyIncome * 12;
  
  const monthlyExpenditure = clientData.expenditures.reduce((sum, exp) => 
    sum + (exp.frequency === 'Monthly' ? exp.amount : exp.amount / 12), 0);
  const annualExpenditure = monthlyExpenditure * 12;

  const totalAssets = clientData.assets.reduce((sum, asset) => sum + asset.value, 0);
  const totalLiabilities = clientData.liabilities.reduce((sum, liability) => 
    sum + liability.amount, 0);
  const netWorth = totalAssets - totalLiabilities;

  // KYC information
  const kycInfo = clientData.kyc_data ? `
    Date of Birth: ${clientData.kyc_data.date_of_birth}
    Address: ${clientData.kyc_data.address_line1}, ${clientData.kyc_data.city}
    National Insurance Number: ${clientData.kyc_data.national_insurance_number}
  ` : 'KYC data not available';

  const basePrompt = `You are a professional financial adviser in the UK analyzing client data. Use the following information to provide advice}:

  FINANCIAL SUMMARY
  ================
  Monthly Income: £${monthlyIncome.toFixed(2)}
  Annual Income: £${annualIncome.toFixed(2)}
  Monthly Expenditure: £${monthlyExpenditure.toFixed(2)}
  Annual Expenditure: £${annualExpenditure.toFixed(2)}
  Total Assets: £${totalAssets.toFixed(2)}
  Total Liabilities: £${totalLiabilities.toFixed(2)}
  Net Worth: £${netWorth.toFixed(2)}

  KYC INFORMATION
  ==============
  ${kycInfo}

  INCOME SOURCES
  =============
  ${clientData.incomes.map(inc => 
    `- ${inc.type}: £${inc.amount} (${inc.frequency})`
  ).join('\n')}

  EXPENDITURES
  ===========
  ${clientData.expenditures.map(exp => 
    `- ${exp.category}: £${exp.amount} (${exp.frequency})`
  ).join('\n')}

  ASSETS
  ======
  ${clientData.assets.map(asset => 
    `- ${asset.type}: £${asset.value} - ${asset.description}`
  ).join('\n')}

  LIABILITIES
  ==========
  ${clientData.liabilities.map(liability => 
    `- ${liability.type}: £${liability.amount} at ${liability.interest_rate}% interest`
  ).join('\n')}

  FINANCIAL GOALS
  =============
  ${clientData.goals.map(goal => 
    `- ${goal.goal}: Target £${goal.target_amount} in ${goal.time_horizon} years`
  ).join('\n')}`;

  return `${basePrompt}\n\nProvide detailed advice considering...`;

};

exports.handler = async (event) => {
  // Add CORS headers
  const headers = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'Content-Type',
    'Access-Control-Allow-Methods': 'POST, OPTIONS',
    'Content-Type': 'application/json'
  };

  // Handle preflight requests
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 204,
      headers
    };
  }

  if (event.httpMethod !== 'POST') {
    return { 
      statusCode: 405, 
      headers,
      body: JSON.stringify({ error: 'Method not allowed' }) 
    };
  }

  try {
      const {
          message,
          clientData,
          messageHistory = [],
      } = JSON.parse(event.body);

      // Immediately send an initial acknowledgment response
      const initialResponse = {
          type: 'processing',
          response: 'Analyzing your request...'
      };

      // Start the OpenAI request
      const systemPrompt = generateSystemPrompt(clientData);
      const completion = await openai.chat.completions.create({
          model: "gpt-4o-mini",
          messages: [
              { role: "system", content: systemPrompt },
              ...messageHistory.map(msg => ({
                  role: msg.role,
                  content: msg.content
              })),
              { role: "user", content: message }
          ],
          temperature: 0.3,
          max_tokens: 500,
          stream: true // Enable streaming
      });

      // Return initial response
      return {
          statusCode: 200,
          headers,
          body: JSON.stringify({
              type: 'success',
              response: completion.choices[0].message.content,
              initialResponse: initialResponse.response
          })
      };

  } catch (error) {
      console.error('Error:', error);
      return {
          statusCode: 500,
          headers,
          body: JSON.stringify({ 
              error: error.message,
              type: 'error'
          })
      };
  }
};

*/

/*

exports.handler = async (event) => {

    // Add CORS headers
    const headers = {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Headers': 'Content-Type',
      'Access-Control-Allow-Methods': 'POST, OPTIONS',
      'Content-Type': 'application/json'
    };

    // Handle preflight requests
    if (event.httpMethod === 'OPTIONS') {
      return {
        statusCode: 204,
        headers
      };
    }

  if (event.httpMethod !== 'POST') {
    return { statusCode: 405, body: JSON.stringify({ error: 'Method not allowed' }) };
  }

  try {
    const {
      message,
      clientData,
      messageHistory = [],
      // userId,
      // clientId
    } = JSON.parse(event.body);




    const systemPrompt = generateSystemPrompt(clientData);

    const completion = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: systemPrompt },
        ...messageHistory.map(msg => ({
          role: msg.role,
          content: msg.content
        })),
        { role: "user", content: message }
      ],
      temperature: 0.3,
      max_tokens: 1000,
    });

    return {
      statusCode: 200,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*'
      },
      body: JSON.stringify({
        response: completion.choices[0].message.content
      })
    };
  } catch (error) {
    console.error('Error:', error);
    return {
      statusCode: 500,
      body: JSON.stringify({ error: error.message })
    };
  }
};


*/





/*

const OpenAI = require('openai');

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

exports.handler = async (event) => {

    // Add CORS headers
    const headers = {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Headers': 'Content-Type',
      'Access-Control-Allow-Methods': 'POST, OPTIONS'
    };

    // Handle preflight
    if (event.httpMethod === 'OPTIONS') {
      return {
        statusCode: 204,
        headers
      };
    }

    if (event.httpMethod !== 'POST') {
      return {
        statusCode: 405,
        headers,
        body: JSON.stringify({ error: 'Method not allowed' })
      };
    }

    try {
    // Add some debug logging
    console.log('Function called');
    console.log('Event:', event);
  
    if (event.httpMethod !== 'POST') {
      return { statusCode: 405, body: JSON.stringify({ error: 'Method not allowed' }) };
    }
  
    try {
      const {
        message,
        clientData,
        messageHistory = [],
        isSuitabilityReport,
        userId,
        clientId
      } = JSON.parse(event.body);
  
      console.log('Received data:', { message, clientData, isSuitabilityReport });
  
      // For initial testing, just echo back the message
      return {
        statusCode: 200,
        headers: {
          ...headers,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          response: `Test response: Received message "${message}" for client ${clientId}`
        })
      };
    } catch (error) {
      console.error('Error:', error);
      return {
        statusCode: 500,
        body: JSON.stringify({ error: error.message })
      };
    }
    } catch(error) {
        console.error('Error', error);
        return {
            statusCode: 500,
            body: JSON.stringify({ error: 'Internal server error'})
        }
    }
  };


const generateSystemPrompt = (clientData, isSuitabilityReport) => {
  // Calculate key financial metrics
  const monthlyIncome = clientData.incomes.reduce((sum, inc) => 
    sum + (inc.frequency === 'Monthly' ? inc.amount : inc.amount / 12), 0);
  const annualIncome = monthlyIncome * 12;
  
  const monthlyExpenditure = clientData.expenditures.reduce((sum, exp) => 
    sum + (exp.frequency === 'Monthly' ? exp.amount : exp.amount / 12), 0);
  const annualExpenditure = monthlyExpenditure * 12;

  const totalAssets = clientData.assets.reduce((sum, asset) => sum + asset.value, 0);
  const totalLiabilities = clientData.liabilities.reduce((sum, liability) => 
    sum + liability.amount, 0);
  const netWorth = totalAssets - totalLiabilities;

  // KYC information
  const kycInfo = clientData.kyc_data ? `
    Date of Birth: ${clientData.kyc_data.date_of_birth}
    Address: ${clientData.kyc_data.address_line1}, ${clientData.kyc_data.city}
    National Insurance Number: ${clientData.kyc_data.national_insurance_number}
  ` : 'KYC data not available';

  const basePrompt = `You are a professional financial adviser in the UK analyzing client data. Use the following information to ${isSuitabilityReport ? 'generate a detailed suitability report' : 'provide advice'}:

FINANCIAL SUMMARY
================
Monthly Income: £${monthlyIncome.toFixed(2)}
Annual Income: £${annualIncome.toFixed(2)}
Monthly Expenditure: £${monthlyExpenditure.toFixed(2)}
Annual Expenditure: £${annualExpenditure.toFixed(2)}
Total Assets: £${totalAssets.toFixed(2)}
Total Liabilities: £${totalLiabilities.toFixed(2)}
Net Worth: £${netWorth.toFixed(2)}

KYC INFORMATION
==============
${kycInfo}

INCOME SOURCES
=============
${clientData.incomes.map(inc => 
  `- ${inc.type}: £${inc.amount} (${inc.frequency})`
).join('\n')}

EXPENDITURES
===========
${clientData.expenditures.map(exp => 
  `- ${exp.category}: £${exp.amount} (${exp.frequency})`
).join('\n')}

ASSETS
======
${clientData.assets.map(asset => 
  `- ${asset.type}: £${asset.value} - ${asset.description}`
).join('\n')}

LIABILITIES
==========
${clientData.liabilities.map(liability => 
  `- ${liability.type}: £${liability.amount} at ${liability.interest_rate}% interest`
).join('\n')}

FINANCIAL GOALS
=============
${clientData.goals.map(goal => 
  `- ${goal.goal}: Target £${goal.target_amount} in ${goal.time_horizon} years`
).join('\n')}`;

  if (isSuitabilityReport) {
    return `${basePrompt}

As a UK financial adviser, generate a detailed suitability report following these guidelines:
1. Start with a clear executive summary
2. Explain your understanding of the client's circumstances and objectives
3. Detail your analysis of their current financial position
4. Outline specific recommendations with clear rationale
5. Explain any risks and disadvantages
6. Include relevant regulatory disclosures
7. Use professional but clear language
8. Structure the report with clear headings
9. Reference specific financial details from their data
10. Comply with FCA guidelines for suitability reports

Format the report professionally with clear sections and maintain a formal tone.`;
  }

  return isSuitabilityReport ?
  
  `${basePrompt}

      Provide detailed advice considering:
      1. The client's specific financial situation
      2. Their stated goals and objectives
      3. Risk management
      4. Tax efficiency
      5. Long-term sustainability
      6. Regulatory compliance

      Use the data to give specific, actionable recommendations.`:

  `${basePrompt}\n\nProvide detailed advice considering...`;

};

exports.handler = async (event) => {

    // Add CORS headers
    const headers = {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Headers': 'Content-Type',
      'Access-Control-Allow-Methods': 'POST, OPTIONS',
      'Content-Type': 'application/json'
    };

    // Handle preflight requests
    if (event.httpMethod === 'OPTIONS') {
      return {
        statusCode: 204,
        headers
      };
    }

  if (event.httpMethod !== 'POST') {
    return { statusCode: 405, body: JSON.stringify({ error: 'Method not allowed' }) };
  }

  try {
    const {
      message,
      clientData,
      messageHistory = [],
      isSuitabilityReport,
      userId,
      clientId
    } = JSON.parse(event.body);

    // Add dropdown's to enable selection of model, temperatures, max_tokens
    // pull from chat gpt
    // Add Claude as an option later

    // Temperature dictates randomness and specificity
    // 0 > 1 
    // Max tokens dictates the processing power allocated to the query
    // 100 - 100000

    const systemPrompt = generateSystemPrompt(clientData, isSuitabilityReport);

    const completion = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: systemPrompt },
        ...messageHistory.map(msg => ({
          role: msg.role,
          content: msg.content
        })),
        { role: "user", content: message }
      ],
      temperature: isSuitabilityReport ? 0.3 : 0.7,
      max_tokens: isSuitabilityReport ? 2000 : 500
    });

    return {
      statusCode: 200,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*'
      },
      body: JSON.stringify({
        response: completion.choices[0].message.content
      })
    };
  } catch (error) {
    console.error('Error:', error);
    return {
      statusCode: 500,
      body: JSON.stringify({ error: error.message })
    };
  }
};

*/
</file>

<file path="netlify/functions/chatbot.js">
// netlify/functions/chatbot.js

const OpenAI = require('openai');

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

const calculateMonthlyIncome = (incomes) => {
    return incomes.reduce((sum, inc) => {
      const amount = parseFloat(inc.amount) || 0;
      // Convert annual income to monthly
      return sum + (inc.frequency.toLowerCase() === 'annual' ? amount / 12 : amount);
    }, 0);
  };
  
  const calculateAnnualIncome = (incomes) => {
    return incomes.reduce((sum, inc) => {
      const amount = parseFloat(inc.amount) || 0;
      // Convert monthly income to annual
      return sum + (inc.frequency.toLowerCase() === 'monthly' ? amount * 12 : amount);
    }, 0);
  };

  const calculateMonthlyExpenditure = (expenditures) => {
    return expenditures.reduce((sum, exp) => {
        const amount = parseFloat(exp.amount) || 0;
        return sum + (exp.frequency.toLowerCase() === 'annual'? amount / 12 : amount);
    }, 0)
  }

  const calculateAnnualExpenditure = (expenditures) => {
    return expenditures.reduce((sum, exp) => {
        const amount = parseFloat(exp.amount) || 0;
        return sum + (exp.frequency.toLowerCase() === 'monthly'? amount * 12 : amount);
    }, 0)
  }


  const systemMessage = (financialData) => { 

        const monthlyIncome = calculateMonthlyIncome(financialData.incomes);
        const annualIncome = calculateAnnualIncome(financialData.incomes);
        const monthlyExpenditure = calculateMonthlyExpenditure(financialData.expenditures);
        const annualExpenditure = calculateAnnualExpenditure(financialData.expenditures);
        const totalExpenditure = financialData.expenditures.reduce((sum, exp) => sum + exp.amount, 0);
        const totalAssets = financialData.assets.reduce((sum, asset) => sum + asset.value, 0);
        const totalLiabilities = financialData.liabilities.reduce((sum, liability) => sum + liability.amount, 0);
        const netWorth = totalAssets - totalLiabilities;

        let age = null;
        let yearsUntilRetirement = null;
        let retirementAge = null;

        // Get KYC data if available
        if (financialData.kyc_data && financialData.kyc_data.date_of_birth) {
          const today = new Date();
          const birth = new Date(financialData.kyc_data.date_of_birth);
          
          // Calculate age
          let currentAge = today.getFullYear() - birth.getFullYear();
          const monthDiff = today.getMonth() - birth.getMonth();
          if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
              currentAge--;
          }
          age = currentAge;

          // Get retirement goals if available
          const retirementGoal = financialData.goals.find(goal => 
              goal.goal.toLowerCase().includes('retirement'));
          
          if (retirementGoal) {
              retirementAge = age + retirementGoal.time_horizon;
              yearsUntilRetirement = retirementGoal.time_horizon;
          }
      }
    
        return `You are a financial advisor assistant in the UK with access to the user's current financial data. 
        Base your advice on their actual financial situation as shown below:

        PERSONAL INFORMATION
        ===================
        ${age ? `Current Age: ${age} years old` : 'Age: Not provided'}
        ${retirementAge ? `Target Retirement Age: ${retirementAge}` : ''}
        ${yearsUntilRetirement ? `Years until retirement: ${yearsUntilRetirement}` : ''}

        FINANCIAL OVERVIEW
        =================
        Monthly Income: £${monthlyIncome.toFixed(2)}
        Annual Income: £${annualIncome.toFixed(2)}
        Monthly Expenses: £${monthlyExpenditure.toFixed(2)}
        Annual Expenses: £${annualExpenditure.toFixed(2)}
        Monthly Cash Flow: £${(annualIncome - totalExpenditure).toFixed(2)}
        Total Assets: £${totalAssets.toFixed(2)}
        Total Liabilities: £${totalLiabilities.toFixed(2)}
        Net Worth: £${netWorth.toFixed(2)}

        DETAILED BREAKDOWN
        =================
        Income Sources:
        ${financialData.incomes.map((inc) => `- ${inc.type}: £${inc.amount} (${inc.frequency})`).join('\n') || 'No income data available'}

        Expense Sources:
        ${financialData.expenditures.map((exp) => `- ${exp.category}: £${exp.amount}`).join('\n') || 'No expense data available'}

        Assets:
        ${financialData.assets.map((asset) => `- ${asset.type}: £${asset.value} - ${asset.description}`).join('\n') || 'No asset data available'}

        Liabilities:
        ${financialData.liabilities.map((liability) => `- ${liability.type}: £${liability.amount} at ${liability.interest_rate || 0}% interest`).join('\n') || 'No liability data available'}

        Financial Goals:
        ${financialData.goals.map((goal) => `- ${goal.goal}: Target £${goal.target_amount} in ${goal.time_horizon} years`).join('\n') || 'No goals set'}
       
        
        Please use this data to answer the user's question in detail, considering their:
        1. Income
        2. Expenses
        3. Assets
        4. Liabilities
        5. Financial Goals

        When responding:
        1. Always reference specific numbers from their data
        2. Make recommendations based on their actual income, expenses, and goals
        3. Provide specific, actionable advice
        4. Explain how their current finances align with their goals
        5. Consider their income, expenses, assets, and liabilities in your analysis

        Provide actionable and personalized advice based on the provided data.`;

  }


const handler = async (event) => {
    if (event.httpMethod === 'OPTIONS') {
      return {
        statusCode: 204,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Headers': 'Content-Type',
          'Access-Control-Allow-Methods': 'POST, OPTIONS'
        }
      };
    }
    
  if (event.httpMethod !== 'POST') {
    return { statusCode: 405, body: JSON.stringify({ error: 'Method not allowed' }) };
  }

  try {
    const { message, messageHistory = [], financialData } = JSON.parse(event.body || '{}');

    // Validate message content
    if (!message || typeof message !== 'string') {
        return {
          statusCode: 400,
          body: JSON.stringify({ error: 'Invalid message format' })
        };
      }

    console.log('Received Financial Data:', {
        incomes: financialData.incomes,
        expenditureCount: financialData.expenditures.length,
        assetCount: financialData.assets.length,
        liabilityCount: financialData.liabilities.length,
        goalCount: financialData.goals.length
    });

    const systemPrompt = systemMessage(financialData);


    const completion = await openai.chat.completions.create({
      model: "gpt-4o-mini-2024-07-18",
      messages: [
            { role: "system", content: systemPrompt },
            ...messageHistory.slice(-3),
            { role: "user", content: message }
          ],
          temperature: 0.7,
          max_tokens: 1000
    });

    return {
      statusCode: 200,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*'
      },
      body: JSON.stringify({ response: completion.choices[0].message.content })
    };
  } catch (error) {
    return {
      statusCode: 500,
      body: JSON.stringify({ error: String(error) })
    };
  }
};

// Export both ways to ensure compatibility
console.log('Handler is being invoked');
exports.handler = async (event) => {
    console.log('Event:', event);
};

exports.handler = handler;
module.exports = { handler };
</file>

<file path="netlify/functions/chatbot.txt">
// netlify/functions/chatbot.ts
/*
import { Handler } from '@netlify/functions'
import { createClient } from '@supabase/supabase-js'

const supabaseUrl = process.env.REACT_APP_SUPABASE_DATABASE_URL!
const supabaseAnonKey = process.env.REACT_APP_SUPABASE_ANON_KEY!
const supabase = createClient(supabaseUrl, supabaseAnonKey)

const handler: Handler = async (event, context) => {
  // Only allow POST
  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      body: JSON.stringify({ error: 'Method not allowed' })
    }
  }

  try {
    const { userId, query } = JSON.parse(event.body || '{}')

    if (!userId || !query) {
      return {
        statusCode: 400,
        body: JSON.stringify({ error: 'Missing userId or query' })
      }
    }

    // Fetch user's financial data from Supabase
    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', userId)
      .single()

    if (profileError) {
      throw new Error(`Error fetching profile: ${profileError.message}`)
    }

    // Generate response based on user's data and query
    // For now, returning a simple response
    const response = `Hello! I understand you're asking about: "${query}". 
                     I can see your profile and help you with financial planning.`

    return {
      statusCode: 200,
      headers: {
        'Content-Type': 'application/json',
        // Add CORS headers
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type',
        'Access-Control-Allow-Methods': 'POST'
      },
      body: JSON.stringify({ response })
    }
  } catch (error) {
    console.error('Error:', error)
    return {
      statusCode: 500,
      body: JSON.stringify({ error: 'Internal server error' })
    }
  }
}

export { handler }

*/
</file>

<file path="netlify/functions/chatbotbackup.txt">
/*
    // Check for errors
    if (incomesError || expendituresError || assetsError || liabilitiesError || goalsError) {
      console.error('Database errors:', {
        incomesError,
        expendituresError,
        assetsError,
        liabilitiesError,
        goalsError
      });
      throw new Error('Error fetching financial data');
    }

      totalIncome: incomes.reduce((sum, income) => 
        sum + (income.amount * (income.frequency === 'Monthly' ? 1 : 1 / 12)), 0),
      totalExpenditure: expenditures.reduce((sum, expenditure) => sum + expenditure.amount, 0),
      totalAssets: assets.reduce((sum, asset) => sum + asset.value, 0),
      totalLiabilities: liabilities.reduce((sum, liability) => sum + liability.amount, 0)
      
      
      const mappedIncomes: Income[] = (incomes || []).map(income => ({
        id: income.id || '', // Ensure `id` is always present
        client_id: income.client_id || '',
        type: income.type || 'Unknown', // Provide default values for missing fields
        amount: Number(income.amount) || 0,
        frequency: income.frequency || 'Monthly',
      }));

    const mappedExpenditures: Expenditure[] = (expenditures || []).map(exp => ({
      id: exp.id || '',
      client_id: exp.client_id || '',
      category: exp.category || 'Other',
      amount: Number(exp.amount) || 0,
      frequency: exp.frequency || 'Monthly',
    }));

    const mappedAssets: Asset[] = (assets || []).map(asset => ({
      id: asset.id || '',
      client_id: asset.client_id || '',
      type: asset.type || 'Unknown',
      description: asset.description || '',
      value: Number(asset.value) || 0,
    }));

    const mappedLiabilities: Liability[] = (liabilities || []).map(liability => ({
      id: liability.id || '',
      client_id: liability.client_id || '',
      type: liability.type || 'Other',
      description: liability.description || '',
      amount: Number(liability.amount) || 0,
      interest_rate: Number(liability.interest_rate) || 0,
    }));

    const mappedGoals: Goal[] = (goals || []).map(goal => ({
      id: goal.id || '',
      client_id: goal.client_id || '',
      goal: goal.goal || 'Unknown',
      target_amount: Number(goal.target_amount) || 0,
      time_horizon: Number(goal.time_horizon) || 0,
    }));

    const financialData: FinancialData = {
      incomes: mappedIncomes, // Use an empty array if incomes is null
      expenditures: mappedExpenditures, // Use an empty array if expenditures is null
      assets: mappedAssets, // Use an empty array if assets is null
      liabilities: mappedLiabilities, // Use an empty array if liabilities is null
      goals: mappedGoals // Use an empty array if goals is null
    };

    const totalIncome = financialData.incomes.reduce((sum: number, income) => sum + income.amount, 0);
    const totalExpenditure = financialData.expenditures.reduce((sum: number, exp: any) => sum + exp.amount, 0);
    const totalLiabilities = financialData.liabilities.reduce((sum, liability) => sum + liability.amount, 0);
    const totalAssets = financialData.assets.reduce((sum, asset) => sum + asset.value, 0);
    const netWorth = totalAssets - totalLiabilities;




  const financialSummary = createFinancialSummary(financialData);
  console.log('Generated financial summary:', financialSummary);

  const systemMessage = `You are a financial advisor assistant with access to the user's current financial data. 
Base your advice on their actual financial situation as shown below:

Monthly Income: £${totalIncome ? totalIncome.toFixed(2) : 'Not provided'}
Monthly Expenses: £${totalExpenditure.toFixed(2)}
Monthly Cash Flow: £${(totalIncome - totalExpenditure).toFixed(2)}
Total Assets: £${totalAssets.toFixed(2)}
Total Liabilities: £${totalLiabilities.toFixed(2)}
Net Worth: £${netWorth.toFixed(2)}

DETAILED BREAKDOWN
=================
Income Sources:
${financialData.incomes.map((inc) => `- ${inc.type}: £${inc.amount} (${inc.frequency})`).join('\n') || 'No income data available'}

Monthly Expenses:
${financialData.expenditures.map((exp) => `- ${exp.category}: £${exp.amount}`).join('\n') || 'No expense data available'}

Assets:
${financialData.assets.map((asset) => `- ${asset.type}: £${asset.value} - ${asset.description}`).join('\n') || 'No asset data available'}

Liabilities:
${financialData.liabilities.map((liability) => `- ${liability.type}: £${liability.amount} at ${liability.interest_rate}% interest`).join('\n') || 'No liability data available'}

Financial Goals:
${financialData.goals.map((goal) => `- ${goal.goal}: Target £${goal.target_amount} in ${goal.time_horizon} years`).join('\n') || 'No goals set'}

Please use this data to answer the user's question in detail, considering their:
1. Income
2. Expenses
3. Assets
4. Liabilities
5. Financial Goals

When responding:
1. Always reference specific numbers from their data
2. Make recommendations based on their actual income, expenses, and goals
3. Provide specific, actionable advice
4. Explain how their current finances align with their goals
5. Consider their income, expenses, assets, and liabilities in your analysis

Provide actionable and personalized advice based on the provided data.

`;


// netlify/functions/chatbot.ts

import { Handler } from '@netlify/functions';
import OpenAI from 'openai';
import { createClient } from '@supabase/supabase-js';
import { Income, Expenditure, Asset, Liability, Goal, FinancialData } from './types/financial';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

const supabase = createClient(
  process.env.REACT_APP_SUPABASE_DATABASE_URL!,
  process.env.REACT_APP_SUPABASE_ANON_KEY!
);

interface RequestBody {
  message: string;
  userId: string;
  financialData: FinancialData;
  messageHistory?: { role: string; content: string; }[];
}

const createFinancialSummary = (data: FinancialData): string => {
  const totalIncome = data.incomes.reduce((sum, inc) => sum + inc.amount, 0);
  const totalExpenditure = data.expenditures.reduce((sum, exp) => sum + exp.amount, 0);
  const totalAssets = data.assets.reduce((sum, asset) => sum + asset.value, 0);
  const totalLiabilities = data.liabilities.reduce((sum, liability) => sum + liability.amount, 0);
  const netWorth = totalAssets - totalLiabilities;

  if (!data.incomes || !data.incomes.length) {
    console.log('No income data available');
    return 'No income data available';
  }
  
  return `
FINANCIAL OVERVIEW
=================
Monthly Income: £${totalIncome.toFixed(2)}
Monthly Expenses: £${totalExpenditure.toFixed(2)}
Monthly Cash Flow: £${(totalIncome - totalExpenditure).toFixed(2)}
Total Assets: £${totalAssets.toFixed(2)}
Total Liabilities: £${totalLiabilities.toFixed(2)}
Net Worth: £${netWorth.toFixed(2)}

DETAILED BREAKDOWN
=================
Income Sources:
${data.incomes.map((inc) => `- ${inc.type}: £${inc.amount} (${inc.frequency})`).join('\n') || 'No income data available'}

Monthly Expenses:
${data.expenditures.map((exp) => `- ${exp.category}: £${exp.amount}`).join('\n') || 'No expense data available'}

Assets:
${data.assets.map((asset) => `- ${asset.type}: £${asset.value} - ${asset.description}`).join('\n') || 'No asset data available'}

Liabilities:
${data.liabilities.map((liability) => `- ${liability.type}: £${liability.amount} at ${liability.interest_rate}% interest`).join('\n') || 'No liability data available'}

Financial Goals:
${data.goals.map((goal) => `- ${goal.goal}: Target £${goal.target_amount} in ${goal.time_horizon} years`).join('\n') || 'No goals set'}
`;

};

export const handler: Handler = async (event) => {
  console.log('Function invoked');
  
  if (event.httpMethod !== 'POST') {
    return { statusCode: 405, body: JSON.stringify({ error: 'Method not allowed' }) };
  }

  try {
    const { message, userId, messageHistory = [] } = JSON.parse(event.body || '{}');
    console.log('Received request for userId:', userId);
    
    if (!message || !userId) {
      return {
        statusCode: 400,
        body: JSON.stringify({ error: 'Message and userId are required' })
      };
    }

        // Test Supabase connection
        console.log('Testing Supabase connection...');
        try {
          const { data: testData, error: testError } = await supabase
            .from('profiles')
            .select('count')
            .single();
          console.log('Supabase connection test:', { success: !testError, error: testError });
        } catch (dbError) {
          console.error('Supabase connection test failed:', dbError);
        }
    
        // Fetch user's financial data
        console.log('Fetching user data from Supabase for userId:', userId);
        
        // Fetch and log profile first
        const { data: profile, error: profileError } = await supabase
          .from('profiles')
          .select('*')
          .eq('id', userId)
          .single();
        
        console.log('Profile fetch result:', {
          success: !profileError,
          hasProfile: !!profile,
          profileError
        });
    

    // Fetch financial data
    console.log('Fetching financial data...');
    const [
      { data: incomes, error: incomesError },
      { data: expenditures, error: expendituresError },
      { data: assets, error: assetsError },
      { data: liabilities, error: liabilitiesError },
      { data: goals, error: goalsError }
    ] = await Promise.all([
      supabase.from('incomes').select('id, client_id, type, amount, frequency').eq('client_id', userId),
      supabase.from('expenditures').select('id, client_id, category, amount, frequency').eq('client_id', userId),
      supabase.from('assets').select('id, client_id, type, description, value').eq('client_id', userId),
      supabase.from('liabilities').select('id, client_id, type, amount, description, interest_rate').eq('client_id', userId),
      supabase.from('goals').select('id, client_id, goal, target_amount, time_horizon').eq('client_id', userId),
    ]);

    // Log data retrieval results
    console.log('Retrieved data:', {
      incomesCount: incomes?.length || 0,
      expendituresCount: expenditures?.length || 0,
      assetsCount: assets?.length || 0,
      liabilitiesCount: liabilities?.length || 0,
      goalsCount: goals?.length || 0
    });

    // Check for errors
    if (incomesError || expendituresError || assetsError || liabilitiesError || goalsError) {
      console.error('Database errors:', {
        incomesError,
        expendituresError,
        assetsError,
        liabilitiesError,
        goalsError
      });
      throw new Error('Error fetching financial data');
    }

      /*totalIncome: incomes.reduce((sum, income) => 
        sum + (income.amount * (income.frequency === 'Monthly' ? 1 : 1 / 12)), 0),
      totalExpenditure: expenditures.reduce((sum, expenditure) => sum + expenditure.amount, 0),
      totalAssets: assets.reduce((sum, asset) => sum + asset.value, 0),
      totalLiabilities: liabilities.reduce((sum, liability) => sum + liability.amount, 0)
      
      
        const mappedIncomes: Income[] = (incomes || []).map(income => ({
          id: income.id || '', // Ensure `id` is always present
          client_id: income.client_id || '',
          type: income.type || 'Unknown', // Provide default values for missing fields
          amount: Number(income.amount) || 0,
          frequency: income.frequency || 'Monthly',
        }));

      const mappedExpenditures: Expenditure[] = (expenditures || []).map(exp => ({
        id: exp.id || '',
        client_id: exp.client_id || '',
        category: exp.category || 'Other',
        amount: Number(exp.amount) || 0,
        frequency: exp.frequency || 'Monthly',
      }));

      const mappedAssets: Asset[] = (assets || []).map(asset => ({
        id: asset.id || '',
        client_id: asset.client_id || '',
        type: asset.type || 'Unknown',
        description: asset.description || '',
        value: Number(asset.value) || 0,
      }));

      const mappedLiabilities: Liability[] = (liabilities || []).map(liability => ({
        id: liability.id || '',
        client_id: liability.client_id || '',
        type: liability.type || 'Other',
        description: liability.description || '',
        amount: Number(liability.amount) || 0,
        interest_rate: Number(liability.interest_rate) || 0,
      }));

      const mappedGoals: Goal[] = (goals || []).map(goal => ({
        id: goal.id || '',
        client_id: goal.client_id || '',
        goal: goal.goal || 'Unknown',
        target_amount: Number(goal.target_amount) || 0,
        time_horizon: Number(goal.time_horizon) || 0,
      }));

      const financialData: FinancialData = {
        incomes: mappedIncomes, // Use an empty array if incomes is null
        expenditures: mappedExpenditures, // Use an empty array if expenditures is null
        assets: mappedAssets, // Use an empty array if assets is null
        liabilities: mappedLiabilities, // Use an empty array if liabilities is null
        goals: mappedGoals // Use an empty array if goals is null
      };

      const totalIncome = financialData.incomes.reduce((sum: number, income) => sum + income.amount, 0);
      const totalExpenditure = financialData.expenditures.reduce((sum: number, exp: any) => sum + exp.amount, 0);
      const totalLiabilities = financialData.liabilities.reduce((sum, liability) => sum + liability.amount, 0);
      const totalAssets = financialData.assets.reduce((sum, asset) => sum + asset.value, 0);
      const netWorth = totalAssets - totalLiabilities;




    const financialSummary = createFinancialSummary(financialData);
    console.log('Generated financial summary:', financialSummary);

    const systemMessage = `You are a financial advisor assistant with access to the user's current financial data. 
Base your advice on their actual financial situation as shown below:

Monthly Income: £${totalIncome ? totalIncome.toFixed(2) : 'Not provided'}
Monthly Expenses: £${totalExpenditure.toFixed(2)}
Monthly Cash Flow: £${(totalIncome - totalExpenditure).toFixed(2)}
Total Assets: £${totalAssets.toFixed(2)}
Total Liabilities: £${totalLiabilities.toFixed(2)}
Net Worth: £${netWorth.toFixed(2)}

DETAILED BREAKDOWN
=================
Income Sources:
${financialData.incomes.map((inc) => `- ${inc.type}: £${inc.amount} (${inc.frequency})`).join('\n') || 'No income data available'}

Monthly Expenses:
${financialData.expenditures.map((exp) => `- ${exp.category}: £${exp.amount}`).join('\n') || 'No expense data available'}

Assets:
${financialData.assets.map((asset) => `- ${asset.type}: £${asset.value} - ${asset.description}`).join('\n') || 'No asset data available'}

Liabilities:
${financialData.liabilities.map((liability) => `- ${liability.type}: £${liability.amount} at ${liability.interest_rate}% interest`).join('\n') || 'No liability data available'}

Financial Goals:
${financialData.goals.map((goal) => `- ${goal.goal}: Target £${goal.target_amount} in ${goal.time_horizon} years`).join('\n') || 'No goals set'}

Please use this data to answer the user's question in detail, considering their:
1. Income
2. Expenses
3. Assets
4. Liabilities
5. Financial Goals

When responding:
1. Always reference specific numbers from their data
2. Make recommendations based on their actual income, expenses, and goals
3. Provide specific, actionable advice
4. Explain how their current finances align with their goals
5. Consider their income, expenses, assets, and liabilities in your analysis

Provide actionable and personalized advice based on the provided data.

`;

    // Create completion
    const completion = await openai.chat.completions.create({
      model: "gpt-3.5-turbo-16k",
      messages: [
        { role: "system", content: systemMessage },
        ...messageHistory,
        { role: "user", content: message }
      ],
      temperature: 0.7,
      max_tokens: 1500
    });
    
    console.log('Prompt to OpenAI:', [
      { role: 'system', content: systemMessage },
      ...messageHistory,
      { role: 'user', content: message }
    ]);

    console.log('OpenAI Prompt:', {
      systemMessage,
      messageHistory,
      userMessage: message
    });
    

    return {
      statusCode: 200,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type',
        'Access-Control-Allow-Methods': 'POST'
      },
      body: JSON.stringify({
        success: true,
        response: completion.choices[0].message.content,
        debug: {
          hasData: {
            incomes: !!incomes?.length,
            expenditures: !!expenditures?.length,
            assets: !!assets?.length,
            liabilities: !!liabilities?.length,
            goals: !!goals?.length
          }
        }
      })
    };
  } catch (error) {
    console.error('Error:', error);
    return {
      statusCode: 500,
      body: JSON.stringify({ 
        error: 'Server error',
        details: error instanceof Error ? error.message : 'Unknown error'
      })
    };
  }
};

/*
// netlify/functions/chatbot.ts

import { Handler } from '@netlify/functions';
import OpenAI from 'openai';



const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

const systemPrompt = You are a helpful financial advisor assistant. Your role is to:
- Provide clear, practical financial guidance
- Explain financial concepts in simple terms
- Help users make informed decisions about their finances
- Give complete, well-structured responses
- Use bullet points and numbering for clarity
- Always finish your thoughts and never leave sentences incomplete

Remember to be professional, clear, and thorough in your responses.;

export const handler: Handler = async (event) => {
  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      body: JSON.stringify({ error: 'Method not allowed' })
    };
  }

  try {
    const { message, messageHistory = [] } = JSON.parse(event.body || '{}');
    
    if (!message) {
      return {
        statusCode: 400,
        body: JSON.stringify({ error: 'Message is required' })
      };
    }

    // Construct messages array with history
    const messages = [
      { role: "system", content: systemPrompt },
      ...messageHistory,
      { role: "user", content: message }
    ];

    const completion = await openai.chat.completions.create({
      model: "gpt-3.5-turbo",
      messages: messages,
      temperature: 0.7,
      max_tokens: 1000, // Increased token limit
      presence_penalty: 0.6, // Encourages covering new ground
      frequency_penalty: 0.4 // Reduces repetition
    });

    const response = completion.choices[0].message.content;

    return {
      statusCode: 200,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type',
        'Access-Control-Allow-Methods': 'POST'
      },
      body: JSON.stringify({
        success: true,
        response
      })
    };
  } catch (error) {
    console.error('Error:', error);
    return {
      statusCode: 500,
      body: JSON.stringify({ 
        error: 'Server error',
        details: error instanceof Error ? error.message : 'Unknown error'
      })
    };
  }
};


// netlify/functions/chatbot.ts

import { Handler } from '@netlify/functions';
import OpenAI from 'openai';

const handler: Handler = async (event) => {
  try {
    // Log environment variable presence (not the actual value)
    console.log('OpenAI API Key exists:', !!process.env.OPENAI_API_KEY);
    
    const openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });

    // Simple test request
    try {
      const test = await openai.chat.completions.create({
        model: "gpt-3.5-turbo",
        messages: [{ role: "user", content: "test" }],
      });
      
      return {
        statusCode: 200,
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          success: true,
          message: 'OpenAI API connection successful',
          response: test.choices[0].message.content
        })
      };
    } catch (apiError) {
      console.error('OpenAI API Error:', apiError);
      return {
        statusCode: 500,
        body: JSON.stringify({
          error: 'OpenAI API Error',
          details: apiError instanceof Error ? apiError.message : 'Unknown API error'
        })
      };
    }
  } catch (error) {
    console.error('Function Error:', error);
    return {
      statusCode: 500,
      body: JSON.stringify({
        error: 'Function Error',
        details: error instanceof Error ? error.message : 'Unknown error'
      })
    };
  }
};

export { handler };



// netlify/functions/chatbot.ts

import { Handler } from '@netlify/functions';
import OpenAI from 'openai';
import { createClient } from '@supabase/supabase-js';

interface ChatRequestBody {
  userId: string;
  message: string;
}

interface UserProfile {
  id: string;
  name: string;
  email: string;
  role: string;
  adviser_id?: string;
}

interface FinancialData {
  goals: any[];
  incomes: any[];
  expenditures: any[];
  assets: any[];
  liabilities: any[];
}

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

const supabase = createClient(
  process.env.REACT_APP_SUPABASE_DATABASE_URL!,
  process.env.REACT_APP_SUPABASE_ANON_KEY!
);

const handler: Handler = async (event) => {
  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      body: JSON.stringify({ error: 'Method not allowed' })
    };
  }

  try {
    const { userId, message } = JSON.parse(event.body || '{}') as ChatRequestBody;

    if (!userId || !message) {
      return {
        statusCode: 400,
        body: JSON.stringify({ error: 'Missing userId or message' })
      };
    }

    // Fetch user's profile and financial data
    const [
      profileResult,
      goalsResult,
      incomesResult,
      expendituresResult,
      assetsResult,
      liabilitiesResult
    ] = await Promise.all([
      supabase.from('profiles').select('*').eq('id', userId).single(),
      supabase.from('goals').select('*').eq('client_id', userId),
      supabase.from('incomes').select('*').eq('client_id', userId),
      supabase.from('expenditures').select('*').eq('client_id', userId),
      supabase.from('assets').select('*').eq('client_id', userId),
      supabase.from('liabilities').select('*').eq('client_id', userId)
    ]);

    if (profileResult.error) {
      
    }

    const userProfile = profileResult.data as UserProfile;
    
    // Convert null to empty arrays
    const financialData: FinancialData = {
      goals: goalsResult.data || [],
      incomes: incomesResult.data || [],
      expenditures: expendituresResult.data || [],
      assets: assetsResult.data || [],
      liabilities: liabilitiesResult.data || []
    };

    // Calculate financial metrics
    const totalIncome = financialData.incomes.reduce((sum, income) => sum + Number(income.amount), 0);
    const totalExpenses = financialData.expenditures.reduce((sum, exp) => sum + Number(exp.amount), 0);
    const totalAssets = financialData.assets.reduce((sum, asset) => sum + Number(asset.value), 0);
    const totalLiabilities = financialData.liabilities.reduce((sum, liability) => sum + Number(liability.amount), 0);
    const netWorth = totalAssets - totalLiabilities;

    // Create context for the AI based on user's financial data
    const userContext = 
      User Profile: $ {JSON.stringify(userProfile)}
      Financial Overview:
      Income: £$ {financialContext.income || 'Not provided'}
      Assets: £$ {financialContext.assets || 'Not provided'}
      Liabilities: £$ {financialContext.liabilities || 'Not provided'}
      Expenditures:
     

      Detailed Goals:
     ;

    // Generate chat response
    const completion = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [
        {
          role: 'system',
          content: You are a financial advisor assistant. Your role is to provide helpful financial guidance based on the user's current financial situation. Here's the context about the user:\n${userContext}`
        },
        { role: 'user', content: message }
      ]
    });

    return {
      statusCode: 200,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type',
        'Access-Control-Allow-Methods': 'POST'
      },
      body: JSON.stringify({
        response: completion.choices[0].message.content,
        userProfile,
        financialData,
        metrics: {
          totalIncome,
          totalExpenses,
          totalAssets,
          totalLiabilities,
          netWorth
        }
      })
    };
  } catch (error) {
    console.error('Error:', error);
    return {
      statusCode: 500,
      body: JSON.stringify({ 
        error: 'Internal server error',
        details: error instanceof Error ? error.message : 'Unknown error'
      })
    };
  }
};

export { handler };


// netlify/functions/chat.ts

import { Handler } from '@netlify/functions';
import OpenAI from 'openai';
import { createClient } from '@supabase/supabase-js';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

const supabase = createClient(
  process.env.SUPABASE_DATABASE_URL!,
  process.env.SUPABASE_ANON_KEY!
);

// Ensure the handler function is correctly exported and contains all your logic
export const handler: Handler = async (event) => {
  console.log('Function triggered', {
    method: event.httpMethod,
    body: event.body,
    headers: event.headers,
  });

  let message: string | undefined;
  let userId: string | undefined;

  try {
    const body = JSON.parse(event.body || '{}');
    message = body.message;
    userId = body.userId;

    if (!message) {
        console.error('No message provided in the request body.');
      return {
        statusCode: 400,
        body: JSON.stringify({ error: 'Message is required' }),
      };
    }
    if (!userId) {
        console.error('No userId provided in the request body.');
        return {
          statusCode: 400,
          body: JSON.stringify({ error: 'User ID is required' }),
        };
      }

    const { data: profileData, error: profileError } = await supabase
       .from('profiles')
       .select('*')
       .eq('id', userId)
       .single();


       if (profileError || !profileData) {
        console.error('Error fetching user data from Supabase:', profileError);
        return {
          statusCode: 404,
          body: JSON.stringify({ error: 'User not found in profiles table' }),
        };
      }
  
      // Fetch additional data if needed, e.g., goals, incomes
      // Example:
      const { data: goals, error: goalsError } = await supabase
        .from('goals')
        .select('*')
        .eq('client_id', userId);
  
      if (goalsError) {
        console.error('Error fetching goals data from Supabase:', goalsError);
        // Optional: Return partial data or handle gracefully
      }
  

    const completion = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [
        { role: 'system', content: 'You are a helpful financial advisor assistant.' },
        { role: 'user', content: message },
      ],
    });

    console.log('OpenAI API response:', completion);

    return {
      statusCode: 200,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*', // Consider setting this to your domain for security
      },
      body: JSON.stringify({
        response: completion.choices[0].message?.content,
        userProfile: profileData, // Include fetched profile data if needed
        userGoals: goals || [], 
      }),
    };
  } catch (error: any) {
    console.error('Detailed error:', {
      name: error.name,
      message: error.message,
      stack: error.stack,
    });
    return {
      statusCode: 500,
      body: JSON.stringify({ error: 'Internal server error', details: error.message }),
    };
  }

};

*/
</file>

<file path="netlify/functions/chatbotts.txt">
/*
import { HandlerEvent } from "@netlify/functions";

const { Handler } = require('@netlify/functions');
const OpenAI = require('openai');

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

const handler = async (event: HandlerEvent) => {
  if (event.httpMethod !== 'POST') {
    return { statusCode: 405, body: JSON.stringify({ error: 'Method not allowed' }) };
  }

  try {
    const { message, financialData } = JSON.parse(event.body || '{}');
    
    const summary = `
      Annual Income: £${financialData.incomes[0].amount}
      Monthly Expenses: £${financialData.expenditures.reduce((sum, e) => sum + e.amount, 0)}
      Total Assets: £${financialData.assets[0].value}
      Total Liabilities: £${financialData.liabilities[0].amount}
    `;

    const completion = await openai.chat.completions.create({
      model: "gpt-3.5-turbo",
      messages: [
        { role: "system", content: `You are a financial advisor. Client data:\n${summary}` },
        { role: "user", content: message }
      ]
    });

    return {
      statusCode: 200,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*'
      },
      body: JSON.stringify({ response: completion.choices[0].message.content })
    };
  } catch (error) {
    return {
      statusCode: 500,
      body: JSON.stringify({ error: String(error) })
    };
  }
};

module.exports = { handler };


// netlify/functions/chatbot.ts

import { Handler, HandlerEvent } from '@netlify/functions';
import OpenAI from 'openai';
import { createClient } from '@supabase/supabase-js';
import { Goal, Expenditure, FinancialData, Income, Asset, Liability, RequestBody } from './types/financial';


const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});


export const handler: Handler = async (event) => {
  if (event.httpMethod !== 'POST') {
    return { statusCode: 405, body: JSON.stringify({ error: 'Method not allowed' }) };
  }

  try {
    const { message, financialData } = JSON.parse(event.body || '{}') as RequestBody;

    const monthlyIncome = data.incomes.reduce((sum, income) => sum + income.amount, 0) / 12;
      const totalMonthlyExpenses = data.expenditures.reduce((sum: number, exp: Expenditure) => sum + exp.amount, 0);
      const totalAssets = data.assets.reduce((sum, asset) => sum + (Number(asset.value) || 0), 0);
      const totalLiabilities = data.liabilities.reduce((sum, liability) => sum + (Number(liability.amount) || 0), 0);
      const netWorth = totalAssets - totalLiabilities;

    const summary = `
      Annual Income: £${financialData.incomes}
      Assets: £${financialData.assets}
      Liabilities: £${financialData.liabilities}
      Monthly Expenses: ${financialData.expenditures.map((e: Expenditure) => `${e.category}: £${e.amount}`).join(', ')}
      Goals: ${financialData.goals.map((g: Goal) => `${g.goal}: £${g.target_amount} in ${g.time_horizon} years`).join(', ')}`;

    const completion = await openai.chat.completions.create({
      model: "gpt-3.5-turbo",
      messages: [
        { role: "system", content: `You are a financial advisor. Here's the client's data:\n${summary}` },
        { role: "user", content: message }
      ]
    });

    return {
      statusCode: 200,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type'
      },
      body: JSON.stringify({ response: completion.choices[0].message.content })
    };

  } catch (error) {
    console.error('Error:', error);
    return {
      statusCode: 500,
      body: JSON.stringify({ error: 'Server error' })
    };
  }
};


const supabase = createClient(
  process.env.REACT_APP_SUPABASE_DATABASE_URL!,
  process.env.REACT_APP_SUPABASE_ANON_KEY!
);



export const handler: Handler = async (event: HandlerEvent) => {
  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      body: JSON.stringify({ error: 'Method not allowed' })
    };
  }

  try {
    const { userId, message, financialData, messageHistory = [] } = JSON.parse(event.body || '{}');

    if (!userId || !message || !financialData) {
      return {
        statusCode: 400,
        body: JSON.stringify({ error: 'Missing userId or message' })
      };
    }

    const createFinancialSummary = (data: FinancialData): string => {
      const monthlyIncome = data.incomes.reduce((sum, income) => sum + income.amount, 0) / 12;
      const totalMonthlyExpenses = data.expenditures.reduce((sum: number, exp: Expenditure) => sum + exp.amount, 0);
      const totalAssets = data.assets.reduce((sum, asset) => sum + (Number(asset.value) || 0), 0);
      const totalLiabilities = data.liabilities.reduce((sum, liability) => sum + (Number(liability.amount) || 0), 0);
      const netWorth = totalAssets - totalLiabilities;

      return `
    Financial Overview:
    - Annual Income: £${data.incomes.toLocaleString()}
    - Monthly Income: £${monthlyIncome.toLocaleString()}
    - Monthly Expenses: £${totalMonthlyExpenses.toLocaleString()}
    - Total Assets: £${data.assets.toLocaleString()}
    - Total Liabilities: £${data.liabilities.toLocaleString()}
    - Net Worth: £${netWorth.toLocaleString()}
    
    Monthly Expenses Breakdown:
    ${data.expenditures.map((exp: Expenditure) => `- ${exp.category}: £${exp.amount.toLocaleString()}`).join('\n')}
    
    Financial Goals:
    ${data.goals.map((goal: Goal) => `- ${goal.goal}: Target £${goal.target_amount.toLocaleString()} in ${goal.time_horizon} years`).join('\n')}
    `;
    };
    



    const financialSummary = createFinancialSummary


    console.log('Sending the following data to OpenAI API:');
    console.log('Summary:', financialSummary);
    console.log('User Message:', message);

          const completion = await openai.chat.completions.create({
          model: "gpt-3.5-turbo",
          messages: [
            {
              role: "system",
              content: `You are a financial advisor assistant. Use this data to provide specific advice:\n${financialSummary}`
            },
            { role: "user", content: message }
          ],
          temperature: 0.7,
          max_tokens: 1000
          });

          return {
          statusCode: 200,
          headers: {
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Headers': 'Content-Type',
            'Access-Control-Allow-Methods': 'POST'
          },
          body: JSON.stringify({
            response: completion.choices[0].message.content
          })
          };

          } catch (error) {
          console.error('Error:', error);
          return {
          statusCode: 500,
          body: JSON.stringify({ 
            error: 'Server error',
            details: error instanceof Error ? error.message : 'Unknown error'
          })
        };
      }
    };


    
// Format financial summary
const summary = `
Financial Overview:
Annual Income: £${financialData.income}
Monthly Income: £${financialData.income / 12}
Assets: £${financialData.assets}
Liabilities: £${financialData.liabilities}
Net Worth: £${financialData.assets - financialData.liabilities}

Monthly Expenses:
${financialData.expenditure.map((exp: Expenditure) => 
  `- ${exp.category}: £${exp.amount}`
).join('\n')}

Financial Goals:
${financialData.goals.map((goal: Goal) => 
  `- ${goal.goal}: £${goal.target_amount} in ${goal.time_horizon} years`
).join('\n')}
`;



// netlify/functions/chatbot.ts

import { Handler, HandlerEvent } from '@netlify/functions';
import OpenAI from 'openai';
import { createClient } from '@supabase/supabase-js';
import { FinancialData } from './types/financial';
import { ChatCompletionMessageParam } from 'openai/resources/chat/completions';



const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

const supabase = createClient(
  process.env.REACT_APP_SUPABASE_DATABASE_URL!,
  process.env.REACT_APP_SUPABASE_ANON_KEY!
);

interface RequestBody {
  message: string;
  userId: string;
  financialData: FinancialData;
  messageHistory?: ChatCompletionMessageParam[];
}

const createFinancialSummary = (data: FinancialData): string => {
  console.log('Incoming financial data:', JSON.stringify(data, null, 2));

  if (!data || typeof data !== 'object') {
    console.error('Invalid financial data received:', data);
    return 'Error: Invalid financial data format';
  }

  // Ensure arrays exist
  const incomes = Array.isArray(data.incomes) ? data.incomes : [];
  const expenditures = Array.isArray(data.expenditures) ? data.expenditures : [];
  const assets = Array.isArray(data.assets) ? data.assets : [];
  const liabilities = Array.isArray(data.liabilities) ? data.liabilities : [];
  const goals = Array.isArray(data.goals) ? data.goals : [];

  const arrays = {
    incomes: Array.isArray(data.incomes),
    expenditures: Array.isArray(data.expenditures),
    assets: Array.isArray(data.assets),
    liabilities: Array.isArray(data.liabilities),
    goals: Array.isArray(data.goals)
  };
  
  console.log('Array validation:', arrays);

  const processed = {
    incomes: arrays.incomes ? data.incomes : [],
    expenditures: arrays.expenditures ? data.expenditures : [],
    assets: arrays.assets ? data.assets : [],
    liabilities: arrays.liabilities ? data.liabilities : [],
    goals: arrays.goals ? data.goals : []
  };

  console.log('Processed arrays:', {
    incomesCount: processed.incomes.length,
    expendituresCount: processed.expenditures.length,
    assetsCount: processed.assets.length,
    liabilitiesCount: processed.liabilities.length,
    goalsCount: processed.goals.length
  });

   // Safely calculate totals
   const totalAnnualIncome = data.incomes.reduce((sum, inc) => 
    sum + (Number(inc.amount) || 0), 0);
  
  const monthlyIncome = totalAnnualIncome / 12;
  
  const totalMonthlyExpenses = data.expenditures.reduce((sum, exp) => 
    sum + (Number(exp.amount) || 0), 0);
  
  const totalAssets = data.assets.reduce((sum, asset) => 
    sum + (Number(asset.value) || 0), 0);
  
  const totalLiabilities = data.liabilities.reduce((sum, liability) => 
    sum + (Number(liability.amount) || 0), 0);
  
  const netWorth = totalAssets - totalLiabilities;

    // Log the calculated values
    console.log('Calculated values:', {
      totalAnnualIncome,
      monthlyIncome,
      totalMonthlyExpenses,
      totalAssets,
      totalLiabilities,
      netWorth
    });

  if (!data.incomes || !data.incomes.length) {
    console.log('No income data available');
    return 'No income data available';
  }


  return `
FINANCIAL OVERVIEW
=================

Annual Income: £${totalAnnualIncome.toLocaleString()}
Monthly Income: £${monthlyIncome.toLocaleString()}
Monthly Expenses: £${totalMonthlyExpenses.toLocaleString()}
Total Assets: £${totalAssets.toLocaleString()}
Total Liabilities: £${totalLiabilities.toLocaleString()}
Net Worth: £${netWorth.toLocaleString()}

DETAILED BREAKDOWN
=================
Income Sources:
${data.incomes.length > 0 
  ? data.incomes.map((inc) => `- ${inc.type}: £${inc.amount} (${inc.frequency})`).join('\n') 
  : 'No income data available'}

Monthly Expenses:
${data.expenditures.length > 0 
  ? data.expenditures.map((exp) => `- ${exp.category}: £${exp.amount}`).join('\n') 
  : 'No expense data available'}

Assets:
${data.assets.length > 0 
  ? data.assets.map((asset) => `- ${asset.type}: £${asset.value} - ${asset.description}`).join('\n') 
  : 'No asset data available'}

Liabilities:
${data.liabilities.length > 0 
  ? data.liabilities.map((liability) => `- ${liability.type}: £${liability.amount} at ${liability.interest_rate}% interest`).join('\n') 
  : 'No liability data available'}

Financial Goals:
${data.goals.length > 0 
  ? data.goals.map((goal) => `- ${goal.goal}: Target £${goal.target_amount} in ${goal.time_horizon} years`).join('\n') 
  : 'No goals set'}

Note: All monetary values are in GBP.
`;


};


    const createSystemPrompt = (financialSummary: string): string => {
        const systemPrompt = `You are a financial advisor assistant with access to the user's current financial data. 
      Please use this data to provide specific, actionable advice:
      
      ${financialSummary}
      
      When responding:
      1. Reference specific numbers from their financial data
      2. Make recommendations based on their actual situation
      3. Consider their income, expenses, assets, liabilities, and stated goals
      4. Provide practical, actionable advice
      5. Keep responses clear and data-driven

      Please provide specific, actionable advice based on these exact numbers and circumstances.`;

        console.log('System prompt:', systemPrompt);
        return systemPrompt;
    };


  export const handler: Handler = async (event: HandlerEvent) => {
    // Ensure the method is POST
    if (event.httpMethod !== 'POST') {
      return {
        statusCode: 405,
        body: JSON.stringify({ error: 'Method not allowed' }),
      };
    }

    console.log('Handler function started');
  
    let clientFinancialData: FinancialData;
    let message: string;
    let messageHistory: ChatCompletionMessageParam[] = [];
  
    try {
      console.log('Raw event body:', event.body);
    
      const parsedBody = JSON.parse(event.body || '{}');
      console.log('Parsed body:', JSON.stringify(parsedBody, null, 2));
      // Parse and validate request body
      const { message: parsedMessage, userId, financialData, messageHistory: parsedMessageHistory = [] } = JSON.parse(event.body || '{}') as RequestBody;
  
      if (!parsedMessage || !userId || !financialData) {
        throw new Error('Missing required fields in request body');
      }

      message = parsedMessage; // Assign parsed message
      messageHistory = parsedMessageHistory; // Assign parsed message history
      clientFinancialData = financialData;

      // Log each piece of data separately
        console.log('Financial Data Received:', {
          hasMessage: Boolean(message),
        hasUserId: Boolean(userId),
        financialDataExists: Boolean(financialData),
        financialDataStructure: financialData ? {
        hasIncomes: Array.isArray(financialData.incomes),
        incomesLength: financialData.incomes?.length,
        firstIncome: financialData.incomes?.[0],
        hasExpenditures: Array.isArray(financialData.expenditures),
        expendituresLength: financialData.expenditures?.length,
        firstExpenditure: financialData.expenditures?.[0],
          } : null
        });

      console.log('Received financial data:', JSON.stringify(clientFinancialData, null, 2));
    } catch (error) {
      console.error('Error parsing event.body:', error);
      return {
        statusCode: 400,
        body: JSON.stringify({
          error: 'Failed to parse request body',
          details: error instanceof Error ? error.message : 'Unknown error',
        }),
      };
    }
  
    // Validate the financial data structure
    const dataValidation = {
      hasIncomes: Array.isArray(clientFinancialData?.incomes) && clientFinancialData.incomes.length > 0,
      hasExpenditures: Array.isArray(clientFinancialData?.expenditures) && clientFinancialData.expenditures.length > 0,
      hasAssets: Array.isArray(clientFinancialData?.assets) && clientFinancialData.assets.length > 0,
      hasLiabilities: Array.isArray(clientFinancialData?.liabilities) && clientFinancialData.liabilities.length > 0,
      hasGoals: Array.isArray(clientFinancialData?.goals) && clientFinancialData.goals.length > 0,
    };
  
    console.log('Data validation results:', dataValidation);
  
    if (!dataValidation.hasIncomes && !dataValidation.hasExpenditures && !dataValidation.hasAssets && !dataValidation.hasLiabilities && !dataValidation.hasGoals) {
      return {
        statusCode: 400,
        body: JSON.stringify({
          error: 'No financial data provided',
          debug: dataValidation,
        }),
      };
    }

    const validateFinancialData = (data: FinancialData): boolean => {
        if (typeof data !== 'object' || data === null) {
            console.error('Invalid financial data: not an object');
            return false;
        }

        const requiredKeys = ['incomes', 'expenditures', 'assets', 'liabilities', 'goals'] as const;
        for (const key of requiredKeys) {
            if (!Array.isArray(data[key])) {
                console.error(`Invalid financial data: ${key} is not an array`);
                return false;
            }
        }

        return true;
    };
  
    // Before sending the data to OpenAI
    if (!validateFinancialData(clientFinancialData)) {
        return {
            statusCode: 400,
            body: JSON.stringify({
                error: 'Invalid financial data structure',
            }),
        };
    }
  
    try {
      // Generate financial summary and system prompt
      const financialSummary = createFinancialSummary(clientFinancialData);
      console.log('Generated financial summary:', financialSummary);
  
      // const systemPrompt = createSystemPrompt(financialSummary);
      console.log('Financial Summary being sent to OpenAI:', financialSummary);
      console.log('Message history:', messageHistory);
      console.log('User message:', message);
      // Interact with OpenAI
      
      let completion

      try {
        completion = await openai.chat.completions.create({
          model: 'gpt-3.5-turbo',
          messages: [
            { role: 'system', content: createSystemPrompt(financialSummary) },
            ...messageHistory,
            { role: 'user', content: message },
          ],
          temperature: 0.7,
          max_tokens: 150,
        });
            console.log('OpenAI API response:', JSON.stringify(completion, null, 2));

            if (completion.choices && completion.choices.length > 0) {
              const responseMessage = completion.choices[0].message.content;
              console.log('Response message:', responseMessage);
          } else {
              console.error('No choices found in the response.');
          }

        } catch (error) {
            console.error('Error calling OpenAI API:', error);
            // Handle the error appropriately, e.g., set a default response or return an error message
            return {
                statusCode: 500,
                body: JSON.stringify({
                    error: 'Failed to get a response from OpenAI',
                    details: error instanceof Error ? error.message : 'Unknown error',
                }),
            };
        }
  
      return {
        statusCode: 200,
        headers: {
          'Content-Type': 'application/json',
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Headers': 'Content-Type',
          'Access-Control-Allow-Methods': 'POST',
        },
        body: JSON.stringify({
          success: true,
          response: completion.choices[0].message.content,
          debug: { hasIncomes: clientFinancialData.incomes?.length > 0,
            incomesCount: clientFinancialData.incomes?.length,
            expendituresCount: clientFinancialData.expenditures?.length,
            assetsCount: clientFinancialData.assets?.length,
            liabilitiesCount: clientFinancialData.liabilities?.length,
            goalsCount: clientFinancialData.goals?.length },
        }),
      };
    } catch (error) {
      console.error('Handler error:', error);
      return {
        statusCode: 500,
        body: JSON.stringify({
          error: 'Server error',
          details: error instanceof Error ? error.message : 'Unknown error',
        }),
      };
    }
  };

*/
</file>

<file path="netlify/functions/generate-suitability-report.js">
const { Anthropic } = require('@anthropic-ai/sdk');
const { OpenAI } = require('openai');
const { createClient } = require('@supabase/supabase-js');
// Initialize Supabase client
const supabase = createClient(
    process.env.SUPABASE_DATABASE_URL,
    process.env.SUPABASE_SERVICE_ROLE_KEY
  );

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
});

const openai = new OpenAI({
  apiKey: process.env.OPEN_API_KEY,
})

const handler = async (event) => {
  // Add CORS headers
  const headers = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'Content-Type',
    'Access-Control-Allow-Methods': 'POST, OPTIONS',
  };

  // Handle preflight
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 204,
      headers,
    };
  }

  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      body: JSON.stringify({ error: 'Method not allowed' }),
    };
  }

  try {
    const { clientId, config } = JSON.parse(event.body || '{}');

    console.log('Received clientId:', clientId); // Log clientId
    console.log('Received config:', config); // Log config

    // Fetch client data from Supabase
    const { data: clientData, error: clientError } = await supabase
      .from('profiles')
      .select(
        `*,
        incomes(*),
        expenditures(*),
        assets(*),
        liabilities(*),
        goals(*),
        kyc_data!fk_profile(*)`
      )
      .eq('id', clientId)
      .single();

    if (clientError) {
      console.error('Supabase error:', clientError); // Debug log
      throw new Error(`Failed to fetch client data: ${clientError.message}`);
    }

    if (!clientData) {
      throw new Error('No client data found');
    }

    console.log('Client data:', clientData); // Log client data

    // Format the client data for the prompt
    const formattedData = {
      monthlyIncome: clientData.incomes.reduce(
        (sum, inc) =>
          sum + (inc.frequency === 'Monthly' ? inc.amount : inc.amount / 12),
        0
      ) || 0,
      annualIncome: clientData.incomes.reduce(
        (sum, inc) =>
          sum + (inc.frequency === 'Annual' ? inc.amount : inc.amount * 12),
        0
      ) || 0,
      totalAssets: clientData.assets.reduce((sum, asset) => sum + asset.value, 0),
      totalLiabilities: clientData.liabilities.reduce(
        (sum, liability) => sum + liability.amount,
        0
      ) || 0,
      goals: clientData.goals,
      kyc: clientData.kyc_data,
    };

    console.log('Formatted data:', formattedData); // Log formatted data

    // Generate the system prompt
    const systemPrompt = `You are a professional UK financial adviser creating a suitability report. Use the following client data:

Name: ${clientData.name}
Date: ${new Date().toLocaleDateString()}

Monthly Income: £${formattedData.monthlyIncome.toFixed(0)}
Annual Income: £${formattedData.annualIncome.toFixed(0)}
Total Assets: £${formattedData.totalAssets.toFixed(0)}
Total Liabilities: £${formattedData.totalLiabilities.toFixed(0)}

Financial Goals:
${formattedData.goals
  .map((g) => `- ${g.goal}: £${g.target_amount} in ${g.time_horizon} years`)
  .join('\n')}

KYC Information:
Date of Birth: ${formattedData.kyc[0]?.date_of_birth || 'Not provided'}
Address: ${formattedData.kyc[0]?.address_line1 || 'Not provided'}
${formattedData.kyc[0]?.address_line2 ? `${formattedData.kyc[0].address_line2}` : ''}
${formattedData.kyc[0]?.city ? `${formattedData.kyc[0].city}` : ''}
${formattedData.kyc[0]?.postal_code ? `${formattedData.kyc[0].postal_code}` : ''}

Create a detailed suitability report following FCA guidelines. Include:
1. Executive Summary
2. Client Circumstances
3. Objectives and Needs
4. Analysis and Research
5. Recommendations
6. Risks and Considerations
7. Costs and Charges
8. Next Steps

Use ## to denote section headers.

${config.customPrompt ? `\nAdditional Instructions:\n${config.customPrompt}` : ''}`;

    console.log('System prompt:', systemPrompt); // Log system prompt

    let report;

    // Call appropriate API based on provider
    if (config.provider === 'anthropic') {
      const message = await anthropic.messages.create({
        model: config.model,
        max_tokens: config.maxTokens,
        temperature: config.temperature,
        messages: [{ role: 'user', content: systemPrompt }],
      });
      report = message.content[0].text;
    } else if (config.provider === 'openai') {
      const completion = await openai.chat.completions.create({
        model: config.model,
        messages: [
          { role: 'system', content: 'You are a professional UK financial adviser.' },
          { role: 'user', content: systemPrompt }
        ],
        temperature: config.temperature,
        max_tokens: config.maxTokens,
      });
      report = completion.choices[0].message.content;
    } else {
      throw new Error(`Unsupported provider: ${config.provider}`);
    }

    return {
      statusCode: 200,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*',
      },
      body: JSON.stringify({
        report,
      }),
    };
  } catch (error) {
    console.error('Error:', error);
    return {
      statusCode: 500,
      body: JSON.stringify({
        error: error.message,
        stack: process.env.NODE_ENV === 'development' ? error.stack : undefined,
      }),
    };
  }
};

exports.handler = handler;
</file>

<file path="netlify/functions/get-models.js">
const { Anthropic } = require('@anthropic-ai/sdk');
const { OpenAI } = require('openai')

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
});

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

const ANTHROPIC_MODELS = [
  {
    id: 'claude-3-7-sonnet-20250219',
    display_name: 'Claude 3.7 Sonnet',
    provider: 'anthropic'
  },
  {
    id: 'claude-3-5-haiku-20240620',
    display_name: 'Claude 3.5 Haiku',
    provider: 'anthropic'
  },
  {
    id: 'claude-3-opus-20240229',
    display_name: 'Claude 3 Opus',
    provider: 'anthropic'
  }
];

// Define OpenAI models to include
const OPENAI_MODELS = [
  {
    id: 'gpt-4o',
    display_name: 'GPT-4o',
    provider: 'openai'
  },
  {
    id: 'gpt-4o-mini',
    display_name: 'GPT-4o-mini',
    provider: 'openai'
  },
  {
    id: 'o3-mini-2025-01-31',
    display_name: 'o3-mini',
    provider: 'openai'
  }
];

exports.handler = async (event) => {
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 204,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type',
        'Access-Control-Allow-Methods': 'POST, OPTIONS'
      }
    };
  }
  
  if (event.httpMethod !== 'POST') {
    return { statusCode: 405, body: JSON.stringify({ error: 'Method not allowed' }) };
  }
  
  
  try {
    let formattedAnthropicModels = [];
    
    try {
      // Attempt to fetch Anthropic models from API
      const anthropicModelsResponse = await anthropic.models.list({limit: 10});
      
      // Format Anthropic models to include provider
      formattedAnthropicModels = anthropicModelsResponse.data.map(model => ({
        id: model.id,
        display_name: model.name || model.id,
        provider: 'anthropic'
      }));
      
      console.log(`Successfully fetched ${formattedAnthropicModels.length} models from Anthropic API`);
    } catch (apiError) {
      console.error('Error fetching Anthropic models from API:', apiError);
      console.log('Using predefined Anthropic models instead');
      formattedAnthropicModels = ANTHROPIC_MODELS;
    }
    
    // Make sure our predefined models are included (will be merged or deduplicated)
    const predefinedModelIds = new Set(ANTHROPIC_MODELS.map(m => m.id));
    const apiModelIds = new Set(formattedAnthropicModels.map(m => m.id));
    
    // Add any predefined models that weren't in the API response
    const missingModels = ANTHROPIC_MODELS.filter(model => !apiModelIds.has(model.id));
    formattedAnthropicModels = [...formattedAnthropicModels, ...missingModels];
    
    // Combine Anthropic and OpenAI models
    const allModels = [...formattedAnthropicModels, ...OPENAI_MODELS];
    
    console.log(`Returning ${allModels.length} models: ${formattedAnthropicModels.length} from Anthropic and ${OPENAI_MODELS.length} from OpenAI`);
    

    return {
      statusCode: 200,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*'
      },
      body: JSON.stringify({
        response: allModels
      })
    };
  } catch (error) {
    console.error('Error:', error);
    return {
      statusCode: 500,
      body: JSON.stringify({ error: error.message })
    };
  }
}
</file>

<file path="netlify/functions/parse-file-note.js">
// netlify/functions/parse-file-note.js

const OpenAI = require('openai');
const { createClient } = require('@supabase/supabase-js');

// Initialize OpenAI client
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

// Initialize Supabase client
const supabase = createClient(
  process.env.REACT_APP_SUPABASE_DATABASE_URL,
  process.env.REACT_APP_SUPABASE_ANON_KEY
);

exports.handler = async (event) => {
  // Add CORS headers
  const headers = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'Content-Type',
    'Access-Control-Allow-Methods': 'POST, OPTIONS',
    'Content-Type': 'application/json'
  };

  // Handle preflight requests
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 204,
      headers
    };
  }

  if (event.httpMethod !== 'POST') {
    return { 
      statusCode: 405, 
      headers,
      body: JSON.stringify({ error: 'Method not allowed' }) 
    };
  }

  try {
    const { noteContent, clientId } = JSON.parse(event.body);

    if (!noteContent || !clientId) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: 'Missing required fields: noteContent or clientId' })
      };
    }

    // Fetch existing client data to provide context
    const [
      { data: profileData, error: profileError },
      { data: incomesData, error: incomesError },
      { data: expendituresData, error: expendituresError },
      { data: assetsData, error: assetsError },
      { data: liabilitiesData, error: liabilitiesError },
      { data: goalsData, error: goalsError }
    ] = await Promise.all([
      supabase.from('profiles').select('*').eq('id', clientId).single(),
      supabase.from('incomes').select('*').eq('client_id', clientId),
      supabase.from('expenditures').select('*').eq('client_id', clientId),
      supabase.from('assets').select('*').eq('client_id', clientId),
      supabase.from('liabilities').select('*').eq('client_id', clientId),
      supabase.from('goals').select('*').eq('client_id', clientId)
    ]);

    if (profileError && profileError.code !== 'PGRST116') {
      console.error('Error fetching profile:', profileError);
    }

    // Create a context object with existing client data
    const clientContext = {
      profile: profileData || {},
      incomes: incomesData || [],
      expenditures: expendituresData || [],
      assets: assetsData || [],
      liabilities: liabilitiesData || [],
      goals: goalsData || []
    };

    // Define the prompt for GPT-4o-mini
    const systemPrompt = `
      You are a financial adviser's assistant tasked with extracting relevant financial information from meeting notes.
      
      Extract the following information from the file note:
      1. Personal details: age, family, dependents, occupation
      2. Financial goals: short and long-term objectives, retirement plans
      3. Income: salary, bonuses, pension, rental income, etc.
      4. Expenses: major expenditures, fixed costs
      5. Assets: property, investments, savings, etc.
      6. Liabilities: mortgages, loans, credit cards, etc.
      7. Risk profile: attitude to risk, investment preferences
      
      The client's existing data is:
      ${JSON.stringify(clientContext, null, 2)}
      
      Look for any new information or updates to this existing data. Format your response as structured JSON and provide a concise summary paragraph about the client based on all available information (existing + new).
      
      JSON format should include:
      {
        "extractedData": {
          "personalDetails": { ... },
          "financialGoals": { ... },
          "income": { ... },
          "expenses": { ... },
          "assets": { ... },
          "liabilities": { ... },
          "riskProfile": { ... }
        },
        "summary": "Concise paragraph summarizing key client information"
      }
    `;

    // Call OpenAI API
    const completion = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: noteContent }
      ],
      temperature: 0.2,
      max_tokens: 1000,
      response_format: { type: "json_object" }
    });

    // Parse the response
    const responseContent = completion.choices[0].message.content;
    const parsedResponse = JSON.parse(responseContent);

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify({
        extractedData: parsedResponse.extractedData,
        summary: parsedResponse.summary
      })
    };
  } catch (error) {
    console.error('Error:', error);
    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({ error: error.message })
    };
  }
};
</file>

<file path="netlify/functions/test.ts">
import { Handler } from '@netlify/functions';

export const handler: Handler = async () => {
  return {
    statusCode: 200,
    body: JSON.stringify({
      message: 'Test function is working'
    })
  };
};
</file>

<file path="netlify/functions/tsconfig.functions.json">
// netlify/functions/tsconfig.functions.json

{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "rootDir": "./",
    "outDir": "../../dist/functions"
  },
  "include": ["**/*"]
}
</file>

<file path="public/_redirects">
/*    /index.html   200
</file>

<file path="public/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>
</file>

<file path="public/manifest.json">
{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}
</file>

<file path="public/robots.txt">
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:
</file>

<file path="src/@types/auth.ts">
// src/types/auth.ts

export interface SignUpResponse {
    user: {
      id: string;
      email: string;
      user_metadata: {
        role: string;
      };
    } | null;
    session: any;
  }
  
  export interface Profile {
    id: string;
    email: string;
    role: string;
    created_at: string;
  }
</file>

<file path="src/@types/documents.ts">
// src/@types/documents.ts

export type DocumentType = 'bank_statement' | 'investment_statement' | 'utility_bill' | 'identity_document' | 'tax_return' | 'payslip' | 'pension_statement' | 'insurance_policy' | 'mortgage_statement' | 'credit_report' | 'other' | 'unknown';

export interface ExtractedDocumentData {
  // Common extracted data
  postcodes?: string[];
  addresses?: string[];
  phoneNumbers?: string[];
  emails?: string[];
  nationalInsurance?: string[];
  monetaryValues?: string[];
  dates?: string[];
  rawText?: string;
  
  // Document-specific data
  accountNumber?: string;
  sortCode?: string;
  portfolioValue?: number;
  transactions?: Transaction[];
  
  // Any other extracted data
  [key: string]: any;
}

export interface Transaction {
  date: string;
  description: string;
  amount: number;
  type: 'credit' | 'debit';
  category?: string;
}

export interface ClientDocument {
  id: string;
  client_id: string;
  file_name: string;
  file_type: string;
  file_path: string;
  file_url?: string;
  file_size?: number;
  upload_date: string;
  processed: boolean;
  processed_date?: string;
  document_type?: DocumentType;
  extracted_data?: ExtractedDocumentData;
  uploaded_by?: string; // Can be client_id or adviser_id
  signedUrl?: string;
}

export interface DocumentListProps {
  clientId?: string; // Optional: if used in adviser view
  showExtractedData?: boolean;
  onSelectDocument?: (document: ClientDocument) => void;
  adviserMode?: boolean;
  limit?: number;
  className?: string;
}

export interface DocumentUploadProps {
  onUploadSuccess?: (fileUrl: string, fileType: string, fileName: string) => void;
  allowedFileTypes?: string[];
  maxFileSizeMB?: number;
  bucketName?: string;
  clientId?: string; // Optional: for adviser uploading on behalf of client
  adviserMode?: boolean;
}
</file>

<file path="src/@types/fileNote.ts">
// src/@types/fileNote.ts

export interface FileNote {
    id: string;
    client_id: string;
    adviser_id: string;
    content: string;
    created_at: string;
    updated_at?: string;
    extracted_data?: ExtractedData;
    summary?: string;
    tags?: string[];
  }
  
  export interface ClientSummary {
    id: string;
    client_id: string;
    summary: string;
    updated_at: string;
    created_by?: string;
  }
  
  export interface ExtractedData {
    personalDetails?: {
      age?: number;
      occupation?: string;
      familyStatus?: string;
      dependents?: Dependent[];
      [key: string]: any;
    };
    financialGoals?: {
      shortTerm?: Goal[];
      longTerm?: Goal[];
      retirement?: RetirementGoal;
      [key: string]: any;
    };
    income?: {
      salary?: number;
      bonus?: number;
      rental?: number;
      pension?: number;
      other?: OtherIncome[];
      [key: string]: any;
    };
    expenses?: {
      housing?: number;
      utilities?: number;
      transportation?: number;
      entertainment?: number;
      other?: OtherExpense[];
      [key: string]: any;
    };
    assets?: {
      property?: Property[];
      investments?: Investment[];
      savings?: Saving[];
      other?: OtherAsset[];
      [key: string]: any;
    };
    liabilities?: {
      mortgages?: Mortgage[];
      loans?: Loan[];
      creditCards?: CreditCard[];
      other?: OtherLiability[];
      [key: string]: any;
    };
    riskProfile?: {
      attitude?: string;
      capacity?: string;
      tolerance?: string;
      preferredInvestments?: string[];
      [key: string]: any;
    };
    [key: string]: any;
  }
  
  // Sub-types for extracted data
  export interface Dependent {
    name?: string;
    age?: number;
    relationship?: string;
  }
  
  export interface Goal {
    description: string;
    targetAmount?: number;
    timeHorizon?: number;
  }
  
  export interface RetirementGoal {
    targetAge?: number;
    targetIncome?: number;
    currentProvision?: number;
  }
  
  export interface OtherIncome {
    source: string;
    amount: number;
    frequency: string;
  }
  
  export interface OtherExpense {
    category: string;
    amount: number;
    frequency: string;
  }
  
  export interface Property {
    type: string;
    value: number;
    description?: string;
  }
  
  export interface Investment {
    type: string;
    value: number;
    provider?: string;
    riskLevel?: string;
  }
  
  export interface Saving {
    type: string;
    value: number;
    institution?: string;
    interestRate?: number;
  }
  
  export interface OtherAsset {
    type: string;
    value: number;
    description?: string;
  }
  
  export interface Mortgage {
    property: string;
    outstandingAmount: number;
    interestRate: number;
    term?: number;
    monthlyPayment?: number;
  }
  
  export interface Loan {
    type: string;
    outstandingAmount: number;
    interestRate: number;
    term?: number;
    monthlyPayment?: number;
  }
  
  export interface CreditCard {
    provider: string;
    outstandingBalance: number;
    creditLimit?: number;
    interestRate: number;
  }
  
  export interface OtherLiability {
    type: string;
    outstandingAmount: number;
    description?: string;
  }
</file>

<file path="src/@types/financial.js">
"use strict";
// src/types/financial.ts
Object.defineProperty(exports, "__esModule", { value: true });
</file>

<file path="src/@types/financial.ts">
// src/types/financial.ts

export interface RiskAssessmentEntry extends BaseEntry {
  responses: Record<string, number>;
  calculated_scores?: {
    knowledgeScore: number | null;
    attitudeScore: number | null;
    capacityScore: number | null;
    timeframeScore: number | null;
    overallScore: number | null;
    riskCategory: string;
    
  };
}

export interface FormFields {
    // Goals fields
    retirement_age: string | number;
    planned_expenditures: string;
    retirement_type: string;
    time_horizon: string | number;
    
    // Assets fields
    type: string;
    description: string;
    value: number;
    
    // Liabilities fields
    amount: number;
    interest_rate: number;
    
    // Expenditure fields
    category: string;
    frequency: string;
  }
  
  export type FormFieldName = keyof FormFields;
  
  export interface FormField {
    name: FormFieldName | string;
    type: 'text' | 'number' | 'select';
    label: string;
    options?: { value: string; label: string }[];
  }
  
  // Update other interfaces to use these field names
  export interface BaseEntry {
    id: string;
    client_id: string;
  }
  
  export interface GoalEntry extends BaseEntry {
    retirement_age: number;
    planned_expenditures: string;
    retirement_type: string;
    time_horizon: number;
  }
  
  export interface AssetEntry extends BaseEntry {
    type: string;
    description: string;
    value: number;
  }
  
  export interface LiabilityEntry extends BaseEntry {
    type: string;
    description: string;
    amount: number;
    interest_rate: number;
    term?: number;
  }
  
  export interface ExpenditureEntry extends BaseEntry {
    category: string;
    amount: number;
    frequency: string;
  }

  export interface RiskAssessmentEntry extends BaseEntry {
    knowledge_score?: number;
    attitude_score?: number;
    capacity_score?: number;
    timeframe_score?: number;
    overall_score?: number;
    risk_category?: string;
    responses: Record<string, number>;
  }
  
  export type FormEntry = GoalEntry | AssetEntry | LiabilityEntry | ExpenditureEntry | RiskAssessmentEntry;
  
  export interface Income {
    client_id: string;
    type: string; // e.g., 'Salary', 'Rental Income'
    amount: number;
    frequency: string; // e.g., 'Monthly', 'Yearly'
  }
  
  export interface Expenditure {
    client_id: string;
    category: string; // e.g., 'Rent/Mortgage', 'Utilities'
    amount: number;
    frequency: string; // e.g., 'Monthly', 'Yearly'
  }
  
  export interface Asset {
    client_id: string;
    type: string; // e.g., 'Property', 'Stocks', 'Savings'
    description: string; // Additional details about the asset
    value: number; // Current value of the asset
  }
  
  export interface Liability {
    client_id: string;
    type: string; // e.g., 'Mortgage', 'Credit Card', 'Student Loan'
    amount: number; // Outstanding balance
    interest_rate?: number; // Interest rate (if applicable)
    description: string;
    term?: number;
  }
  
  export interface Goal {
    client_id: string;
    id: string;
    goal: string; // e.g., 'Retire', 'Pay off mortgage'
    target_amount: number;
    time_horizon: number; // Years to achieve the goal
  }
  
  export interface FinancialData {
    incomes: Income[]; // Detailed incomes
    expenditures: Expenditure[]; // Detailed expenditures
    assets: Asset[]; // Detailed assets
    liabilities: Liability[]; // Detailed liabilities
    goals: Goal[]; // Financial goals
  }
  
  
  export interface FinancialFormProps {
    formType: 'expenditures' | 'assets' | 'goals' | 'liabilities' | 'risk_assessments';
    nextRoute: string;
    stepNumber: number;
    fields: FormField[];
    defaultEntry: Record<string, any>;
  }

  export interface KYCData {
    date_of_birth: string;
    address_line1: string;
    address_line2: string;
    city: string;
    postal_code: string;
    phone_number: string;
  }

  export interface Profile {
    id: string;
    name: string;
    email: string;
    kyc?: KYCData;
  }

  export interface FinancialSummary {
    monthlyIncome: number;
    annualIncome: number;
    monthlyExpenditure: number;
    annualExpenditure: number;
    totalAssets: number;
    totalLiabilities: number;
    netWorth: number;
    annualDebtService: number;
    totalIncome: number;
  }

  export interface ClientData {
    profile: Profile | null;
    incomes: Income[];
    expenditures: Expenditure[];
    assets: Asset[];
    liabilities: Liability[];
    goals: Goal[];
    risk_assessments: RiskAssessmentEntry[];
  }
  
  export * from '../../netlify/functions/types/financial';
</file>

<file path="src/@types/forms.ts">
// src/types/forms.ts
export interface BaseFormProps {
    onComplete: () => void;
  }
</file>

<file path="src/@types/json2csv.d.ts">
declare module 'json2csv' {
    export class Parser<T = any> {
      constructor(opts?: any);
      parse(data: T[]): string;
    }
  }
</file>

<file path="src/@types/transactions.ts">
export interface Transaction {
    date: string;
    description: string;
    amount: number;
    type: 'credit' | 'debit';
  }
</file>

<file path="src/api/chatbot.ts">
// src/api/chatbot.ts
import { NextApiRequest, NextApiResponse } from 'next';
import generateBotResponse from '../components/Chat/Bot';
import { supabase } from '../services/supabaseClient';

const rateLimitMap = new Map();

interface ChatbotRequestBody {
    userId: string;
    query: string;
  }

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { userId, query } = req.body;

  if (!userId || !query) {
    return res.status(400).json({ error: 'Missing userId or query in the request body.' });
  }

  // Rate-limiting logic
  const now = Date.now();
  if (rateLimitMap.has(userId)) {
    const { lastRequest, requestCount } = rateLimitMap.get(userId);

    if (now - lastRequest < 60000) { // 1-minute window
      if (requestCount >= 5) { // Limit to 5 requests per minute
        return res.status(429).json({ error: 'Rate limit exceeded. Try again in a minute.' });
      }
      rateLimitMap.set(userId, { lastRequest: now, requestCount: requestCount + 1 });
    } else {
      rateLimitMap.set(userId, { lastRequest: now, requestCount: 1 });
    }
  } else {
    rateLimitMap.set(userId, { lastRequest: now, requestCount: 1 });
  }

  try {
    // Fetch user profile to determine agent type and preferences
    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('agent_type')
      .eq('id', userId)
      .single();

    if (profileError) {
      console.error('Error fetching user profile:', profileError);
      return res.status(500).json({ error: 'Failed to fetch user profile.' });
    }

    // Customize agent type for OpenAI prompt
    const agentType = profile?.agent_type || 'default';

    // Generate bot response
    const response = await generateBotResponse(userId, query, agentType);
    res.status(200).json({ response });
  } catch (error) {
    console.error('Error processing chatbot request:', error);
    res.status(500).json({ error: 'Failed to process the request.' });
  }
}
</file>

<file path="src/components/Adviser/Documents/AdviserDocumentsPage.tsx">
// src/components/Adviser/AdviserDocumentsPage.tsx
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { supabase } from '../../../services/supabaseClient';
import DocumentUpload from 'components/Common/Documents/DocumentUpload';
import DocumentList from 'components/Common/Documents/DocumentList';
import DocumentDetails from 'components/Common/Documents/DocumentDetails';
import { ClientDocument } from '../../../@types/documents';

const AdviserDocumentsPage: React.FC = () => {
  const { clientId } = useParams<{ clientId: string }>();
  const navigate = useNavigate();
  const [showUpload, setShowUpload] = useState(false);
  const [refreshKey, setRefreshKey] = useState(0);
  const [selectedDocument, setSelectedDocument] = useState<ClientDocument | null>(null);
  const [clientDetails, setClientDetails] = useState<{ name: string; email: string } | null>(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    const fetchClientDetails = async () => {
      if (!clientId) return;
      
      try {
        const { data, error } = await supabase
          .from('profiles')
          .select('name, email')
          .eq('id', clientId)
          .single();
        
        if (error) throw error;
        setClientDetails(data);
      } catch (error) {
        console.error('Error fetching client details:', error);
      } finally {
        setLoading(false);
      }
    };
    
    fetchClientDetails();
  }, [clientId]);
  
  const handleUploadSuccess = () => {
    setShowUpload(false);
    setRefreshKey(prev => prev + 1);
  };
  
  const handleDocumentSelect = (document: ClientDocument) => {
    setSelectedDocument(document);
  };

  const handleApplyData = (id: string) => {
    // Insert logic to apply data to the client profile
    alert('Data applied to client profile');
  };

  if (loading) {
    return (
      <div className="flex justify-center items-center h-64">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500"></div>
      </div>
    );
  }
  
  if (!clientId || !clientDetails) {
    return (
      <div className="p-6 bg-red-50 border border-red-200 rounded-lg max-w-3xl mx-auto my-8">
        <h3 className="text-red-800 font-medium">Error</h3>
        <p className="text-red-600">Client not found or you don't have permission to view this client's documents.</p>
        <button 
          onClick={() => navigate('/adviser/adviser-dashboard')}
          className="mt-4 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
        >
          Return to Dashboard
        </button>
      </div>
    );
  }
  
  return (
    <div className="container mx-auto px-4 py-8">
      <div className="mb-8">
        <button 
          onClick={() => navigate(`/adviser/client/${clientId}`)}
          className="text-gray-600 hover:text-gray-900 mb-4 flex items-center gap-2"
        >
          ← Back to Client Details
        </button>
        
        <div className="flex flex-wrap justify-between items-center">
          <div>
            <h1 className="text-2xl font-bold mb-2">Documents for {clientDetails.name}</h1>
            <p className="text-gray-600">{clientDetails.email}</p>
          </div>
          
          <button
            onClick={() => setShowUpload(!showUpload)}
            className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
          >
            {showUpload ? 'Cancel Upload' : 'Upload Document for Client'}
          </button>
        </div>
      </div>
      
      {showUpload && (
        <div className="mb-8">
          <div className="p-4 bg-blue-50 border border-blue-200 rounded-lg mb-4">
            <p className="text-blue-800">
              <strong>Note:</strong> You are uploading a document on behalf of {clientDetails.name}.
              This document will appear in the client's documents list.
            </p>
          </div>
          <DocumentUpload 
            onUploadSuccess={handleUploadSuccess} 
            clientId={clientId}
            adviserMode={true}
          />
        </div>
      )}
      
      <div className="grid gap-6">
        <DocumentList 
          key={refreshKey}
          clientId={clientId}
          onSelectDocument={handleDocumentSelect}
          adviserMode={true}
        />
      </div>
      
      {selectedDocument && selectedDocument.processed && selectedDocument.extracted_data && (
        <DocumentDetails document={selectedDocument} onApplyData={handleApplyData} />
      )}
    </div>
  );
};

export default AdviserDocumentsPage;
</file>

<file path="src/components/Adviser/ClientDetails.tsx">
import React, { useEffect, useState, useCallback } from 'react';
import { supabase } from '../../services/supabaseClient';
import { useParams, useNavigate } from 'react-router-dom';
import { Pie, Bar } from 'react-chartjs-2';
import { financialCalculations } from '../../utils/financialcalculationMetrics';
import type { Income, Expenditure, Asset, Liability, Goal, Profile, ClientData, RiskAssessmentEntry } from '../../@types/financial';
import RiskProfileResults from '../Client/Risk/RiskProfileResults';
import { RiskScores } from 'utils/riskAssessment';
import FileNoteComponent from './FileNote';
import { ExtractedData } from '../../@types/fileNote';
import { updateClientDetails } from '../../utils/fileNoteUtils';
import toast from 'react-hot-toast'; // Install with: npm install react-hot-toast
import ClientSummary from './ClientSummary';
import ClientDocumentsList from 'components/Common/Documents/ClientDocumentList';
import DocumentUpload from '../Common/Documents/DocumentUpload';
import DocumentList from 'components/Common/Documents/DocumentList';



const ClientDetails = () => {
  const { clientId } = useParams<{ clientId: string }>();
  const navigate = useNavigate();
  const [data, setData] = useState<ClientData>({
    profile: null,
    incomes: [] as Income[],
    expenditures: [] as Expenditure[],
    assets: [] as Asset[],
    liabilities: [] as Liability[],
    goals: [] as Goal[], 
    risk_assessments: [] as RiskAssessmentEntry[]
  });
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [riskProfileData, setRiskProfileData] = useState<RiskScores | null>(null);
  const [isUpdatingFromFileNote, setIsUpdatingFromFileNote] = useState(false);
  const [clientSummary, setClientSummary] = useState<string | null>(null);
  const [showUpload, setShowUpload] = useState(false);
  const [refreshDocuments, setRefreshDocuments] = useState(0);
  const [selectedDocument, setSelectedDocument] = useState<any | null>(null);
  

  const handleExtractedData = async (extractedData: ExtractedData) => {
    if (!clientId || !extractedData) return;
    
    setIsUpdatingFromFileNote(true);
    
    try {
      const result = await updateClientDetails(clientId, extractedData);
      
      if (result.success) {
        toast.success('Client information updated from file note');
        // Refetch client data to reflect the changes
        fetchData();
      } else {
        toast.error(`Failed to update client data: ${result.message}`);
      }
    } catch (error) {
      console.error('Error updating client data:', error);
      toast.error('An error occurred while updating client data');
    } finally {
      setIsUpdatingFromFileNote(false);
    }
  };

  const fetchData = useCallback(async () => {
    if (!clientId) {
      setError('No client ID provided');
      setIsLoading(false);
      return;
    }

    try {
      const [
        { data: profile },
        { data: incomes },
        { data: expenditures },
        { data: assets },
        { data: liabilities },
        { data: goals },
        { data: kycData }, 
        { data: risk_assessments}
      ] = await Promise.all([
        supabase.from('profiles').select('*').eq('id', clientId).single(),
        supabase.from('incomes').select('*').eq('client_id', clientId),
        supabase.from('expenditures').select('*').eq('client_id', clientId),
        supabase.from('assets').select('*').eq('client_id', clientId),
        supabase.from('liabilities').select('*').eq('client_id', clientId),
        supabase.from('goals').select('*').eq('client_id', clientId),
        supabase.from('kyc_data').select('*').eq('profile_id', clientId).single(), 
        supabase.from('risk_assessments').select('*').eq('client_id', clientId)
      ]);

      setData({
        profile: profile ? { ...profile, kyc: kycData } as Profile : null,
        incomes: incomes as Income[] || [],
        expenditures: expenditures as Expenditure[] || [],
        assets: assets as Asset[] || [],
        liabilities: liabilities as Liability[] || [],
        goals: goals as Goal[] || [],
        risk_assessments: risk_assessments || []
      });
    } catch (error) {
      if (error instanceof Error) {
        setError(error.message);
        toast.error(error.message);
      } else {
        setError('An unknown error occurred');
        toast.error('Failed to load client data')
      }
    } finally {
      setIsLoading(false);
    }
  }, [clientId]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);


  useEffect(() => {
    const fetchRiskProfile = async () => {
      if (!clientId) return;
  
      try {

        
        const { data, error } = await supabase
          .from('risk_assessments')
          .select('*')
          .eq('client_id', clientId)
          .order('created_at', { ascending: false })
          .limit(1)
          .single();
    
        console.log('RiskProfileResults received data:', data);

        if (error) throw error;
        if (data?.calculated_scores) {
          // Convert the stored calculated_scores into the RiskScores format
            const riskScores = {
              knowledgeScore: data.calculated_scores.knowledgeScore,
              attitudeScore: data.calculated_scores.attitudeScore,
              capacityScore: data.calculated_scores.capacityScore,
              timeframeScore: data.calculated_scores.timeframeScore,
              overallScore: data.calculated_scores.overallScore,
              riskCategory: data.calculated_scores.riskCategory,
              capacityForLoss: data.calculated_scores.capacityForLoss
            };

          console.log('Formatted risk scores:', riskScores);
          setRiskProfileData(riskScores);
        }
      } catch (error) {
        console.error('Error fetching risk profile:', error);
      }
    };

    fetchRiskProfile(); // Call the function

}, [clientId]);
  
  
  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500"></div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="p-6 bg-red-50 border border-red-200 rounded-lg">
        <h3 className="text-red-800 font-medium">Error</h3>
        <p className="text-red-600">{error}</p>
      </div>
    );
  }

  const financialSummary = financialCalculations.calculateFinancialSummary({
    incomes: data.incomes,
    expenditures: data.expenditures,
    assets: data.assets,
    liabilities: data.liabilities,
    goals: data.goals
  });

  // Ensure we have values for debt service calculations
  if (financialSummary.annualDebtService === undefined) {
    financialSummary.annualDebtService = 0;
  }
  if (financialSummary.totalIncome === undefined) {
    financialSummary.totalIncome = financialSummary.annualIncome;
  }

  const incomeChartData = {
    labels: data.incomes.map(inc => inc.type),
    datasets: [{
      data: data.incomes.map(inc => inc.amount),
      backgroundColor: [
        '#4BC0C0', '#36A2EB', '#FFCE56', '#FF6384', '#9966FF'
      ]
    }]
  };

  const expenditureChartData = {
    labels: data.expenditures.map(exp => exp.category),
    datasets: [{
      data: data.expenditures.map(exp => exp.amount),
      backgroundColor: [
        '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF'
      ]
    }]
  };

  const assetChartData = {
    labels: data.assets.map(asset => asset.type),
    datasets: [{
      data: data.assets.map(asset => asset.value),
      backgroundColor: [
        '#4BC0C0', '#36A2EB', '#FFCE56', '#FF6384', '#9966FF'
      ]
    }]
  };
  
  const liabilityChartData = {
    labels: data.liabilities.map(liability => liability.type),
    datasets: [{
      data: data.liabilities.map(liability => liability.amount),
      backgroundColor: [
        '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF'
      ]
    }]
  };
  

  const assetsLiabilitiesData = {
    labels: ['Assets', 'Liabilities'],
    datasets: [{
      data: [financialSummary.totalAssets, financialSummary.totalLiabilities],
      backgroundColor: ['#4BC0C0', '#FF6384']
    }]
  };

  const handleUploadSuccess = () => {
    setShowUpload(false);
    // Trigger documents list refresh
    setRefreshDocuments(prev => prev + 1);
  };

  const navigateToDocuments = () => {
    navigate(`/adviser/client/${clientId}/documents`);
  };

  const handleDocumentSelect = (document: any) => {
    setSelectedDocument(document);
  };


  const RiskProfileSection: React.FC<{ riskProfileData: RiskScores | null }> = ({ riskProfileData }) => {
    if (!riskProfileData) {
      return (
        <section className="bg-white p-6 rounded-lg shadow mb-6">
          <div className="text-center py-8">
            <p className="text-gray-500">Client has not completed risk assessment</p>
          </div>
        </section>
      );
    }

    
  
    return (
      <section className="bg-white p-6 rounded-lg shadow mb-6">
        <div className="flex justify-between items-center mb-6">
          <h2 className="text-xl font-semibold">Risk Profile Analysis</h2>
          <span className={`px-3 py-1 rounded-full text-sm font-medium ${
            riskProfileData.riskCategory.includes('Conservative') ? 'bg-blue-100 text-blue-800' :
            riskProfileData.riskCategory.includes('Moderate') ? 'bg-green-100 text-green-800' :
            'bg-yellow-100 text-yellow-800'
          }`}>
            {riskProfileData.riskCategory}
          </span>
        </div>
  
        <div className="grid md:grid-cols-2 gap-4 mb-6">
          <div className="bg-gray-50 p-4 rounded-lg">
            <div className="text-sm text-gray-500">Overall Risk Score</div>
            <div className="text-2xl font-semibold">{riskProfileData.overallScore.toFixed(1)}/4</div>
            <div className="w-full h-2 bg-gray-200 rounded-full mt-2">
              <div 
                className="h-2 bg-blue-500 rounded-full"
                style={{ width: `${(riskProfileData.overallScore / 4) * 100}%` }}
              />
            </div>
          </div>
  
          <div className="bg-gray-50 p-4 rounded-lg">
            <div className="text-sm text-gray-500">Capacity for Loss</div>
            <div className="text-2xl font-semibold">{riskProfileData.capacityForLoss.category}</div>
            <div className="text-sm text-gray-500 mt-2">
              Score: {riskProfileData.capacityForLoss.score.toFixed(1)}/4
            </div>
          </div>
        </div>
  
        <div className="space-y-6">
          <div>
            <h3 className="text-lg font-medium mb-4">Risk Components</h3>
            <div className="space-y-4">
              {[
                { label: 'Knowledge', score: riskProfileData.knowledgeScore },
                { label: 'Attitude', score: riskProfileData.attitudeScore },
                { label: 'Capacity', score: riskProfileData.capacityScore },
                { label: 'Time Horizon', score: riskProfileData.timeframeScore }
              ].map((item) => (
                <div key={item.label}>
                  <div className="flex justify-between mb-1">
                    <span className="text-sm font-medium">{item.label}</span>
                    <span className="text-sm">{item.score.toFixed(1)}/4</span>
                  </div>
                  <div className="w-full h-2 bg-gray-200 rounded-full">
                    <div 
                      className="h-2 bg-blue-500 rounded-full"
                      style={{ width: `${(item.score / 4) * 100}%` }}
                    />
                  </div>
                </div>
              ))}
            </div>
          </div>
  
          <div>
            <h3 className="text-lg font-medium mb-4">Capacity for Loss Analysis</h3>
            <div className="space-y-4">
              {riskProfileData.capacityForLoss.factors.map((factor, index) => (
                <div key={index} className="bg-gray-50 p-4 rounded-lg">
                  <div className="flex justify-between mb-1">
                    <span className="font-medium">{factor.factor}</span>
                    <span>{factor.score}/4</span>
                  </div>
                  <div className="text-sm text-gray-600 mt-1">{factor.explanation}</div>
                </div>
              ))}
            </div>
          </div>
        </div>
      </section>
    );
  };

  return (
    <div className="container mx-auto px-4 py-8">
      {/* Client Profile Section */}
      <div className="bg-white rounded-lg shadow-lg p-6 mb-8">
      <div className="flex justify-between items-center">
          <h2 className="text-2xl font-bold mb-4">{data.profile?.name}</h2>
          <div className="flex flex-wrap gap-3">
            <button
              onClick={() => navigate(`/adviser/client/${clientId}/insights`)}
              className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
            >
              Generate Insights
            </button>
            <button
              onClick={() => navigate(`/adviser/client/${clientId}/reports`)}
              className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
            >
              View Reports
            </button>
                     
              <button
                onClick={() => navigate(`/adviser/client/${clientId}/suitability-report`)}
                className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
              >
                Generate Suitability Report
              </button>
            </div>
          </div>
        
        <div className="grid md:grid-cols-2 gap-4">
          <div>
            <p><span className="font-medium">Email:</span> {data.profile?.email}</p>
            <p><span className="font-medium">Date of Birth:</span> {data.profile?.kyc?.date_of_birth}</p>
            <p><span className="font-medium">Phone:</span> {data.profile?.kyc?.phone_number}</p>
          </div>
          <div>
            <p><span className="font-medium">Address:</span></p>
            <p>{data.profile?.kyc?.address_line1}</p>
            <p>{data.profile?.kyc?.address_line2}</p>
            <p>{data.profile?.kyc?.city}, {data.profile?.kyc?.postal_code}</p>
          </div>
        </div>
      </div>

      <ClientSummary data={data} />

      {/* Financial Summary */}
      <div className="grid md:grid-cols-3 gap-6 mb-8">
        <div className="bg-white rounded-lg shadow-lg p-6">
          <h3 className="text-lg font-semibold mb-4">Monthly Cash Flow</h3>
          <div className="space-y-4">
            <div>
              <div className="flex justify-between items-baseline">
                <p className="text-gray-600">Monthly Income</p>
                <p className="text-2xl font-bold text-green-600">
                  {financialCalculations.formatCurrency(financialSummary.monthlyIncome)}
                </p>
              </div>
              <div className="w-full h-1.5 bg-gray-100 rounded-full mt-1">
                <div className="h-full bg-green-500 rounded-full" style={{ width: '100%' }}></div>
              </div>
            </div>
            
            <div>
              <div className="flex justify-between items-baseline">
                <p className="text-gray-600">Monthly Expenditure</p>
                <p className="text-2xl font-bold text-red-600">
                  {financialCalculations.formatCurrency(financialSummary.monthlyExpenditure)}
                </p>
              </div>
              <div className="w-full h-1.5 bg-gray-100 rounded-full mt-1">
                <div className="h-full bg-red-500 rounded-full" style={{ 
                  width: `${Math.min(100, (financialSummary.monthlyExpenditure / financialSummary.monthlyIncome) * 100)}%` 
                }}></div>
              </div>
            </div>
            
            <div className="pt-4 border-t">
              <div className="flex justify-between items-baseline">
                <p className="text-gray-700 font-medium">Monthly Surplus</p>
                <p className={`text-xl font-bold ${
                  financialSummary.monthlyIncome - financialSummary.monthlyExpenditure > 0 ? 
                  'text-green-600' : 'text-red-600'
                }`}>
                  {financialCalculations.formatCurrency(financialSummary.monthlyIncome - financialSummary.monthlyExpenditure)}
                </p>
              </div>
            </div>
          </div>
        </div>

        <div className="bg-white rounded-lg shadow-lg p-6">
          <h3 className="text-lg font-semibold mb-4">Net Worth</h3>
          <p className="text-3xl font-bold text-blue-600 mb-2">
            {financialCalculations.formatCurrency(financialSummary.netWorth)}
          </p>
          <div className="space-y-3 mt-4">
            <div>
              <div className="flex justify-between items-center">
                <span className="text-gray-600">Assets</span>
                <span className="font-medium text-green-600">{financialCalculations.formatCurrency(financialSummary.totalAssets)}</span>
              </div>
              <div className="w-full h-2 bg-gray-100 rounded-full mt-1">
                <div className="h-full bg-green-500 rounded-full" style={{ width: '100%' }}></div>
              </div>
            </div>
            
            <div>
              <div className="flex justify-between items-center">
                <span className="text-gray-600">Liabilities</span>
                <span className="font-medium text-red-600">{financialCalculations.formatCurrency(financialSummary.totalLiabilities)}</span>
              </div>
              <div className="w-full h-2 bg-gray-100 rounded-full mt-1">
                <div className="h-full bg-red-500 rounded-full" style={{ 
                  width: `${Math.min(100, (financialSummary.totalLiabilities / financialSummary.totalAssets) * 100)}%` 
                }}></div>
              </div>
            </div>
          </div>
        </div>

        <div className="bg-white rounded-lg shadow-lg p-6">
          <h3 className="text-lg font-semibold mb-4">Financial Goals</h3>
          <div className="space-y-4">
            {data.goals.length > 0 ? (
              data.goals.map((goal, index) => (
                <div key={index}>
                  <div className="flex justify-between text-sm mb-1">
                    <span className="font-medium">{goal.goal}</span>
                    <span>{financialCalculations.formatCurrency(goal.target_amount)}</span>
                  </div>
                  <div className="flex justify-between text-xs text-gray-500 mb-1">
                    <span>Target in {goal.time_horizon} years</span>
                  </div>
                  <div className="w-full h-2 bg-gray-200 rounded-full">
                    {/* Here we're using 30% as a placeholder - in a real app you'd calculate actual progress */}
                    <div className="h-2 bg-blue-500 rounded-full" style={{ width: '30%' }}></div>
                  </div>
                </div>
              ))
            ) : (
              <div className="text-center text-gray-500 py-8">
                No financial goals set
              </div>
            )}
          </div>
        </div>
      </div>      {/* Existing Monthly Summary card */}
      <div className="bg-white rounded-lg shadow-lg p-6">
        <h3 className="text-lg font-semibold mb-4">Asset Breakdown</h3>
        {/* Group assets by type */}
        <div className="space-y-4 mb-4">
          {Object.entries(
            data.assets.reduce((acc, asset) => {
              acc[asset.type] = (acc[asset.type] || 0) + asset.value;
              return acc;
            }, {} as Record<string, number>)
          ).map(([type, total]) => (
            <div key={type}>
              <div className="flex justify-between items-center mb-1">
                <span className="text-gray-700 font-medium">{type}</span>
                <span className="font-medium">
                  {financialCalculations.formatCurrency(total)}
                </span>
              </div>
              <div className="w-full h-2.5 bg-gray-200 rounded-full overflow-hidden">
                <div 
                  className="h-full bg-blue-500 rounded-full"
                  style={{ 
                    width: `${(total / financialSummary.totalAssets) * 100}%` 
                  }}
                />
              </div>
              <div className="text-xs text-right mt-1 text-gray-500">
                {((total / financialSummary.totalAssets) * 100).toFixed(1)}% of portfolio
              </div>
            </div>
          ))}
        </div>
        <div className="mt-4 pt-4 border-t">
          <div className="flex justify-between items-center">
            <span className="font-medium text-gray-700">Total Assets</span>
            <span className="font-medium text-lg">
              {financialCalculations.formatCurrency(financialSummary.totalAssets)}
            </span>
          </div>
        </div>
      </div>

      <div className="bg-white rounded-lg shadow-lg p-6">
      <h3 className="text-lg font-semibold mb-4">Liability Breakdown</h3>
      {/* Detailed list of liabilities */}
      <div className="max-h-64 overflow-y-auto mb-4">
        {data.liabilities.length > 0 ? (
          data.liabilities.map((liability, index) => (
            <div
              key={index}
              className="flex justify-between items-center py-2 border-b last:border-b-0"
            >
              <div>
                <p className="text-gray-700 font-medium">{liability.type}</p>
                {liability.description && (
                  <p className="text-sm text-gray-500">{liability.description}</p>
                )}
                {['Loan', 'Mortgage'].includes(liability.type) && liability.term && (
                  <p className="text-sm text-gray-500">
                    {liability.term} years @ {liability.interest_rate}%
                  </p>
                )}
              </div>
              <p className="font-medium">
                {financialCalculations.formatCurrency(liability.amount)}
              </p>
            </div>
                ))
              ) : (
                <p className="text-gray-500 text-center py-2">No liabilities recorded</p>
              )}
            </div>

              {/* Summary statistics with cleaner formatting */}
              <div className="mt-4 pt-4 border-t space-y-3">
                <div className="flex justify-between items-center">
                  <span className="font-medium text-gray-700">Total Liabilities</span>
                  <span className="font-medium text-lg">
                    {financialCalculations.formatCurrency(financialSummary.totalLiabilities)}
                  </span>
                </div>
                <div className="flex justify-between items-center">
                  <span className="font-medium text-gray-700">Annual Debt Service</span>
                  <span className="font-medium">
                    {financialCalculations.formatCurrency(financialSummary.annualDebtService)}
                  </span>
                </div>
                <div className="flex justify-between items-center">
                  <span className="font-medium text-gray-700">Debt Service Ratio</span>
                  <span className={`font-medium ${
                    ((financialSummary.annualDebtService / financialSummary.totalIncome) * 100) > 30 
                      ? 'text-red-600' 
                      : 'text-green-600'
                  }`}>
                    {financialSummary.totalIncome > 0
                      ? ((financialSummary.annualDebtService / financialSummary.totalIncome) * 100).toFixed(1)
                      : '0.0'}%
                  </span>
                </div>
              </div>
            </div>

              {/* Detailed Breakdowns */}
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
                {/* Income Breakdown */}
                <div className="bg-white rounded-lg shadow-lg p-6">
                  <h3 className="text-lg font-semibold mb-4">Income Sources</h3>
                  <div className="h-64 flex justify-center items-center mb-4">
            <Pie 
              data={incomeChartData}
              options={{
                plugins: {
                  legend: {
                    position: 'bottom',
                    labels: {
                      boxWidth: 12,
                      padding: 16
                    }
                  },
                  tooltip: {
                    callbacks: {
                      label: function(context) {
                        let label = context.label || '';
                        let value = context.raw || 0;
                        let total = context.chart.data.datasets[0].data.reduce((a, b) => (a as number) + (b as number), 0);
                        let percentage = Math.round((value as number / (total as number)) * 100);
                        return `${label}: ${financialCalculations.formatCurrency(value as number)} (${percentage}%)`;
                      }
                    }
                  }
                }
              }}
            />
          </div>
          <div className="mt-4 space-y-2">
            {data.incomes.map((income, index) => (
              <div key={index} className="flex justify-between py-2 border-b">
                <span className="font-medium">{income.type}</span>
                <div className="text-right">
                  <div>{financialCalculations.formatCurrency(income.amount)}</div>
                  <div className="text-gray-500 text-xs">
                    {income.frequency}
                  </div>
                </div>
              </div>
            ))}
            <div className="flex justify-between pt-3 border-t mt-2">
              <span className="font-medium">Monthly Total</span>
              <span className="font-medium">
                {financialCalculations.formatCurrency(financialSummary.monthlyIncome)}
              </span>
            </div>
          </div>
        </div>
        <div className="bg-white rounded-lg shadow-lg p-6">
          <h3 className="text-lg font-semibold mb-4">Risk Profile</h3>
          {riskProfileData ? (
            <RiskProfileResults riskData={riskProfileData} />
          ) : (
            <div className="text-center py-8">
              <p className="text-gray-500">No risk profile data available</p>
            </div>
          )}
        </div>

        <div className="bg-white rounded-lg shadow">
            <div className="flex items-center justify-between p-4 border-b">
              <h2 className="text-xl font-semibold">Documents</h2>
              <button 
                onClick={navigateToDocuments}
                className="text-sm text-blue-600 hover:text-blue-800"
              >
                View All
              </button>
            </div>
            
            <div className="p-4">
              <DocumentList 
                key={refreshDocuments}
                clientId={clientId}
                onSelectDocument={handleDocumentSelect}
                adviserMode={true}
                showExtractedData={false}
              />
            </div>
          </div>

          <FileNoteComponent 
        clientId={clientId!} 
        onDataExtracted={handleExtractedData}
      />
          
      </div>

      
    </div>
  );
};

export default ClientDetails;
</file>

<file path="src/components/Adviser/ClientList.tsx">
// src/components/Adviser/ClientsList.tsx
import React, { useEffect, useState } from 'react';
import { supabase } from '../../services/supabaseClient';

interface Client {
  id: string;
  name: string;
  email: string;
  created_at: string;
}

const ClientsList: React.FC = () => {
  const [clients, setClients] = useState<Client[]>([]);

  const fetchClients = async () => {
    const { data, error } = await supabase.from('clients').select('*');
    if (error) console.error(error);
    else setClients(data as Client[]);
  };

  useEffect(() => {
    fetchClients();
  }, []);

  return (
    <div>
      <h2>Your Clients</h2>
      <ul>
        {clients.map((client) => (
          <li key={client.id}>
            {client.name} ({client.email})
          </li>
        ))}
      </ul>
    </div>
  );
};

export default ClientsList;
</file>

<file path="src/components/Adviser/ClientSummary.tsx">
import React, { useState } from 'react';
import { financialCalculations } from '../../utils/financialcalculationMetrics';
import type { Income, Expenditure, Asset, Liability, Goal, Profile, ClientData } from '../../@types/financial';

interface ClientSummaryProps {
  data: ClientData;
}

const ClientSummary: React.FC<ClientSummaryProps> = ({ data }) => {
  const [isExpanded, setIsExpanded] = useState(true);
  
  const toggleExpand = () => {
    setIsExpanded(!isExpanded);
  };
  // Calculate financial metrics
  const financialSummary = financialCalculations.calculateFinancialSummary({
    incomes: data.incomes,
    expenditures: data.expenditures,
    assets: data.assets,
    liabilities: data.liabilities,
    goals: data.goals
  });

  // Check for missing sections
  const missingData = {
    income: data.incomes.length === 0,
    expenditure: data.expenditures.length === 0,
    assets: data.assets.length === 0,
    liabilities: data.liabilities.length === 0,
    goals: data.goals.length === 0,
    riskAssessment: data.risk_assessments.length === 0,
    kyc: !data.profile?.kyc
  };

  const hasMissingData = Object.values(missingData).some(missing => missing);

  // Extract age if date of birth exists
  let age: number | null = null;
  if (data.profile?.kyc?.date_of_birth) {
    const dob = new Date(data.profile.kyc.date_of_birth);
    const today = new Date();
    age = today.getFullYear() - dob.getFullYear();
    
    // Adjust age if birthday hasn't occurred yet this year
    const m = today.getMonth() - dob.getMonth();
    if (m < 0 || (m === 0 && today.getDate() < dob.getDate())) {
      age--;
    }
  }

  // Find retirement goal if it exists
  const retirementGoal = data.goals.find(goal => 
    goal.goal.toLowerCase().includes('retirement')
  );

  // Create summary text
  const createSummary = () => {
    let summary = '';
    
    // Personal info
    if (data.profile?.name) {
      summary += `${data.profile.name} `;
      if (age) {
        summary += `is ${age} years old `;
      }
    }
    
    
    // Family situation - placeholder since we don't have family info in the data model
    // This would be expanded with actual data when available
    
    // Financial position
    summary += `They have a net worth of ${financialCalculations.formatCurrency(financialSummary.netWorth)} `;
    summary += `with total assets of ${financialCalculations.formatCurrency(financialSummary.totalAssets)} `;
    summary += `and liabilities of ${financialCalculations.formatCurrency(financialSummary.totalLiabilities)}. `;
    
    // Monthly income/expenditure
    summary += `Monthly income is ${financialCalculations.formatCurrency(financialSummary.monthlyIncome)} `;
    summary += `with expenditure of ${financialCalculations.formatCurrency(financialSummary.monthlyExpenditure)}, `;
    
    const monthlySurplus = financialSummary.monthlyIncome - financialSummary.monthlyExpenditure;
    if (monthlySurplus > 0) {
      summary += `resulting in a monthly surplus of ${financialCalculations.formatCurrency(monthlySurplus)}. `;
    } else {
      summary += `resulting in a monthly deficit of ${financialCalculations.formatCurrency(Math.abs(monthlySurplus))}. `;
    }
    
    // Goals
    if (data.goals.length > 0) {
      summary += `Their financial goals include `;
      
      const goalStrings = data.goals.map(goal => {
        return `${goal.goal.toLowerCase()} (${financialCalculations.formatCurrency(goal.target_amount)} in ${goal.time_horizon} years)`;
      });
      
      if (goalStrings.length === 1) {
        summary += goalStrings[0];
      } else {
        const lastGoal = goalStrings.pop();
        summary += `${goalStrings.join(', ')} and ${lastGoal}`;
      }
      
      summary += '. ';
    }
    
    // Retirement specific info
    if (retirementGoal) {
      summary += `They are planning for retirement in ${retirementGoal.time_horizon} years `;
      summary += `with a target of ${financialCalculations.formatCurrency(retirementGoal.target_amount)}. `;
    }
    
    return summary;
  };

  return (
    <div className="bg-white rounded-lg shadow-lg p-6 mb-8">
      <div className="flex justify-between items-center mb-4">
        <h3 className="text-lg font-semibold">Client Summary</h3>
        <button 
          onClick={toggleExpand} 
          className="p-1 hover:bg-gray-100 rounded-full transition-colors"
        >
          <svg 
            xmlns="http://www.w3.org/2000/svg" 
            className="h-5 w-5 text-gray-600" 
            fill="none" 
            viewBox="0 0 24 24" 
            stroke="currentColor"
          >
            {isExpanded ? (
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
            ) : (
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
            )}
          </svg>
        </button>
      </div>
      
      {isExpanded && (
        <>
          <div className="mb-4">
            <p className="text-gray-700">{createSummary()}</p>
          </div>
          
          {hasMissingData && (
            <div className="mt-4 pt-4 border-t border-gray-200">
              <h4 className="font-medium text-gray-700 mb-2">Profile Completion</h4>
              <p className="text-gray-600">
                Please help your client complete their profile by collecting information about:
                {[
                  missingData.kyc && 'KYC information',
                  missingData.income && 'income details',
                  missingData.expenditure && 'expenditure',
                  missingData.assets && 'assets',
                  missingData.liabilities && 'liabilities',
                  missingData.goals && 'financial goals',
                  missingData.riskAssessment && 'risk assessment'
                ].filter(Boolean).join(', ')}.
              </p>
              <p className="text-gray-600 mt-2">
                A complete profile will help provide more accurate financial recommendations.
              </p>
            </div>
          )}
        </>
      )}
      
      {!isExpanded && hasMissingData && (
        <div className="flex items-center">
          <span className="text-sm text-gray-600">
            Client profile needs additional information
          </span>
        </div>
      )}
    </div>
  );
};

export default ClientSummary;
</file>

<file path="src/components/Adviser/CreateClient.tsx">
// src/components/Adviser/CreateClient.tsx
import React, { useState } from 'react';
import { supabase } from '../../services/supabaseClient';
import { useNavigate } from 'react-router-dom';
import { AuthContext } from '../../context/AuthContext';

const CreateClient: React.FC = () => {
  const navigate = useNavigate();
  const { user } = React.useContext(AuthContext);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [clientData, setClientData] = useState({
    name: '',
    email: '',
    password: '', // temporary password that client can change later
  });
  
  const handleCreateClient = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError(null);
  
    try {
      if (!user?.id) {
        throw new Error('Adviser not authenticated');
      }
  
      console.log('Attempting to create client with:', {
        email: clientData.email,
        name: clientData.name,
        adviserID: user.id
      });
  
      // Check existing users in both auth.users and profiles
      const { data: authUsersCheck, error: authCheckError } = await supabase.auth.admin.listUsers();
      
      console.log('Auth users check:', {
        users: authUsersCheck?.users.map(u => u.email),
        error: authCheckError
      });
  
      const existingAuthUser = authUsersCheck?.users.find(
        authUser => authUser.email && authUser.email.toLowerCase() === clientData.email.toLowerCase()
      );
  
      if (existingAuthUser) {
        console.error('Existing auth user found:', existingAuthUser);
        throw new Error('A user with this email already exists in the authentication system');
      }
  
      // Check profiles table
      const { data: existingProfiles, error: profileCheckError } = await supabase
        .from('profiles')
        .select('*')
        .eq('email', clientData.email)
        .eq('role', 'client');
  
      console.log('Existing profiles check:', {
        profiles: existingProfiles,
        error: profileCheckError
      });
  
      if (existingProfiles && existingProfiles.length > 0) {
        console.error('Existing profile found:', existingProfiles);
        throw new Error('A client with this email already exists');
      }

      const { data, error } = await supabase.auth.admin.createUser({
        email: clientData.email,
        password: clientData.password,
        email_confirm: true, // Automatically confirm the email
        user_metadata: {
          role: 'client',
          name: clientData.name,
          adviser_id: user.id
        }
      });
  
      if (error) {
        console.error('User creation error:', error);
        throw error;
      }
  
      if (!data.user) {
        throw new Error('No user data returned');
      }
  
      // Create profile
      const { error: profileError } = await supabase
        .from('profiles')
        .upsert({
          id: data.user.id,
          email: clientData.email,
          name: clientData.name,
          role: 'client',
          adviser_id: user.id,
          created_at: new Date().toISOString()
        });
  
      if (profileError) {
        console.error('Profile creation error:', profileError);
        // Attempt to delete the auth user if profile creation fails
        await supabase.auth.admin.deleteUser(data.user.id);
        throw profileError;
      }
  
      alert(
        `Client account created successfully!\n\n` +
        `Email: ${clientData.email}\n` +
        `Temporary Password: ${clientData.password}\n\n` +
        `Please provide these credentials to your client.`
      );
      
      navigate('/adviser/adviser-dashboard');
  
    } catch (err: any) {
      console.error('Full error object:', err);
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  // ADD IMPORT CLIENT FROM API OPTIONS FUNCTIONALITY

  return (
    <div className="min-h-screen bg-white p-4 sm:p-6 md:p-8">
      <div className="max-w-xl mx-auto">
        {/* Header */}
        <div className="mb-8">
          <button 
            onClick={() => navigate('/adviser/adviser-dashboard')}
            className="text-gray-600 hover:text-gray-900 mb-4 flex items-center gap-2"
          >
            ← Back to Dashboard
          </button>
          <h1 className="text-2xl font-semibold text-gray-900">Create New Client</h1>
        </div>

        {error && (
          <div className="mb-6 p-4 bg-red-50 border border-red-100 rounded-lg text-red-600">
            {error}
          </div>
        )}

        <form onSubmit={handleCreateClient} className="space-y-6">
          <div className="space-y-1">
            <label className="block text-sm font-medium text-gray-700">
              Client Name
            </label>
            <input
              type="text"
              value={clientData.name}
              onChange={(e) => setClientData({...clientData, name: e.target.value})}
              required
              className="w-full px-3 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              placeholder="Enter full name"
            />
          </div>

          <div className="space-y-1">
            <label className="block text-sm font-medium text-gray-700">
              Email Address
            </label>
            <input
              type="email"
              value={clientData.email}
              onChange={(e) => setClientData({...clientData, email: e.target.value})}
              required
              className="w-full px-3 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              placeholder="client@example.com"
            />
          </div>

          <div className="space-y-1">
            <label className="block text-sm font-medium text-gray-700">
              Temporary Password
            </label>
            <input
              type="password"
              value={clientData.password}
              onChange={(e) => setClientData({...clientData, password: e.target.value})}
              required
              className="w-full px-3 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              placeholder="Enter temporary password"
            />
            <p className="text-sm text-gray-500 mt-1">
              Client will be able to change this after first login
            </p>
          </div>

          <div className="pt-4">
            <button
              type="submit"
              disabled={loading}
              className={`w-full px-4 py-2 rounded-lg font-medium transition-colors
                ${loading 
                  ? 'bg-gray-100 text-gray-400 cursor-not-allowed'
                  : 'bg-blue-600 hover:bg-blue-700 text-white'
                }`}
            >
              {loading ? 'Creating Client...' : 'Create Client'}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default CreateClient;
</file>

<file path="src/components/Adviser/Dashboard.tsx">
// src/components/Adviser/Dashboard

import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { supabase } from '../../services/supabaseClient';
// import { Bar } from 'react-chartjs-2';
import { Clock, Users, ArrowUpRight } from 'lucide-react';
import { RiskScores } from 'utils/riskAssessment';

interface Client {
  id: string;
  name: string;
  email: string;
  created_at: string;
  workflow_progress: number;
  riskProfile?: RiskScores | null;
}


const AdviserDashboard = () => {
  const navigate = useNavigate();
  const [clients, setClients] = useState<Client[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchClients = async () => {
      setLoading(true);
      const { data: { user } } = await supabase.auth.getUser();
      
      if (!user) {
        console.log('No authenticated user found');
        setLoading(false);
        return;
      }

      console.log('Fetching clients for adviser:', user.id);

      const { data: adviserProfile, error: adviserError } = await supabase
      .from('profiles')
      .select('*')
      .eq('adviser_id', user.id)
      .eq('role', 'client');

    if (adviserError) {
      console.error('Error fetching adviser profile:', adviserError);
      return;
    }

    console.log('Adviser profile:', adviserProfile);
      
      const { data, error } = await supabase
        .from('profiles')
        .select(`
          id,
          name,
          email,
          created_at,
          risk_assessments (
        calculated_scores,
        created_at
      )
        `)
        .eq('adviser_id', user.id)
        .eq('role', 'client');

        console.log('Client query result:', { data, error });

        if (error) {
          console.error('Error fetching clients:', error);
          setLoading(false);
          return;
        }

      // Calculate workflow progress for each client
      const clientsWithProgress = await Promise.all(data.map(async (client) => {
        const tables = ['incomes', 'expenditures', 'assets', 'liabilities', 'goals', 'risk_assessments'];
        let completedSteps = 0;

        for (const table of tables) {
          const { count } = await supabase
            .from(table)
            .select('*', { count: 'exact', head: true })
            .eq('client_id', client.id);

          if (count && count > 0) completedSteps++;
        }

        const riskProfile = client.risk_assessments?.[0]?.calculated_scores || null;

        return {
          ...client,
          workflow_progress: (completedSteps / tables.length) * 100, 
          risk_assessments: riskProfile
        };
      }));

      console.log('Processed clients:', clientsWithProgress);
      setClients(clientsWithProgress);
      setLoading(false);
    };

    fetchClients();
  }, []);

  const formatLastActivity = (date: string) => {
    const activityDate = new Date(date);
    const now = new Date();
    const diffDays = Math.floor((now.getTime() - activityDate.getTime()) / (1000 * 60 * 60 * 24));
    
    if (diffDays === 0) return 'Today';
    if (diffDays === 1) return 'Yesterday';
    if (diffDays < 7) return `${diffDays} days ago`;
    return activityDate.toLocaleDateString();
  };

  return (
    <div className="min-h-screen bg-gray-50">
      <header className="bg-white shadow">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
          <div className="flex justify-between items-center">
            <h1 className="text-2xl font-bold text-gray-900">Adviser Dashboard</h1>
            <button
              onClick={() => navigate('/adviser/create-client')}
              className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
            >
              Add New Client
            </button>
          </div>
        </div>
      </header>

      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        {loading ? (
          <div className="text-center py-12">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto"></div>
            <p className="mt-4 text-gray-500">Loading client data...</p>
          </div>
        ) : (
          <div className="space-y-6">
           
            <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
              <div className="bg-white p-6 rounded-lg shadow">
                <div className="flex items-center">
                  <Users className="h-8 w-8 text-blue-500" />
                  <div className="ml-4">
                    <p className="text-sm text-gray-500">Total Clients</p>
                    <p className="text-2xl font-semibold">{clients.length}</p>
                  </div>
                </div>
              </div>
            </div>
            
            <div className="bg-white shadow rounded-lg overflow-hidden">
              <div className="px-4 py-5 sm:px-6">
                <h3 className="text-lg font-medium text-gray-900">Your Clients</h3>
              </div>
              <div className="border-t border-gray-200">
                <div className="overflow-x-auto">
                  <table className="min-w-full divide-y divide-gray-200">
                    <thead className="bg-gray-50">
                      <tr>
                        <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                          Client Name
                        </th>
                        <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                          Workflow Progress
                        </th>
                        <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                          Last Activity
                        </th>
                        <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                          Last Review
                        </th>
                        <th colSpan={2} className="px-4 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">
                          Actions
                        </th>
                      </tr>
                    </thead>
                    <tbody className="bg-white divide-y divide-gray-200">
                      {clients.map((client) => (
                        <tr 
                          key={client.id}
                          className="hover:bg-gray-50 cursor-pointer"
                          onClick={() => navigate(`/adviser/client/${client.id}`)}
                        >
                          <td className="px-4 py-4 whitespace-nowrap">
                            <div className="flex items-center">
                              <div>
                                <div className="text-sm font-medium text-gray-900">{client.name}</div>
                                <div className="text-sm text-gray-500">{client.email}</div>
                              </div>
                            </div>
                          </td>
                          <td className="px-4 py-4 whitespace-nowrap">
                            <div className="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-700">
                              <div 
                                className="bg-blue-600 h-2.5 rounded-full" 
                                style={{ width: `${client.workflow_progress}%` }}
                              ></div>
                            </div>
                            <span className="text-xs text-gray-500 mt-1">
                              {Math.round(client.workflow_progress)}% Complete
                            </span>
                          </td>
                          
                          <td className="px-4 py-4 whitespace-nowrap text-left text-sm font-medium">
                            <button
                              onClick={(e) => {
                                e.stopPropagation();
                                navigate(`/adviser/client/${client.id}`);
                              }}
                              className="text-blue-600 hover:text-blue-900"
                            >
                              View Details
                            </button>
                          </td>
                          <td className="px-4 py-4 whitespace-nowrap text-left text-sm font-medium">
                            <button
                              // onClick={(e) => {
                              //   e.stopPropagation();
                              //   navigate(`/adviser/client/${client.id}/insights`);
                              // }}
                              className="text-blue-600 hover:text-blue-900"
                            >
                              Holding Text
                            </button>
                          </td>
                          <td className="px-4 py-4 whitespace-nowrap text-left text-sm font-medium">
                            <button
                              onClick={(e) => {
                                e.stopPropagation();
                                navigate(`/adviser/client/${client.id}/insights`);
                              }}
                              className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
                            >
                              Insights
                            </button>
                          </td>
                          <td className="px-4 py-4 whitespace-nowrap text-left text-sm font-medium">
                            <button
                              onClick={(e) => {
                                 e.stopPropagation();
                                navigate(`/adviser/client/${client.id}/suitability-report`);
                              }}
                              className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
                            >
                              Generate Suitability Report
                            </button>
                          </td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>
        )}
      </main>
    </div>
  );
};

export default AdviserDashboard;
</file>

<file path="src/components/Adviser/ExportClientData.tsx">
// src/components/Adviser/ExportClientData.tsx
import React from 'react';
import { supabase } from '../../services/supabaseClient';
import { useParams } from 'react-router-dom';
import { Parser } from 'json2csv';

const ExportClientData: React.FC = () => {
  const { clientId } = useParams<{ clientId: string }>();

  const handleExport = async () => {
    const [
      { data: incomes, error: incomesError },
      { data: expenditures, error: expendituresError },
      { data: assets, error: assetsError },
      { data: liabilities, error: liabilitiesError },
      { data: goals, error: goalsError },
    ] = await Promise.all([
      supabase.from('incomes').select('*').eq('client_id', clientId),
      supabase.from('expenditures').select('*').eq('client_id', clientId),
      supabase.from('assets').select('*').eq('client_id', clientId),
      supabase.from('liabilities').select('*').eq('client_id', clientId),
      supabase.from('goals').select('*').eq('client_id', clientId),
    ]);

    if (incomesError || expendituresError || assetsError || liabilitiesError || goalsError) {
      console.error('Error fetching data:', { incomesError, expendituresError, assetsError, liabilitiesError, goalsError });
      alert('Error fetching data.');
      return;
    }

    const allDataArray = [
      ...(incomes || []).map((item) => ({
        dataType: 'Income',
        ...item,
      })),
      ...(expenditures || []).map((item) => ({
        dataType: 'Expenditure',
        ...item,
      })),
      ...(assets || []).map((item) => ({
        dataType: 'Asset',
        ...item,
      })),
      ...(liabilities || []).map((item) => ({
        dataType: 'Liability',
        ...item,
      })),
      ...(goals || []).map((item) => ({
        dataType: 'Goal',
        ...item,
      })),
    ];

    const parser = new Parser();
    const csv = parser.parse(allDataArray);

    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);

    const link = document.createElement('a');
    link.href = url;
    link.setAttribute('download', `client_${clientId}_data.csv`);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  return <button onClick={handleExport}>Export Data</button>;
};

export default ExportClientData;
</file>

<file path="src/components/Adviser/ExtractionPreviewComponent.tsx">
import React, { useState, useEffect } from 'react';
import { ExtractedData } from '../../@types/fileNote';

interface ExtractionPreviewComponentProps {
  extractedData: any;
  summary: string;
  onConfirm: (updatedData: any, updatedSummary: string) => void;
  onCancel: () => void;
}

const ExtractionPreviewComponent: React.FC<ExtractionPreviewComponentProps> = ({
  extractedData,
  summary,
  onConfirm,
  onCancel
}) => {
  const [editedData, setEditedData] = useState<any>(extractedData);
  const [editedSummary, setEditedSummary] = useState<string>(summary);

  // Render function for different data types
  const renderDataField = (key: string, value: any, path: string = '') => {
    // Handle nested objects
    if (typeof value === 'object' && value !== null) {
      return (
        <div key={`${path}${key}`} className="mb-4">
          <h4 className="font-semibold text-gray-700 mb-2">{key}</h4>
          <div className="pl-4">
            {Object.entries(value).map(([nestedKey, nestedValue]) => 
              renderDataField(nestedKey, nestedValue, `${path}${key}.`)
            )}
          </div>
        </div>
      );
    }

    // Handle primitive values
    return (
        <div key={`${path}${key}`} className="mb-2">
          <label className="block text-sm font-medium text-gray-600 mb-1">
            {key}
          </label>
          <input
            type="text"
            value={value?.toString() || ''}
            onChange={(e) => {
              setEditedData((prev: ExtractedData) => {
                // Create a deep copy of the previous state
                const updatedData = JSON.parse(JSON.stringify(prev));
                
                // Handle nested path
                if (path) {
                  let current = updatedData;
                  const parts: string[] = path.split('.').filter((part: string) => part);
                  
                  // Navigate to the correct nesting level
                  for (let i = 0; i < parts.length; i++) {
                    if (!current[parts[i]]) {
                      current[parts[i]] = {};
                    }
                    current = current[parts[i]];
                  }
                  
                  // Update the value
                  current[key] = e.target.value;
                } else {
                  // Direct property
                  updatedData[key] = e.target.value;
                }
                
                return updatedData;
              });
            }}
            className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
        </div>
      );
    };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4">
      <div className="bg-white rounded-lg shadow-xl max-w-4xl w-full max-h-[90vh] overflow-y-auto">
        {/* Header */}
        <div className="bg-gray-100 px-6 py-4 border-b border-gray-200 flex justify-between items-center">
          <h2 className="text-xl font-semibold text-gray-800">
            Review Extracted Information
          </h2>
          <button 
            onClick={onCancel}
            className="text-gray-500 hover:text-gray-700"
          >
            ✕
          </button>
        </div>

        {/* Content */}
        <div className="p-6 grid md:grid-cols-2 gap-6">
          {/* Extracted Data Preview */}
          <div>
            <h3 className="text-lg font-medium mb-4 text-gray-700">
              Extracted Details
            </h3>
            <div className="space-y-4">
              {Object.entries(editedData).map(([key, value]) => 
                renderDataField(key, value)
              )}
            </div>
          </div>

          {/* Summary Section */}
          <div>
            <h3 className="text-lg font-medium mb-4 text-gray-700">
              Client Summary
            </h3>
            <textarea
              value={editedSummary}
              onChange={(e) => setEditedSummary(e.target.value)}
              className="w-full h-64 px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
              placeholder="Edit client summary..."
            />
          </div>
        </div>

        {/* Actions */}
        <div className="bg-gray-100 px-6 py-4 border-t border-gray-200 flex justify-end space-x-3">
          <button
            onClick={onCancel}
            className="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-100"
          >
            Cancel
          </button>
          <button
            onClick={() => onConfirm(editedData, editedSummary)}
            className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
          >
            Confirm
          </button>
        </div>
      </div>
    </div>
  );
};

export default ExtractionPreviewComponent;
</file>

<file path="src/components/Adviser/FileNote.tsx">
// src/components/Adviser/FileNoteComponent.tsx
import React, { useState, useEffect } from 'react';
import { supabase } from '../../services/supabaseClient';
import { ExtractedData } from '../../@types/fileNote';
import ExtractionPreviewComponent from './ExtractionPreviewComponent';

interface FileNote {
  id: string;
  client_id: string;
  adviser_id: string;
  content: string;
  created_at: string;
  summary?: string;
  extracted_data?: ExtractedData;
}

interface FileNoteComponentProps {
  clientId: string;
  onDataExtracted?: (extractedData: ExtractedData) => void;
}

const FileNoteComponent: React.FC<FileNoteComponentProps> = ({ clientId, onDataExtracted }) => {
  const [notes, setNotes] = useState<FileNote[]>([]);
  const [newNote, setNewNote] = useState('');
  const [isAdding, setIsAdding] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [isParsing, setIsParsing] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [expandedNoteId, setExpandedNoteId] = useState<string | null>(null);
  const [expandedSummary, setExpandedSummary] = useState<boolean>(false);
  const [clientSummary, setClientSummary] = useState<string | null>(null);
  

  // Fetch existing notes
  useEffect(() => {
    const fetchNotes = async () => {
      setIsLoading(true);
      try {
        const { data, error } = await supabase
          .from('file_notes')
          .select('*')
          .eq('client_id', clientId)
          .order('created_at', { ascending: false });

        if (error) throw error;
        setNotes(data || []);

        // Get client summary if available
        const { data: summaryData, error: summaryError } = await supabase
          .from('client_summaries')
          .select('summary')
          .eq('client_id', clientId)
          .single();

        if (!summaryError && summaryData) {
          setClientSummary(summaryData.summary);
        }
      } catch (error) {
        console.error('Error fetching notes:', error);
        setError('Failed to load file notes');
      } finally {
        setIsLoading(false);
      }
    };

    if (clientId) {
      fetchNotes();
    }
  }, [clientId]);

  const addNote = async () => {
    if (!newNote.trim()) return;

    setIsLoading(true);
    setError(null);

    try {
      // Get current user ID
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('User not authenticated');

      // Insert the new note
      const { data, error } = await supabase
        .from('file_notes')
        .insert({
          client_id: clientId,
          adviser_id: user.id,
          content: newNote,
          created_at: new Date().toISOString()
        })
        .select();

      if (error) throw error;

      // Update local state
      if (data && data.length > 0) {
        setNotes(prev => [data[0], ...prev]);
        setNewNote('');
        setIsAdding(false);
      }
    } catch (error) {
      console.error('Error adding note:', error);
      setError('Failed to add file note');
    } finally {
      setIsLoading(false);
    }
  };

  const [extractionPreview, setExtractionPreview] = useState<{
    noteId: string;
    extractedData: any;
    summary: string;
  } | null>(null);

  const parseNote = async (noteId: string) => {
    const note = notes.find(n => n.id === noteId);
    if (!note) return;

    setIsParsing(true);
    setError(null);

    try {
      // Call serverless function to parse note
      const response = await fetch('/.netlify/functions/parse-file-note', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          noteContent: note.content,
          clientId
        })
      });

      if (!response.ok) {
        throw new Error('Failed to parse note');
      }

      const { extractedData, summary } = await response.json();

      // Show the preview instead of updating immediately
      setExtractionPreview({
        noteId,
        extractedData,
        summary
      });
    } catch (error) {
      console.error('Error parsing note:', error);
      setError('Failed to parse file note');
    } finally {
      setIsParsing(false);
    }
  };

  const confirmExtraction = async () => {
    if (!extractionPreview) return;
    
    const { noteId, extractedData, summary } = extractionPreview;
    
    try {
      // Show loading state
      setIsParsing(true);
      
      // Update note with extracted data and summary
      const { error: updateError } = await supabase
        .from('file_notes')
        .update({
          extracted_data: extractedData,
          summary: summary
        })
        .eq('id', noteId);

      if (updateError) throw updateError;

      // Update or create client summary
      const { error: summaryError } = await supabase
        .from('client_summaries')
        .upsert({
          client_id: clientId,
          summary: summary,
          updated_at: new Date().toISOString()
        });

      if (summaryError) throw summaryError;

      // Update local state
      setNotes(prevNotes => 
        prevNotes.map(n => 
          n.id === noteId 
            ? { ...n, extracted_data: extractedData, summary } 
            : n
        )
      );
      
      setClientSummary(summary);

      // Notify parent component about extracted data
      if (onDataExtracted) {
        // Use setTimeout to allow UI to update first before potentially heavy processing
        setTimeout(() => {
          onDataExtracted(extractedData);
        }, 0);
      }

      // Clear the preview
      setExtractionPreview(null);
    } catch (error) {
      console.error('Error updating with extracted data:', error);
      setError('Failed to update with extracted data');
    } finally {
      setIsParsing(false);
    }
  };

  const cancelExtraction = () => {
    setExtractionPreview(null);
  };

  const formatDate = (dateString: string) => {
    const options: Intl.DateTimeFormatOptions = { 
      year: 'numeric', 
      month: 'short', 
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    };
    return new Date(dateString).toLocaleDateString(undefined, options);
  };

  return (
    <div className="bg-white rounded-lg shadow-lg p-6 mb-8">
      <div className="flex justify-between items-center mb-4">
        <h2 className="text-xl font-semibold">File Notes</h2>
        {!isAdding && (
          <button
            onClick={() => setIsAdding(true)}
            className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
          >
            Add Note
          </button>
        )}
      </div>

      {/* Client Summary Section */}
      {clientSummary && (
        <div className="mb-6 bg-blue-50 p-4 rounded-lg border border-blue-200">
          <div className="flex justify-between items-center mb-2">
            <h3 className="text-lg font-medium text-blue-800">Client Summary</h3>
            <button
              onClick={() => setExpandedSummary(!expandedSummary)}
              className="text-blue-600 hover:text-blue-800"
            >
              {expandedSummary ? 'Collapse' : 'Expand'}
            </button>
          </div>
          {expandedSummary ? (
            <div className="text-sm text-gray-700">{clientSummary}</div>
          ) : (
            <div className="text-sm text-gray-700 line-clamp-2">{clientSummary}</div>
          )}
        </div>
      )}

      {/* Data Extraction Preview */}
      {extractionPreview && (
        <ExtractionPreviewComponent
          extractedData={extractionPreview.extractedData}
          summary={extractionPreview.summary}
          onConfirm={(updatedData, updatedSummary) => {
            // Update the extraction preview with edited data before confirming
            setExtractionPreview({
              ...extractionPreview,
              extractedData: updatedData,
              summary: updatedSummary
            });
            confirmExtraction();
          }}
          onCancel={cancelExtraction}
        />
      )}

      {/* Error messages */}
      {error && (
        <div className="mb-4 p-3 bg-red-50 border border-red-200 rounded-lg text-red-600">
          {error}
        </div>
      )}

      {/* Add new note form */}
      {isAdding && (
        <div className="mb-6 bg-gray-50 p-4 rounded-lg">
          <h3 className="text-lg font-medium mb-2">New File Note</h3>
          <textarea
            value={newNote}
            onChange={(e) => setNewNote(e.target.value)}
            className="w-full p-3 border rounded-lg focus:ring-2 focus:ring-blue-500 min-h-[200px]"
            placeholder="Enter meeting notes, client goals, details about assets, liabilities, dependents, etc."
          />
          <div className="flex justify-end mt-3 space-x-3">
            <button
              onClick={() => setIsAdding(false)}
              className="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-100"
              disabled={isLoading}
            >
              Cancel
            </button>
            <button
              onClick={addNote}
              disabled={isLoading || !newNote.trim()}
              className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-400"
            >
              {isLoading ? 'Saving...' : 'Save Note'}
            </button>
          </div>
        </div>
      )}

      {/* List of existing notes */}
      <div className="space-y-4">
        {notes.length === 0 && !isLoading ? (
          <p className="text-gray-500 text-center py-8">No file notes yet</p>
        ) : (
          notes.map((note) => (
            <div key={note.id} className="border rounded-lg overflow-hidden">
              <div className="bg-gray-50 px-4 py-3 flex justify-between items-center">
                <div>
                  <p className="font-medium">{formatDate(note.created_at)}</p>
                </div>
                <div className="flex space-x-2">
                  {!note.extracted_data && (
                    <button
                      onClick={() => parseNote(note.id)}
                      disabled={isParsing}
                      className="px-3 py-1 bg-green-600 text-white text-sm rounded hover:bg-green-700 disabled:bg-gray-400"
                    >
                      {isParsing ? 'Extracting...' : 'Extract Data'}
                    </button>
                  )}
                  <button
                    onClick={() => setExpandedNoteId(expandedNoteId === note.id ? null : note.id)}
                    className="px-3 py-1 bg-gray-200 text-sm rounded hover:bg-gray-300"
                  >
                    {expandedNoteId === note.id ? 'Collapse' : 'Expand'}
                  </button>
                </div>
              </div>
              
              {/* Note content */}
              {expandedNoteId === note.id && (
                <div className="p-4 border-t">
                  <div className="prose max-w-none">
                    {note.content.split('\n').map((paragraph, idx) => (
                      <p key={idx} className="mb-2">{paragraph}</p>
                    ))}
                  </div>
                  
                  {/* Show extracted data if available */}
                  {note.extracted_data && (
                    <div className="mt-4 pt-4 border-t">
                      <h4 className="font-medium mb-2">Extracted Information</h4>
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-2">
                        {Object.entries(note.extracted_data).map(([key, value]) => (
                          <div key={key} className="bg-gray-50 p-2 rounded">
                            <span className="font-medium">{key}: </span>
                            <span>{JSON.stringify(value)}</span>
                          </div>
                        ))}
                      </div>
                    </div>
                  )}
                  
                  {/* Show summary if available */}
                  {note.summary && (
                    <div className="mt-4 pt-4 border-t">
                      <h4 className="font-medium mb-2">Summary</h4>
                      <p className="text-gray-700">{note.summary}</p>
                    </div>
                  )}
                </div>
              )}
            </div>
          ))
        )}
      </div>
    </div>
  );
};

export default FileNoteComponent;
</file>

<file path="src/components/Adviser/Insights.tsx">
import React from 'react';
import { useParams } from 'react-router-dom';
import AdviserChat from '../Chat/AdviserChat';

const Insights = () => {
  const { clientId } = useParams<{ clientId: string }>();

  if (!clientId) {
    return <div className="p-4 text-red-600">No client ID provided</div>;
  }

  return (
    <div>
      <div className="mt-8 bg-white rounded-lg shadow-lg p-6">
        <h3 className="text-xl font-semibold mb-4">Client Communication & Reports</h3>
        <AdviserChat clientId={clientId} />
      </div>
    </div>
  );
};

export default Insights;
</file>

<file path="src/components/Adviser/Reports.tsx">
import React from 'react';
import { useParams } from 'react-router-dom';
import AdviserReports from '../Chat/AdviserReports';

const Reports = () => {
  const { clientId } = useParams<{ clientId: string }>();

  console.log(clientId, "CLIENT ID FOR ALEX")

  if (!clientId) {
    return <div className="p-4 text-red-600">No client ID provided</div>;
  }

  return (
    <div>
      <div className="mt-8 bg-white rounded-lg shadow-lg p-6">
        <h3 className="text-xl font-semibold mb-4">Client Communication & Reports</h3>
        <AdviserReports clientId={clientId} />
      </div>
    </div>
  );
};

export default Reports;
</file>

<file path="src/components/Adviser/ReportViewer.tsx">
import React from 'react';

interface ReportViewerProps {
  content: string;
  onDownload?: () => void;
}

const ReportViewer = ({ content, onDownload }: ReportViewerProps) => {
  // Parse sections from the content
  // Assuming sections are marked with ## for headers
  const sections = content.split('\n').reduce((acc, line) => {
    if (line.startsWith('##')) {
      acc.push({ title: line.replace('##', '').trim(), content: [] });
    } else if (acc.length > 0) {
      acc[acc.length - 1].content.push(line);
    } else {
      // Content before first section goes into an "Overview" section
      acc.push({ title: 'Overview', content: [line] });
    }
    return acc;
  }, [] as { title: string; content: string[] }[]);

  return (
    <div className="bg-white rounded-lg shadow-lg">
      {/* Header */}
      <div className="border-b border-gray-200 p-6">
        <div className="flex justify-between items-center">
          <h2 className="text-2xl font-semibold text-gray-900">Suitability Report</h2>
          {onDownload && (
            <button
              onClick={onDownload}
              className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
            >
              Download PDF
            </button>
          )}
        </div>
        <p className="mt-2 text-sm text-gray-500">
          Generated on {new Date().toLocaleDateString()}
        </p>
      </div>

      {/* Table of Contents */}
      <div className="p-6 border-b border-gray-200">
        <h3 className="text-lg font-medium mb-4">Contents</h3>
        <nav className="space-y-1">
          {sections.map((section, index) => (
            <a
              key={index}
              href={`#section-${index}`}
              className="text-blue-600 hover:text-blue-800 block"
            >
              {section.title}
            </a>
          ))}
        </nav>
      </div>

      {/* Report Content */}
      <div className="p-6">
        {sections.map((section, index) => (
          <section
            key={index}
            id={`section-${index}`}
            className="mb-8 scroll-mt-6"
          >
            <h3 className="text-xl font-semibold mb-4 text-gray-900">
              {section.title}
            </h3>
            <div className="prose max-w-none">
              {section.content.map((paragraph, pIndex) => (
                <p
                  key={pIndex}
                  className="mb-4 text-gray-700 leading-relaxed"
                >
                  {paragraph}
                </p>
              ))}
            </div>
          </section>
        ))}
      </div>

      {/* Footer */}
      <div className="border-t border-gray-200 p-6">
        <p className="text-sm text-gray-500">
          This report is generated based on the information provided and should be reviewed with your financial adviser.
        </p>
      </div>
    </div>
  );
};

export default ReportViewer;
</file>

<file path="src/components/Adviser/SuitabilityReportGenerator.tsx">
import React, { useState } from 'react';
import { useParams } from 'react-router-dom';
import ReportViewer from './ReportViewer';

interface ModelOption {
  id: string;
  display_name: string;
  provider: string;
}

const SuitabilityReportGenerator: React.FC = () => {
  const { clientId } = useParams<{ clientId: string }>();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState('');
  const [reportContent, setReportContent] = useState('');
  const [modelOptions, setModelOptions] = useState<ModelOption[]>([]);
  const [config, setConfig] = useState({
      model: 'gpt-4o-mini',
      provider: 'openai',
      temperature: 0.7,
      maxTokens: 2000,
      customPrompt: ''
  });

  // Collect and set the language model options from providers
  const getModels = async () => {
    const response = await fetch('/.netlify/functions/get-models', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
    });
  
    if (!response.ok) {
      throw new Error('Failed to fetch language models');
    } 

    return JSON.parse(await response.text()).response;
  }

  React.useEffect(() => {
    const fetchModels = async () => {
      if (!modelOptions.length) {
        const languageModels = await getModels();
        setModelOptions(languageModels);
      }
    };
    
    fetchModels();
  }, [modelOptions]);

  // Model change handler to update provider
  const handleModelChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const selectedModel = modelOptions.find(model => model.id === e.target.value);
    setConfig({ 
      ...config, 
      model: e.target.value,
      provider: selectedModel?.provider || 'anthropic'
    });
  };


  const modelOptionsForSelector = modelOptions.map((model) => (
    <option key={model.id} value={model.id}>
      {model.display_name}
    </option>
  ));

  const generateReport = async () => {
    setIsLoading(true);
    setError('');
    
    try {
        console.log('Sending request with clientId:', clientId); // Log clientId
        console.log('Sending request with config:', config); // Log config
        
      const response = await fetch('/.netlify/functions/generate-suitability-report', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ clientId, config })
      });

      if (!response.ok) {
        throw new Error('Failed to generate report');
      }

      const data = await response.json();
      setReportContent(data.report);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred');
    } finally {
      setIsLoading(false);
      const viewer = document.getElementById("reportViewer")
      setTimeout(function () {
        viewer?.scrollIntoView({
            behavior: "smooth",
            block: "start",
        });
      }, 100);
    }
  };

  return (
    <div className="max-w-4xl mx-auto p-6">
      <div className="bg-white rounded-lg shadow-lg p-6">
        <h2 className="text-2xl font-semibold mb-6">Generate Suitability Report</h2>

        {/* Model Selection */}
        <div className="mb-6">
          <label className="block text-sm font-medium text-gray-700 mb-2">
            Model
          </label>
          <select
            value={config.model}
            onChange={handleModelChange}
            className="w-full p-2 border rounded-lg focus:ring-2 focus:ring-blue-500"
          >
            {modelOptionsForSelector}
          </select>
          <p className="mt-1 text-sm text-gray-500">
            Provider: {config.provider}
          </p>
        </div>

        {/* Temperature Slider */}
        <div className="mb-6">
          <label className="block text-sm font-medium text-gray-700 mb-2">
            Temperature: {config.temperature}
          </label>
          <input
            type="range"
            min="0"
            max="1"
            step="0.1"
            value={config.temperature}
            onChange={(e) => setConfig({ ...config, temperature: parseFloat(e.target.value) })}
            className="w-full"
          />
          <p className="mt-1 text-sm text-gray-500">
            Lower values produce more focused and deterministic outputs
          </p>
        </div>

        {/* Max Tokens */}
        <div className="mb-6">
          <label className="block text-sm font-medium text-gray-700 mb-2">
            Max Tokens
          </label>
          <input
            type="number"
            value={config.maxTokens}
            onChange={(e) => setConfig({ ...config, maxTokens: parseInt(e.target.value) })}
            min="1000"
            max="4096"
            className="w-full p-2 border rounded-lg focus:ring-2 focus:ring-blue-500"
          />
        </div>

        {/* Custom Prompt */}
        <div className="mb-6">
          <label className="block text-sm font-medium text-gray-700 mb-2">
            Custom Instructions (Optional)
          </label>
          <textarea
            value={config.customPrompt}
            onChange={(e) => setConfig({ ...config, customPrompt: e.target.value })}
            className="w-full p-2 border rounded-lg focus:ring-2 focus:ring-blue-500 h-32"
            placeholder="Add any specific instructions or requirements for the report..."
          />
        </div>

        {/* Generate Button */}
        <button
          onClick={generateReport}
          disabled={isLoading}
          className={`w-full py-2 px-4 rounded-lg text-white font-medium ${
            isLoading 
              ? 'bg-gray-400 cursor-not-allowed' 
              : 'bg-blue-600 hover:bg-blue-700'
          }`}
        >
          {isLoading ? 'Generating...' : 'Generate Report'}
        </button>

        {error && (
          <div className="mt-4 p-4 bg-red-50 border border-red-200 rounded-lg text-red-600">
            {error}
          </div>
        )}
        
        <div id="reportViewer">
          {reportContent && (
            <div className="mt-6">
              <ReportViewer 
                content={reportContent}
                onDownload={() => {
                  // Handle PDF download here
                  console.log('Download PDF');
                }}
              />
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default SuitabilityReportGenerator;
</file>

<file path="src/components/Auth/SignIn.tsx">
// src/components/Auth/SignIn.tsx
import React, { useState } from 'react';
import { supabase } from '../../services/supabaseClient';
import { Link, useNavigate } from 'react-router-dom';
// import { useAuthRedirect } from '../../hooks/useAuthRedirect';

const SignIn: React.FC = () => {
  const navigate = useNavigate();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  // const [showResendButton, setShowResendButton] = useState(false);

  const handleSignIn = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError(null);
    // setShowResendButton(false);

    try {
      // First try to get the user's profile
      const { data: profile, error: profileError } = await supabase
        .from('profiles')
        .select('role')
        .eq('email', email)
        .single()
        .throwOnError();

      if (profileError && !profileError.message.includes('no rows')) {
        console.error('Profile check error:', profileError);
      }

      // Attempt sign in
      const { data, error: signInError } = await supabase.auth.signInWithPassword({
        email,
        password,
      });

      if (signInError) {

        console.error('Sign in error:', signInError);
/*
        if (signInError.message.includes('Email not confirmed')) {
          setShowResendButton(true);
          throw new Error('Please confirm your email address. Check your inbox for a confirmation link.');
        }
*/
        if (signInError.message.includes('Invalid login credentials')) {
          throw new Error('Invalid email or password');
        }
        if (signInError.message.includes('Database error')) {
          throw new Error('Service temporarily unavailable. Please try again in a few moments.');
        }
        throw signInError;
      }

      if (!data.user) {
        throw new Error('Sign in successful but no user data returned');
      }

      // Get role from either profile or user metadata
      const userRole = profile?.role || data.user.user_metadata?.role;

      if (userRole === 'adviser') {
        navigate('/adviser/adviser-dashboard');
      } else {
        navigate('/client/client-dashboard');
      }

    } catch (error: any) {
      console.error('Sign in error:', error);
      setError(error.message);
    } finally {
      setLoading(false);
    }
  };

  /*
  const handleResendConfirmation = async () => {
    setLoading(true);
    try {
      const { error: resendError } = await supabase.auth.resend({
        type: 'signup',
        email,
      });

      if (resendError) throw resendError;

      setError('Confirmation email resent. Please check your inbox.');
      setShowResendButton(false);
    } catch (error: any) {
      console.error('Resend error:', error);
      setError('Failed to resend confirmation email. Please try again.');
    } finally {
      setLoading(false);
    }
  };

*/

return (
  <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
    <div className="max-w-md w-full space-y-8 bg-white p-8 rounded-lg shadow-sm">
      <div>
        <h2 className="text-center text-3xl font-semibold text-gray-900">
          Sign In
        </h2>
      </div>

      {error && (
        <div className="bg-red-50 border border-red-100 text-red-600 p-3 rounded-md">
          {error}
        </div>
      )}

      <form className="mt-8 space-y-6" onSubmit={handleSignIn}>
        <div className="space-y-4">
          <div>
            <label htmlFor="email" className="block text-sm font-medium text-gray-700">
              Email
            </label>
            <input
              id="email"
              type="email"
              required
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              placeholder="Enter your email"
            />
          </div>

          <div>
            <label htmlFor="password" className="block text-sm font-medium text-gray-700">
              Password
            </label>
            <input
              id="password"
              type="password"
              required
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              placeholder="Enter your password"
            />
          </div>
        </div>

        <div>
          <button
            type="submit"
            disabled={loading}
            className={`w-full flex justify-center py-2 px-4 border border-transparent rounded-lg shadow-sm text-sm font-medium text-white 
              ${loading 
                ? 'bg-gray-400 cursor-not-allowed' 
                : 'bg-blue-600 hover:bg-blue-700'
              }`}
          >
            {loading ? 'Signing in...' : 'Sign In'}
          </button>
        </div>
      </form>

      <div className="mt-6 text-center">
        <p className="text-sm text-gray-600">
          Don't have an account?{' '}
          <Link to="/signup" className="font-medium text-blue-600 hover:text-blue-500">
            Sign up here
          </Link>
        </p>
      </div>
    </div>
  </div>
);

}

export default SignIn;
</file>

<file path="src/components/Auth/SignUp.tsx">
// src/components/Auth/SignUp.tsx
import React, { useState } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import { supabase } from '../../services/supabaseClient';
// import { sign } from 'crypto';

const SignUp: React.FC = () => {
  const navigate = useNavigate();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [role, setRole] = useState<'adviser' | 'client'>('client');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSignUp = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError(null);

    try {
      // First check if user exists
      const { data: existingUser } = await supabase
        .from('profiles')
        .select('id')
        .eq('email', email)
        .single();

      if (existingUser) {
        throw new Error('An account with this email already exists.');
      }

      // Create new user
      const { data, error: signUpError } = await supabase.auth.signUp({
        email,
        password,
        options: {
          data: { role },
          emailRedirectTo: `${window.location.origin}/auth/callback`
        }
      });

      if (signUpError) {
        if (signUpError.message.includes('already registered')) {
          throw new Error('This email is already registered. Please sign in instead.');
        }
        throw signUpError;
      }

      if (!data.user) {
        throw new Error('Sign up successful but no user data returned');
      }

      alert(
        `Sign-up successful! \n\n` +
        `Please note your credentials:\n` +
        `Email: ${email}\n` +
        `Password: ${password}\n\n` +
        `You can now sign in with these credentials.`
      );

      navigate('/');

    } catch (error: any) {
      console.error('Sign up error:', error);
      setError(error.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-md w-full space-y-8 bg-white p-8 rounded-lg shadow-sm">
        <div>
          <h2 className="text-center text-3xl font-semibold text-gray-900">
            Create Account
          </h2>
        </div>

        {error && (
          <div className="bg-red-50 border border-red-100 text-red-600 p-3 rounded-md">
            {error}
          </div>
        )}

        <form className="mt-8 space-y-6" onSubmit={handleSignUp}>
          <div className="space-y-4">
            <div>
              <label htmlFor="email" className="block text-sm font-medium text-gray-700">
                Email
              </label>
              <input
                id="email"
                type="email"
                required
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                placeholder="Enter your email"
              />
            </div>

            <div>
              <label htmlFor="password" className="block text-sm font-medium text-gray-700">
                Password
              </label>
              <input
                id="password"
                type="password"
                required
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                placeholder="Create a password"
              />
            </div>

            <div>
              <label htmlFor="role" className="block text-sm font-medium text-gray-700">
                Role
              </label>
              <select
                id="role"
                value={role}
                onChange={(e) => setRole(e.target.value as 'adviser' | 'client')}
                className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              >
                <option value="client">Client</option>
                <option value="adviser">Adviser</option>
              </select>
            </div>
          </div>

          <div>
            <button
              type="submit"
              disabled={loading}
              className={`w-full flex justify-center py-2 px-4 border border-transparent rounded-lg shadow-sm text-sm font-medium text-white 
                ${loading 
                  ? 'bg-gray-400 cursor-not-allowed' 
                  : 'bg-blue-600 hover:bg-blue-700'
                }`}
            >
              {loading ? 'Creating account...' : 'Sign Up'}
            </button>
          </div>
        </form>

        <div className="mt-6 text-center">
          <p className="text-sm text-gray-600">
            Already have an account?{' '}
            <Link to="/" className="font-medium text-blue-600 hover:text-blue-500">
              Sign in here
            </Link>
          </p>
        </div>
      </div>
    </div>
  );
};

export default SignUp;

/*
import React, { useState, useEffect } from 'react';
import { supabase } from '../../services/supabaseClient';
import { useNavigate } from 'react-router-dom';

interface Adviser {
  id: string;
  name: string;
  email: string;
}

const SignUp: React.FC = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [name, setName] = useState('');
  const [role, setRole] = useState<'adviser' | 'client'>('client');
  const [adviserId, setAdviserId] = useState<string>('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [advisers, setAdvisers] = useState<Adviser[]>([]);
  const navigate = useNavigate();

  // Fetch advisers when component mounts
  useEffect(() => {
    const fetchAdvisers = async () => {
      const { data, error } = await supabase
        .from('profiles')
        .select('id, name, email')
        .eq('role', 'adviser');

      if (error) {
        console.error('Error fetching advisers:', error);
        return;
      }

      setAdvisers(data || []);
    };

    fetchAdvisers();
  }, []);

  const handleSignUp = async () => {
    // Basic validation
    if (!email || !password || !name) {
      setError('Please fill in all fields');
      return;
    }
  
    if (role === 'client' && !adviserId) {
      setError('Please select an adviser');
      return;
    }
  
    setLoading(true);
    setError(null);
  
    try {
      // Sign up user
      const { data, error } = await supabase.auth.signUp({
        email,
        password,
        options: {
          data: { role },
        },
      });
  
      if (error) throw error;
  
      // Verify we have a user ID
      if (!data.user?.id) {
        throw new Error('No user ID received from signup');
      }
  
      // Create profile with proper null handling for adviser_id
      const profileData = {
        id: data.user.id,
        email: data.user.email,
        name,
        role,
        adviser_id: role === 'client' ? adviserId : null,
        created_at: new Date().toISOString(),
      };
  
      console.log('Creating profile with data:', profileData); // For debugging
  
      const { error: profileError } = await supabase
        .from('profiles')
        .insert([profileData]);
  
      if (profileError) {
        console.error('Error creating profile:', profileError);
        await supabase.auth.signOut();
        throw new Error('Failed to create user profile');
      }

      if (role === 'adviser') {
        navigate('/adviser/adviser-dashboard');
      } else {
        navigate('/client/client-dashboard');
      }
  
      console.log('Sign-up and profile creation successful:', data);
      alert('Sign-up successful! Please check your email to confirm your account.');
    } catch (error: any) {
      console.error('Error in signup process:', error);
      setError(error.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div>
      <h2>Sign Up</h2>
      {error && <div style={{ color: 'red', marginBottom: '10px' }}>{error}</div>}
      <label>
        Name:
        <input
          type="text"
          placeholder="Full Name"
          value={name}
          onChange={(e) => setName(e.target.value)}
          required
        />
      </label>
      <br />
      <label>
        Email:
        <input
          type="email"
          placeholder="Email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          required
        />
      </label>
      <br />
      <label>
        Password:
        <input
          type="password"
          placeholder="Password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          required
        />
      </label>
      <br />
      <label>
        Role:
        <select 
          value={role} 
          onChange={(e) => {
            setRole(e.target.value as 'adviser' | 'client');
            if (e.target.value === 'adviser') {
              setAdviserId(''); // Clear adviser selection if switching to adviser
            }
          }}
          required
        >
          <option value="client">Client</option>
          <option value="adviser">Adviser</option>
        </select>
      </label>
      <br />
      {role === 'client' && (
        <label>
          Select Adviser:
          <select
            value={adviserId}
            onChange={(e) => setAdviserId(e.target.value)}
            required
          >
            <option value="">Choose an adviser</option>
            {advisers.map((adviser) => (
              <option key={adviser.id} value={adviser.id}>
                {adviser.name} ({adviser.email})
              </option>
            ))}
          </select>
        </label>
      )}
      <br />
      <button 
        onClick={handleSignUp} 
        disabled={loading}
        style={{ opacity: loading ? 0.7 : 1 }}
      >
        {loading ? 'Signing up...' : 'Sign Up'}
      </button>
    </div>
  );
};

export default SignUp;

*/
</file>

<file path="src/components/Chat/AdviserChat.tsx">
import React, { useState, useEffect, useContext } from 'react';
import { AuthContext } from '../../context/AuthContext';
import { supabase } from '../../services/supabaseClient';

interface ChatMessage {
  role: 'user' | 'assistant';
  content: string;
  timestamp: string;
}

interface ChatResponse {
    response: string;
    error?: string;
  }

interface ClientData {
  id: string;
  name: string;
  email: string;
  financialData: {
    incomes: any[];
    expenditures: any[];
    assets: any[];
    liabilities: any[];
    goals: any[];
    kyc_data?: any;
  };
}

const AdviserChat = ({ clientId }: { clientId: string }) => {
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [newMessage, setNewMessage] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [clientData, setClientData] = useState<ClientData | null>(null);
  const [error, setError] = useState<string | null>(null)
  const { user } = useContext(AuthContext);

  useEffect(() => {
    const fetchClientData = async () => {
      if (!clientId) return;

      setIsLoading(true);
      try {
        // Fetch client profile
        const { data: profile, error: profileError } = await supabase
          .from('profiles')
          .select('*')
          .eq('id', clientId)
          .single();

        if (profileError) throw profileError;

        // Fetch all financial data in parallel
        const [
          { data: incomes },
          { data: expenditures },
          { data: assets },
          { data: liabilities },
          { data: goals },
          { data: kyc }
        ] = await Promise.all([
          supabase.from('incomes').select('*').eq('client_id', clientId),
          supabase.from('expenditures').select('*').eq('client_id', clientId),
          supabase.from('assets').select('*').eq('client_id', clientId),
          supabase.from('liabilities').select('*').eq('client_id', clientId),
          supabase.from('goals').select('*').eq('client_id', clientId),
          supabase.from('kyc_data').select('*').eq('profile_id', clientId)
        ]);

        setClientData({
          ...profile,
          financialData: {
            incomes: incomes || [],
            expenditures: expenditures || [],
            assets: assets || [],
            liabilities: liabilities || [],
            goals: goals || [],
            kyc_data: kyc?.[0] || null
          }
        });
      } catch (error) {
        console.error('Error fetching client data:', error);
      } finally {
        setIsLoading(false);
      }
    };

    fetchClientData();
  }, [clientId]);

  const sendMessage = async () => {
    if (!newMessage.trim() || !clientData) return;

    const message = {
      role: 'user' as const,
      content: newMessage,
      timestamp: new Date().toISOString()
    };

    setMessages(prev => [...prev, message]);
    setNewMessage('');
    setIsLoading(true);

    try {
      const payload = {
        message: newMessage,
        clientData: clientData.financialData,
        messageHistory: messages.slice(-5),
        userId: user?.id,
        clientId
      };

    try {
      const response = await fetch('/.netlify/functions/adviser-chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
        body: JSON.stringify(payload)
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      // Get raw text first to see what we're receiving
      const text = await response.text();

      // Try to parse if it looks like JSON
      let data: ChatResponse;
      try {
      data = JSON.parse(text);
      } catch (e) {
      throw new Error(`Invalid JSON response: ${text.slice(0, 100)}...`);
      }

      if (data.error) {
        throw new Error(data.error);
      }

      setMessages(prev => [...prev, {
        role: 'assistant',
        content: data.response,
        timestamp: new Date().toISOString()
      }]);

    } catch (error) {
      console.error('Error sending message:', error);
    } finally {
      setIsLoading(false);
    }

    } catch (error) {
        console.error('Error sending message:', error);
        setError((error as Error).message);
    }

  };

  if (isLoading && !clientData) {
    return <div className="flex justify-center items-center h-64">Loading client data...</div>;
  }

  if (messages.length !== 0) {
    return (
      <div className="flex flex-col h-full max-w-4xl mx-auto p-4">
        
        <div className="flex-1 overflow-y-auto mb-4 space-y-4 min-h-[400px] p-4 border rounded-lg">
          {messages.map((msg, idx) => (
            <div
              key={idx}
              className={`p-4 rounded-lg max-w-[80%] ${
                msg.role === 'user'
                  ? 'ml-auto bg-blue-600 text-white'
                  : 'bg-gray-100'
              }`}
            >
              <div className="text-sm opacity-75 mb-1">
                {msg.role === 'user' ? 'You' : 'Assistant'}
              </div>
              <div className="whitespace-pre-wrap">{msg.content}</div>
              <div className="text-xs opacity-50 mt-2">
                {new Date(msg.timestamp).toLocaleTimeString()}
              </div>
            </div>
          ))}
          {isLoading && (
            <div className="bg-gray-100 p-4 rounded-lg">
              <div className="animate-pulse">Processing...</div>
            </div>
          )}
        </div>
  
        <div className="flex gap-2">
          <textarea
            value={newMessage}
            onChange={(e) => setNewMessage(e.target.value)}
            onKeyPress={(e) => {
              if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
              }
            }}
            placeholder={"Ask about your client's financial situation..."}
            className="flex-1 p-3 border rounded-lg resize-none h-20"
          />
          <button
            onClick={sendMessage}
            disabled={isLoading || !newMessage.trim()}
            className="px-6 py-2 bg-blue-600 text-white rounded-lg disabled:opacity-50 h-20"
          >
            {isLoading ? 'Sending...' : 'Send'}
          </button>
        </div>
      </div>
    );
  } else {
    return (
      <div className="flex flex-col h-screen max-w-4xl mx-auto p-4">
        <div className="flex gap-2">
          <textarea
            value={newMessage}
            onChange={(e) => setNewMessage(e.target.value)}
            onKeyPress={(e) => {
              if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
              }
            }}
            placeholder={"Ask about your client's financial situation..."}
            className="flex-1 p-3 border rounded-lg resize-none h-20"
          />
          <button
            onClick={sendMessage}
            disabled={isLoading || !newMessage.trim()}
            className="px-6 py-2 bg-blue-600 text-white rounded-lg disabled:opacity-50 h-20"
          >
            {isLoading ? 'Sending...' : 'Send'}
          </button>
        </div>
      </div>
    );
  };
};

export default AdviserChat;

  /*
  const sendMessage = async () => {
    if (!newMessage.trim() || !clientData) return;

    const message = {
      role: 'user' as const,
      content: newMessage,
      timestamp: new Date().toISOString()
    };

    setMessages(prev => [...prev, message]);
    setNewMessage('');
    setIsLoading(true);

    try {
      const payload = {
        message: newMessage,
        clientData: clientData.financialData,
        messageHistory: messages.slice(-5),
        userId: user?.id,
        clientId
      };

        console.log('Sending to:', '/.netlify/functions/adviser-chat');
        console.log('Payload:', payload);

    try {
      const response = await fetch('/.netlify/functions/adviser-chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
        body: JSON.stringify(payload)
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      console.log('Response status:', response.status);

      // Get raw text first to see what we're receiving
      const text = await response.text();
      console.log('Raw response:', text);

      // Try to parse if it looks like JSON
      let data: ChatResponse;
      try {
      data = JSON.parse(text);
      } catch (e) {
      throw new Error(`Invalid JSON response: ${text.slice(0, 100)}...`);
      }

      if (data.error) {
        throw new Error(data.error);
      }

      setMessages(prev => [...prev, {
        role: 'assistant',
        content: data.response,
        timestamp: new Date().toISOString()
      }]);

    } catch (error) {
      console.error('Error sending message:', error);
    } finally {
      setIsLoading(false);
      setIsSuitabilityReport(false);
    }

    } catch (error) {
        console.error('Error sending message:', error);
        setError((error as Error).message);
    }

  };

  if (isLoading && !clientData) {
    return <div className="flex justify-center items-center h-64">Loading client data...</div>;
  }

  if (messages.length !== 0) {
    return (
      <div className="flex flex-col h-full max-w-4xl mx-auto p-4">
        
        <div className="flex-1 overflow-y-auto mb-4 space-y-4 min-h-[400px] p-4 border rounded-lg">
          {messages.map((msg, idx) => (
            <div
              key={idx}
              className={`p-4 rounded-lg max-w-[80%] ${
                msg.role === 'user'
                  ? 'ml-auto bg-blue-600 text-white'
                  : 'bg-gray-100'
              }`}
            >
              <div className="text-sm opacity-75 mb-1">
                {msg.role === 'user' ? 'You' : 'Assistant'}
              </div>
              <div className="whitespace-pre-wrap">{msg.content}</div>
              <div className="text-xs opacity-50 mt-2">
                {new Date(msg.timestamp).toLocaleTimeString()}
              </div>
            </div>
          ))}
          {isLoading && (
            <div className="bg-gray-100 p-4 rounded-lg">
              <div className="animate-pulse">Processing...</div>
            </div>
          )}
        </div>
  
        <div className="flex gap-2">
          <textarea
            value={newMessage}
            onChange={(e) => setNewMessage(e.target.value)}
            onKeyPress={(e) => {
              if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
              }
            }}
            placeholder={"Ask about your client's financial situation..."}
            className="flex-1 p-3 border rounded-lg resize-none h-20"
          />
          <button
            onClick={sendMessage}
            disabled={isLoading || !newMessage.trim()}
            className="px-6 py-2 bg-blue-600 text-white rounded-lg disabled:opacity-50 h-20"
          >
            {isLoading ? 'Sending...' : 'Send'}
          </button>
        </div>
      </div>
    );
  } else {
    return (
      <div className="flex flex-col h-screen max-w-4xl mx-auto p-4">
        <div className="flex gap-2">
          <textarea
            value={newMessage}
            onChange={(e) => setNewMessage(e.target.value)}
            onKeyPress={(e) => {
              if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
              }
            }}
            placeholder={"Ask about your client's financial situation..."}
            className="flex-1 p-3 border rounded-lg resize-none h-20"
          />
          <button
            onClick={sendMessage}
            disabled={isLoading || !newMessage.trim()}
            className="px-6 py-2 bg-blue-600 text-white rounded-lg disabled:opacity-50 h-20"
          >
            {isLoading ? 'Sending...' : 'Send'}
          </button>
        </div>
      </div>
    );
  };
};

export default AdviserChat;

*/
</file>

<file path="src/components/Chat/AdviserReports.tsx">
// AdviserChat.tsx

import React, { useState, useEffect, useContext } from 'react';
import { AuthContext } from '../../context/AuthContext';
import { supabase } from '../../services/supabaseClient';

interface ChatMessage {
  role: 'user' | 'assistant';
  content: string;
  timestamp: string;
}

interface ClientData {
  id: string;
  name: string;
  email: string;
  financialData: {
    incomes: any[];
    expenditures: any[];
    assets: any[];
    liabilities: any[];
    goals: any[];
    kyc_data?: any;
  };
}

const AdviserChat = ({ clientId }: { clientId: string }) => {
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [newMessage, setNewMessage] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [clientData, setClientData] = useState<ClientData | null>(null);
  const [isSuitabilityReport, setIsSuitabilityReport] = useState(false);
  const { user } = useContext(AuthContext);

  useEffect(() => {
    const fetchClientData = async () => {
      if (!clientId) return;

      setIsLoading(true);
      try {
        // Fetch client profile
        const { data: profile, error: profileError } = await supabase
          .from('profiles')
          .select('*')
          .eq('id', clientId)
          .single();

        if (profileError) throw profileError;

        // Fetch all financial data in parallel
        const [
          { data: incomes },
          { data: expenditures },
          { data: assets },
          { data: liabilities },
          { data: goals },
          { data: kyc }
        ] = await Promise.all([
          supabase.from('incomes').select('*').eq('client_id', clientId),
          supabase.from('expenditures').select('*').eq('client_id', clientId),
          supabase.from('assets').select('*').eq('client_id', clientId),
          supabase.from('liabilities').select('*').eq('client_id', clientId),
          supabase.from('goals').select('*').eq('client_id', clientId),
          supabase.from('kyc_data').select('*').eq('profile_id', clientId)
        ]);

        setClientData({
          ...profile,
          financialData: {
            incomes: incomes || [],
            expenditures: expenditures || [],
            assets: assets || [],
            liabilities: liabilities || [],
            goals: goals || [],
            kyc_data: kyc?.[0] || null
          }
        });
      } catch (error) {
        console.error('Error fetching client data:', error);
      } finally {
        setIsLoading(false);
      }
    };

    fetchClientData();
  }, [clientId]);

  const sendMessage = async () => {
    if (!newMessage.trim() || !clientData) return;

    const message = {
      role: 'user' as const,
      content: newMessage,
      timestamp: new Date().toISOString()
    };

    setMessages(prev => [...prev, message]);
    setNewMessage('');
    setIsLoading(true);

    try {
      const payload = {
        message: newMessage,
        clientData: clientData.financialData,
        messageHistory: messages.slice(-5),
        isSuitabilityReport,
        userId: user?.id,
        clientId
      };

      const response = await fetch('/.netlify/functions/adviser-chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      const data = await response.json();

      if (data.error) throw new Error(data.error);

      setMessages(prev => [...prev, {
        role: 'assistant',
        content: data.response,
        timestamp: new Date().toISOString()
      }]);

      // If this was a suitability report request, save it to the database
      if (isSuitabilityReport) {
        await supabase.from('suitability_reports').insert({
          client_id: clientId,
          adviser_id: user?.id,
          content: data.response,
          created_at: new Date().toISOString()
        });
      }
    } catch (error) {
      console.error('Error sending message:', error);
    } finally {
      setIsLoading(false);
      setIsSuitabilityReport(false);
    }
  };

  if (isLoading && !clientData) {
    return <div className="flex justify-center items-center h-64">Loading client data...</div>;
  }

  return (
    <div className="flex flex-col h-full max-w-4xl mx-auto p-4">
      <div className="mb-4">
        <h2 className="text-xl font-semibold">
          Chat - {clientData?.name}
        </h2>
        <div className="flex gap-2 mt-2">
          <button
            onClick={() => setIsSuitabilityReport(true)}
            className="px-4 py-2 text-sm bg-blue-600 text-white rounded hover:bg-blue-700"
          >
            Generate Suitability Report
          </button>
        </div>
      </div>

      <div className="flex-1 overflow-y-auto mb-4 space-y-4 min-h-[400px] p-4 border rounded-lg">
        {messages.map((msg, idx) => (
          <div
            key={idx}
            className={`p-4 rounded-lg max-w-[80%] ${
              msg.role === 'user'
                ? 'ml-auto bg-blue-600 text-white'
                : 'bg-gray-100'
            }`}
          >
            <div className="text-sm opacity-75 mb-1">
              {msg.role === 'user' ? 'You' : 'Assistant'}
            </div>
            <div className="whitespace-pre-wrap">{msg.content}</div>
            <div className="text-xs opacity-50 mt-2">
              {new Date(msg.timestamp).toLocaleTimeString()}
            </div>
          </div>
        ))}
        {isLoading && (
          <div className="bg-gray-100 p-4 rounded-lg">
            <div className="animate-pulse">Processing...</div>
          </div>
        )}
      </div>

      <div className="flex gap-2">
        <textarea
          value={newMessage}
          onChange={(e) => setNewMessage(e.target.value)}
          onKeyPress={(e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
              e.preventDefault();
              sendMessage();
            }
          }}
          placeholder={
            isSuitabilityReport
              ? "Describe the advice you'd like to document in the suitability report..."
              : "Ask about your client's financial situation..."
          }
          className="flex-1 p-3 border rounded-lg resize-none h-20"
        />
        <button
          onClick={sendMessage}
          disabled={isLoading || !newMessage.trim()}
          className="px-6 py-2 bg-blue-600 text-white rounded-lg disabled:opacity-50 h-20"
        >
          {isLoading ? 'Sending...' : 'Send'}
        </button>
      </div>
    </div>
  );
};

export default AdviserChat;
</file>

<file path="src/components/Chat/Bot.tsx">
import openai from '../../config/openai'; // Import OpenAI client
import fetchUserData from './Fetch'; // Fetch user data from Supabase
import { calculateAge, calculateYearsToRetirement, analyzeGoals, suggestDebtRepayment } from './Calculate';

async function generateBotResponse(userId: string, query: string, agentType: string): Promise<string> {
  const { profile, finances } = await fetchUserData(userId);

  // Prepare contextual data
  const age = calculateAge(profile.dob);
  const yearsToRetirement = calculateYearsToRetirement(age, profile.retirement_age);
  const goalsFeedback = analyzeGoals(finances.goals);
  const debtFeedback = suggestDebtRepayment(finances.income, finances.expenses, finances.liabilities);

  // Construct the OpenAI prompt
  const prompt = `
  You are a financial assistant chatbot designed to provide tailored advice for financial planning. 
    Your primary responsibilities include:
    1. Calculating retirement age and guiding users toward retirement goals.
    2. Providing actionable steps to achieve savings and investment goals.
    3. Recommending strategies to pay off debts.
    4. Offering general financial insights in a friendly and professional tone.

    Always ensure your advice is concise, actionable, and specific to the user's financial data.

    Here's the user's data:
    - Age: ${age}
    - Years to Retirement: ${yearsToRetirement}
    - Savings: ${finances.savings}
    - Income: ${finances.income}
    - Expenses: ${finances.expenses}
    - Liabilities: ${finances.liabilities}
    - Goals:
    ${goalsFeedback.map((goal, index) => `${index + 1}. ${goal}`).join('\n')}

    User's query: "${query}"

    Provide a helpful and concise response in a friendly tone.
  `;

  // Use OpenAI's API
  const response = await openai.chat.completions.create({
    model: 'gpt-4',
    messages: [
      { role: 'system', content: 'You are a helpful assistant guiding people on their financial journeys. You seek to provide tailored advice and insights to help users achieve their financial goals. Your responses should be concise, actionable, and specific to the user\'s financial data. Always ensure your advice is helpful and relevant to the user\'s needs.' },
      { role: 'user', content: 'Hello!' },
    ],
  });

  return response.choices[0].message?.content || 'I’m sorry, I couldn’t process your request.';
}

export default generateBotResponse;
</file>

<file path="src/components/Chat/Calculate.tsx">
export function calculateAge(dob: string): number {
    const birthDate = new Date(dob);
    const today = new Date();
    let age = today.getFullYear() - birthDate.getFullYear();
    const monthDiff = today.getMonth() - birthDate.getMonth();
  
    if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {
      age--;
    }
  
    return age;
  }
  
  export function calculateYearsToRetirement(age: number, retirementAge: number): number {
    return Math.max(0, retirementAge - age);
  }
  
  export function analyzeGoals(goals: { name: string; target: number; saved: number }[]): string[] {
    return goals.map((goal) => {
      const remaining = goal.target - goal.saved;
      const status = remaining > 0
        ? `You need to save $${remaining.toFixed(2)} more to reach your goal: ${goal.name}.`
        : `Congratulations! You have reached your goal: ${goal.name}.`;
      return status;
    });
  }
  
  export function suggestDebtRepayment(income: number, expenses: number, liabilities: number): string {
    const disposableIncome = income - expenses;
  
    if (disposableIncome <= 0) {
      return "Your expenses exceed your income. Consider cutting unnecessary expenses to pay off debts.";
    }
  
    const monthsToRepay = Math.ceil(liabilities / disposableIncome);
  
    return `With your current disposable income of $${disposableIncome.toFixed(2)}, you can pay off your debts in approximately ${monthsToRepay} months.`;
  }
</file>

<file path="src/components/Chat/Chat.tsx">
// src/components/Chat/Chat.tsx

import React, { useState, useEffect } from 'react';
import { useContext } from 'react';
import { AuthContext } from '../../context/AuthContext';
import { useFinancialData } from '../../hooks/useFinancialData';
// import { Income, Expenditure, Asset, Liability, Goal } from '../../../netlify/functions/types/financial';
import { supabase } from '../../services/supabaseClient';

interface ChatMessage {
  role: 'user' | 'assistant';
  content: string;
}

export default function Chat() {
  const [message, setMessage] = useState('');
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const { user } = useContext(AuthContext);
  const { data: financialData, loading: dataLoading } = useFinancialData();
  const [dataReady, setDataReady] = useState(false);


  useEffect(() => {
    if (!financialData) {
      setDataReady(false);
      return;
    }
  
    // Validate required data is present
    const isValid = Boolean(
      financialData.income !== undefined &&
      Array.isArray(financialData.expenditure) &&
      financialData.assets !== undefined &&
      financialData.liabilities !== undefined &&
      Array.isArray(financialData.goals)
    );

    console.log(financialData)
  
    setDataReady(isValid);
  }, [financialData]);

  const sendMessage = async (text: string) => {
    if (!text.trim() || !user?.id) {
      setError('Please enter a message and ensure you are logged in');
      return;
    }
  
    if (dataLoading) {
      setError('Still loading your financial data. Please wait...');
      return;
    }
  
    if (!dataReady) {
      setError('Your financial data is not completely loaded. Please try again in a moment.');
      return;
    }
  
    if (!financialData) {
      setError('Unable to access your financial information. Please refresh the page.');
      return;
    }
  
    setIsLoading(true);
    setError(null);
  
    try {
      // Fetch KYC data
      const { data: kycData, error: kycError } = await supabase
        .from('kyc_data')
        .select('*')
        .eq('profile_id', user.id)
        .single();
  
      if (kycError && !kycError.message.includes('no rows')) {
        console.error('Error fetching KYC data:', kycError);
      }

    // Validate specific data points before formatting
    if (
      typeof financialData.income !== 'number' ||
      !Array.isArray(financialData.expenditure) ||
      typeof financialData.assets !== 'number' ||
      typeof financialData.liabilities !== 'number'
    ) {
      throw new Error('Some required financial information is missing. Please complete your profile.');
    }
    
    // Transform financialContext into the expected financialData structure
    const formattedFinancialData = {
      kyc_data: kycData || null,
      incomes: [{ 
        client_id: user.id,
        type: 'Total Income', 
        amount: Number(financialData.income),
        frequency: 'Annual' 
      }],
      expenditures: financialData.expenditure.map((exp, index) => ({
        client_id: user.id,
        category: exp.category,
        amount: Number(exp.amount),
        frequency: 'Monthly'
      })),
      assets: [{
        client_id: user.id,
        type: 'Total Assets',
        value: Number(financialData.assets),
        description: 'Combined assets'
      }],
      liabilities: [{
        client_id: user.id,
        type: 'Total Liabilities',
        amount: Number(financialData.liabilities),
        interest_rate: 0
      }],
      goals: (financialData.goals || []).map(goal => ({
        id: goal.id,
        client_id: user.id,
        goal: goal.goal,
        target_amount: Number(goal.target_amount),
        time_horizon: Number(goal.time_horizon)
      })) || []
    };
    
    // Log the request payload
  const payload = {
    message: text,
    userId: user.id,
    financialData: formattedFinancialData,
    messageHistory: messages.map(msg => ({
      role: msg.role === 'user' ? 'user' : 'assistant',
      content: msg.content || ''
    }))
  };

    // console.log('Sending payload:', JSON.stringify(payload, null, 2));
    console.log('Raw financial data:', financialData);
    console.log('KYC data:', kycData);
    console.log('Formatted data being sent:', formattedFinancialData);
  
    const response = await fetch('/.netlify/functions/chatbot', {
      method: 'POST',
      headers: { 
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(payload)
    });

      // const rawResponse = await response.clone().text();
      
      console.log('Full request body:', JSON.stringify(message, null, 2));
      console.log('Raw server response:', await response.clone().text());

      const data = await response.json();
      console.log('Response from server:', data);
  
      if (data.error) {
        throw new Error(data.error);
      }
      
      const newUserMessage: ChatMessage = { role: 'user', content: text };
      const newAssistantMessage: ChatMessage = { 
        role: 'assistant', 
        content: data.response 
      };
      
      setMessages(prev => [...prev, newUserMessage, newAssistantMessage]);
    } catch (error) {
      console.error('Chat error:', error);
      setError(error instanceof Error ? error.message : 'Failed to send message');
    } finally {
      setIsLoading(false);
      setMessage('');
    }
  };


  return (
    <div className="max-w-2xl mx-auto p-4">

      {dataLoading && (
      <div className="mb-4 p-3 bg-blue-100 border border-blue-400 text-blue-700 rounded">
        Loading your financial data...
      </div>
    )}

    {!dataReady && !dataLoading && (
      <div className="mb-4 p-3 bg-yellow-100 border border-yellow-400 text-yellow-700 rounded">
        Financial data not fully loaded. Some features may be limited.
      </div>
    )}

      {error && (
        <div className="mb-4 p-3 bg-red-100 border border-red-400 text-red-700 rounded">
          {error}
        </div>
      )}
      
      <div className="space-y-4 mb-4 h-[60vh] overflow-y-auto border border-gray-200 rounded-lg p-4 bg-gray-50">
        {messages.length === 0 && (
          <div className="text-center text-gray-500 py-8">
            Ask me anything about financial planning, investments, or budgeting!
          </div>
        )}
        {messages.map((msg, i) => (
          <div 
            key={i} 
            className={`p-4 rounded-lg max-w-[85%] ${
              msg.role === 'user' 
                ? 'bg-blue-500 text-white ml-auto' 
                : 'bg-white text-gray-800 border border-gray-200'
            }`}
          >
            <div className="text-sm opacity-75 mb-1">
              {msg.role === 'user' ? 'You' : 'Financial Advisor'}
            </div>
            <div className="whitespace-pre-wrap">
              {msg.content}
            </div>
          </div>
        ))}
        {isLoading && (
          <div className="bg-gray-100 text-gray-600 p-4 rounded-lg max-w-[85%]">
            Thinking...
          </div>
        )}
      </div>
      
      <div className="flex gap-2">
        <input
          value={message}
          onChange={(e) => setMessage(e.target.value)}
          placeholder="Ask about financial planning, investments, or budgeting..."
          className="flex-1 p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
          onKeyPress={(e) => e.key === 'Enter' && !e.shiftKey && sendMessage(message)}
        />
        <button
          onClick={() => sendMessage(message)}
          disabled={isLoading}
          className="px-6 py-3 bg-blue-500 text-white rounded-lg disabled:opacity-50 hover:bg-blue-600 transition-colors"
        >
          {isLoading ? 'Sending...' : 'Send'}
        </button>
      </div>
    </div>
  );
}


/*
import React, { useState } from 'react';
import { useContext } from 'react';
import { AuthContext } from '../../context/AuthContext';

export default function Chat() {
  const [message, setMessage] = useState('');
  const [messages, setMessages] = useState<Array<{role: string, content: string}>>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const { user } = useContext(AuthContext);

  const sendMessage = async (text: string) => {
    if (!text.trim() || !user) {
      setError('Please enter a message and ensure you are logged in');
      return;
    }
    
    setIsLoading(true);
    setError(null);
    
    try {
      const response = await fetch('/api/chatbot', {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({ userId: user.id, message: text })
      });

      const contentType = response.headers.get('content-type');
      if (!contentType || !contentType.includes('application/json')) {
        throw new Error('Server returned non-JSON response');
      }
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || `Server error: ${response.status}`);
      }
      
      const data = await response.json();
      if (!data.response) {
        throw new Error('Invalid response format from server');
      }

      setMessages(prev => [...prev, 
        { role: 'user', content: text },
        { role: 'assistant', content: data.response }
      ]);
    } catch (error) {
      console.error('Chat error:', error);
      setError(error instanceof Error ? error.message : 'Failed to send message');
      setMessages(prev => [...prev, 
        { role: 'user', content: text },
        { role: 'assistant', content: 'Sorry, I encountered an error. Please try again.' }
      ]);
    } finally {
      setIsLoading(false);
      setMessage('');
    }
  };

  return (
    <div className="max-w-2xl mx-auto p-4">
      <div className="mb-4 text-sm text-gray-600">
        {user ? `Logged in as: ${user.email}` : 'Please log in to use the chat'}
      </div>

      {error && (
        <div className="mb-4 p-3 bg-red-100 border border-red-400 text-red-700 rounded">
          {error}
        </div>
      )}
      
      <div className="space-y-4 mb-4 h-[60vh] overflow-y-auto">
        {messages.map((msg, i) => (
          <div key={i} className={`p-3 rounded-lg max-w-[80%] ${
            msg.role === 'user' 
              ? 'bg-blue-500 text-white ml-auto' 
              : 'bg-gray-200 text-gray-900'
          }`}>
            {msg.content}
          </div>
        ))}
      </div>
      
      <div className="flex gap-2">
        <input
          value={message}
          onChange={(e) => setMessage(e.target.value)}
          placeholder="Ask a question..."
          className="flex-1 p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
          onKeyPress={(e) => e.key === 'Enter' && !e.shiftKey && sendMessage(message)}
          disabled={!user || isLoading}
        />
        <button
          onClick={() => sendMessage(message)}
          disabled={!user || isLoading}
          className="px-4 py-2 bg-blue-500 text-white rounded-lg disabled:opacity-50 hover:bg-blue-600 transition-colors"
        >
          {isLoading ? 'Sending...' : 'Send'}
        </button>
      </div>
    </div>
  );
}



// Chat.tsx
import React, { useState } from 'react';
import { useAuth } from '../../context/AuthContext';

export default function Chat() {
  const [message, setMessage] = useState('');
  const [messages, setMessages] = useState<Array<{role: string, content: string}>>([]);
  const [isLoading, setIsLoading] = useState(false);
  const { user } = useAuth();

  const sendMessage = async (text: string) => {
    if (!text.trim()) return;
    
    setIsLoading(true);
    try {
      const response = await fetch('/.netlify/functions/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ userId: user?.id, message: text })
      });

      if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
      
      const data = await response.json();
      setMessages(prev => [...prev, 
        { role: 'user', content: text },
        { role: 'assistant', content: data.response }
      ]);
    } catch (error) {
      console.error('Failed to send message:', error);
    } finally {
      setIsLoading(false);
      setMessage('');
    }
  };

  return (
    <div className="max-w-2xl mx-auto p-4">
      <div className="space-y-4 mb-4">
        {messages.map((msg, i) => (
          <div key={i} className={`p-3 rounded-lg ${
            msg.role === 'user' ? 'bg-blue-500 text-white ml-auto' : 'bg-gray-200'
          }`}>
            {msg.content}
          </div>
        ))}
      </div>
      
      <div className="flex gap-2">
        <input
          value={message}
          onChange={(e) => setMessage(e.target.value)}
          placeholder="Ask a question..."
          className="flex-1 p-2 bg-gray-700 text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
          onKeyPress={(e) => e.key === 'Enter' && sendMessage(message)}
        />
        <button
          onClick={() => sendMessage(message)}
          disabled={isLoading}
          className="px-4 py-2 bg-blue-500 text-white rounded-lg disabled:opacity-50"
        >
          {isLoading ? 'Sending...' : 'Send'}
        </button>
      </div>
    </div>
  );
}

*/
</file>

<file path="src/components/Chat/Fetch.tsx">
import { supabase } from '../../services/supabaseClient';

interface UserProfile {
  id: string;
  name: string;
  dob: string; // Date of birth
  retirement_age: number;
}

interface FinancialData {
  savings: number;
  income: number;
  expenses: number;
  liabilities: number;
  goals: { name: string; target: number; saved: number }[];
}

async function fetchUserData(userId: string): Promise<{ profile: UserProfile; finances: FinancialData }> {
  const { data: profile, error: profileError } = await supabase
    .from('profiles')
    .select('*')
    .eq('id', userId)
    .single();

  if (profileError) throw profileError;

  const { data: finances, error: financeError } = await supabase
    .from('financial_data')
    .select('*')
    .eq('user_id', userId)
    .single();

  if (financeError) throw financeError;

  return { profile, finances };
}

export default fetchUserData;
</file>

<file path="src/components/Client/Cards/FinancialItemsCard.tsx">
// src/components/Client/Cards/FinancialItemCard.tsx
import React from 'react';
import { useNavigate } from 'react-router-dom';

interface FinancialItemCardProps {
  id: string;
  title: string;
  amount: number;
  subtitle?: string;
  editUrl: string;
}

const FinancialItemCard: React.FC<FinancialItemCardProps> = ({ 
  title, 
  amount, 
  subtitle, 
  editUrl 
}) => {
  const navigate = useNavigate();

  return (
    <div 
      onClick={() => navigate(editUrl)}
      className="p-4 bg-white rounded-lg shadow hover:shadow-md transition-shadow cursor-pointer"
    >
      <div className="flex justify-between items-start">
        <div>
          <h3 className="font-medium text-gray-900">{title}</h3>
          {subtitle && <p className="text-sm text-gray-500">{subtitle}</p>}
        </div>
        <p className="text-lg font-semibold">{amount.toLocaleString('en-GB', {
          style: 'currency',
          currency: 'GBP'
        })}</p>
      </div>
    </div>
  );
};

export default FinancialItemCard;
</file>

<file path="src/components/Client/Cards/NetWorthCard.tsx">
import React from 'react';

interface NetWorthCardProps {
  assets: number;
  liabilities: number;
}

const NetWorthCard: React.FC<NetWorthCardProps> = ({ assets, liabilities }) => {
  const netWorth = assets - liabilities;

  const formatCurrency = (amount: number): string => {
    return new Intl.NumberFormat('en-GB', {
      style: 'currency',
      currency: 'GBP',
      minimumFractionDigits: 0,
      maximumFractionDigits: 0
    }).format(amount);
  };

  return (
    <div className="w-full bg-[#111111] rounded-2xl p-8 mb-8">
      <h2 className="!text-2xl !font-bold !text-white mb-12">Net Worth Summary</h2>
      
      <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
        <div className="space-y-2">
          <p className="!text-gray-400 !text-lg">Total Assets</p>
          <p className="!text-[#4ade80] !text-4xl !font-bold">{formatCurrency(assets)}</p>
        </div>
        
        <div className="space-y-2">
          <p className="!text-gray-400 !text-lg">Total Liabilities</p>
          <p className="!text-[#f87171] !text-4xl !font-bold">{formatCurrency(liabilities)}</p>
        </div>
        
        <div className="space-y-2">
          <p className="!text-gray-400 text-lg">Net Worth</p>
          <p className="!text-[#818cf8] !text-4xl !font-bold">{formatCurrency(netWorth)}</p>
        </div>
      </div>
    </div>
  );
};

export default NetWorthCard;
</file>

<file path="src/components/Client/Documents/DocumentsPage.tsx">
// src/components/Client/DocumentsPage.tsx
import React, { useState } from 'react';
import DocumentUpload from 'components/Common/Documents/DocumentUpload';
import DocumentList from 'components/Common/Documents/DocumentList';
import DocumentDetails from 'components/Common/Documents/DocumentDetails';
import { ClientDocument } from '../../../@types/documents';

const DocumentsPage: React.FC = () => {
  const [showUpload, setShowUpload] = useState(false);
  const [refreshKey, setRefreshKey] = useState(0);
  const [selectedDocument, setSelectedDocument] = useState<ClientDocument | null>(null);
  
  const handleUploadSuccess = () => {
    setShowUpload(false);
    setRefreshKey(prev => prev + 1);
  };

  const handleDocumentSelect = (document: ClientDocument) => {
    setSelectedDocument(document);
  };

  const handleApplyData = (id: string) => {
    // Insert logic to apply data to the client profile
    alert('Data applied to client profile');
  };
  
  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-2xl font-bold mb-6">Document Management</h1>
      
      <div className="mb-6 flex flex-wrap items-center justify-between gap-4">
        <div className="max-w-2xl">
          <p className="text-gray-600">
            Upload and manage important documents such as bank statements, investment reports, 
            utility bills, and identity documents. We can automatically extract relevant information to 
            update your profile.
          </p>
        </div>
        <button
          onClick={() => setShowUpload(!showUpload)}
          className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
        >
          {showUpload ? 'Cancel Upload' : 'Upload New Document'}
        </button>
      </div>
      
      {showUpload && (
        <div className="mb-8">
          <DocumentUpload onUploadSuccess={handleUploadSuccess} />
        </div>
      )}
      
      <div className="grid gap-6">
        <DocumentList 
          key={refreshKey}
          onSelectDocument={handleDocumentSelect}
        />
      </div>
      
      {selectedDocument && selectedDocument.processed && selectedDocument.extracted_data && (
        <DocumentDetails document={selectedDocument} onApplyData={handleApplyData} />
      )}
    </div>
  );
};

export default DocumentsPage;
</file>

<file path="src/components/Client/Risk/RiskAssessmentForm.tsx">
// src/components/Client/Risk/RiskAssessmentForm.tsx
import React, { useMemo, useContext, useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { supabase } from '../../../services/supabaseClient';
import FinancialForm from '../BaseForm';
import { riskProfileQuestions } from '../../../utils/riskAssessment';
import { calculateFinancialMetricsForRisk,  } from '../../../utils/riskAssessment/riskCalculations';
import type { FormField, RiskAssessmentEntry } from '../../../@types/financial';
import { AuthContext } from '../../../context/AuthContext';
import { financialCalculations } from '../../../utils/financialcalculationMetrics';
import { calculateRiskScores } from '../../../utils/riskAssessment/riskCalculations';
import { useFinancialData } from '../../../hooks/useFinancialData';

const RiskAssessmentForm: React.FC = () => {
  const navigate = useNavigate();
  const { user } = useContext(AuthContext);
  const { data: financialData } = useFinancialData();
  const [initialResponses, setInitialResponses] = useState<Record<string, any>>({});
  
  useEffect(() => {
    const fetchLatestRiskAssessment = async () => {
      if (!user) return;

      try {
        const { data, error } = await supabase
          .from('risk_assessments')
          .select('responses')
          .eq('client_id', user.id)
          .order('created_at', { ascending: false })
          .limit(1)
          .single();

        if (error && error.code !== 'PGRST116') {
          console.error('Error fetching latest risk assessment:', error);
        }

        if (data?.responses) {
          setInitialResponses(data.responses);
        }
      } catch (error) {
        console.error('Fetch latest risk assessment failed:', error);
      }
    };

    fetchLatestRiskAssessment();
  }, [user]);

  // Transform risk profile questions into form fields format
  const fields: FormField[] = riskProfileQuestions.map(question => ({
    name: question.id,
    type: 'select' as const,
    label: question.question,
    options: question.answers.map(answer => ({
      value: answer.score.toString(),
      label: answer.text
    }))
  }));


  const handleSubmit = async (entries: Record<string, any>) => {
    if (!user) {
      alert('No user found. Please log in again.');
      return;
    }

    try {
      
      // Fetch all necessary data for risk calculations
      const { 
        data: profileData, 
        error: profileError 
      } = await supabase
        .from('profiles')
        .select(`
          id,
          incomes(*),
          expenditures(*),
          assets(*),
          liabilities(*),
          goals(*)
        `)
        .eq('id', user.id)
        .single();
  
      console.log('Profile query result:', { 
        profileData, 
        profileError,
        profileId: profileData?.id,
        incomesCount: profileData?.incomes?.length,
        expendituresCount: profileData?.expenditures?.length
      });
  
      if (profileError) {
        console.error('Profile query error details:', profileError);
        throw new Error('Failed to retrieve user profile data: ' + profileError.message);
      }
  
      // Calculate metrics
      const metrics = calculateFinancialMetricsForRisk(
        profileData.incomes || [],
        profileData.expenditures || [],
        profileData.assets || [],
        profileData.liabilities || [],
        profileData.goals || []
      );
  
  
      // Calculate risk scores
      const calculatedScores = calculateRiskScores(entries, metrics);
  
     // Remove existing entries before inserting new one
     await supabase
      .from('risk_assessments')
      .delete()
      .eq('client_id', user.id);

  
      const { data, error } = await supabase
        .from('risk_assessments')
        .upsert({
          client_id: user.id,
          responses: entries,
          calculated_scores: calculatedScores
        })
        .select();

      if (error) throw error;

      navigate('/client/client-dashboard');
  
    } catch (error) {
      console.error('Failed to submit risk assessment:', error);
      if (error instanceof Error) {
        console.error('Error details:', error.message);
        console.error('Error stack:', error.stack);
      }
      alert('Failed to save risk assessment. Please try again.');
    }
  };

  return (
    <div className="max-w-2xl mx-auto p-6 bg-white rounded-lg shadow-lg">
      <h1 className="text-2xl font-semibold mb-6">Risk Assessment Questionnaire</h1>
      <FinancialForm
        formType="risk_assessments"
        nextRoute="/client/client-dashboard"
        stepNumber={6}
        fields={fields}
        defaultEntry={initialResponses}
        onSubmit={handleSubmit}
            />
          </div>
        );
      };

export default RiskAssessmentForm;

  /*

  const handleSubmit = async (entries: Record<string, any>) => {
    if (!user) {
      alert('No user found. Please log in again.');
      return;
    }
    try {
      console.log('Starting risk assessment submission for user:', user.id);
      console.log('Financial data available:', !!financialData);

      // Fetch all necessary data directly from the database
      const { 
        data: profileData, 
        error: profileError 
      } = await supabase
        .from('profiles')
        .select(`
          id,
          incomes(*),
          expenditures(*),
          assets(*),
          liabilities(*),
          goals(*)
        `)
        .eq('id', user.id)
        .single();

        const { 
          data: kycData, 
          error: kycError 
        } = await supabase
          .from('kyc_data')
          .select('*')
          .eq('profile_id', user.id)
          .limit(1)
          .maybeSingle();

      console.log('Profile query result:', { 
        profileData, 
        profileError,
        profileId: profileData?.id,
        incomesCount: profileData?.incomes?.length,
        expendituresCount: profileData?.expenditures?.length,
        kycData,
        kycError
      });

      if (profileError || !profileData) {
        console.error('Profile query error details:', profileError);
        throw new Error('Failed to retrieve user profile data: ' + profileError?.message);
      }

    // Calculate metrics
    const metrics = calculateFinancialMetricsForRisk(
      profileData.incomes || [],
      profileData.expenditures || [],
      profileData.assets || [],
      profileData.liabilities || [],
      profileData.goals || [],
      kycData?.date_of_birth
    );

      console.log('Calculated metrics:', metrics); // Debug log
      // Calculate risk scores
      const calculatedScores = calculateRiskScores(entries, metrics);

      console.log('Calculated risk scores:', calculatedScores);

      // Format responses object properly
      const responses = {
        knowledge_1: entries.knowledge_1,
        knowledge_2: entries.knowledge_2,
        attitude_1: entries.attitude_1,
        attitude_2: entries.attitude_2,
        capacity_1: entries.capacity_1,
        capacity_2: entries.capacity_2,
        timeframe_1: entries.timeframe_1
      };


      console.log('Submitting risk assessment with scores:', calculatedScores);
      

      // First, check for existing risk assessments
      const { data: existingAssessments, error: existingError } = await supabase
        .from('risk_assessments')
        .select('*')
        .eq('client_id', user.id)
        .order('created_at', { ascending: false })
        .limit(1);

      console.log('Existing assessments:', { 
        existingAssessments, 
        existingError 
      });

      const riskAssessmentData = {
        client_id: user.id,
        responses: entries,
        calculated_scores: {
          knowledgeScore: calculatedScores.knowledgeScore,
          attitudeScore: calculatedScores.attitudeScore,
          capacityScore: calculatedScores.capacityScore,
          timeframeScore: calculatedScores.timeframeScore,
          overallScore: calculatedScores.overallScore,
          riskCategory: calculatedScores.riskCategory
        }
      };

      let result;
      if (existingAssessments?.[0]) {
        // Update existing risk assessment (using the existing id)
        result = await supabase
          .from('risk_assessments')
          .update(riskAssessmentData)
          .eq('id', existingAssessments[0].id)
          .select();
      } else {
        // Insert new risk assessment, without an id field so that Supabase auto-generates it
        result = await supabase
          .from('risk_assessments')
          .insert(riskAssessmentData)
          .select();
      }

    const { data, error } = result;

    console.log('Upsert result:', { data, error });

    if (error) throw error;

    // Navigate to dashboard
    navigate('/client/client-dashboard');

    } catch (error) {
      console.error('Error saving risk assessment:', error);
      alert('Failed to save risk assessment. Please try again.');
    }
  };
    
  

  return (
    <div className="max-w-2xl mx-auto p-6 bg-white rounded-lg shadow-lg">
      <h1 className="text-2xl font-semibold mb-6">Risk Assessment Questionnaire</h1>
      <FinancialForm
        formType="risk_assessments"
        nextRoute="/client/client-dashboard"
        stepNumber={6}
        fields={fields}
        defaultEntry={{}}
        onSubmit={handleSubmit}
      />
    </div>
  );
};

export default RiskAssessmentForm;

import React, { useState, useEffect, useContext } from 'react';
import { useNavigate } from 'react-router-dom';
import { supabase } from '../../../services/supabaseClient';
import { AuthContext } from '../../../context/AuthContext';
import { riskProfileQuestions } from '../../../utils/riskAssessment';

const RiskAssessmentForm = () => {
  const navigate = useNavigate();
  const { user } = useContext(AuthContext);
  const [responses, setResponses] = useState<{ [key: string]: number }>({});
  const [currentQuestion, setCurrentQuestion] = useState(0);
  const [isSaving, setIsSaving] = useState(false);

  const handleAnswer = (score: number) => {
    setResponses(prev => ({
      ...prev,
      [riskProfileQuestions[currentQuestion].id]: score
    }));

    if (currentQuestion < riskProfileQuestions.length - 1) {
      setCurrentQuestion(prev => prev + 1);
    }
  };

  const handleSubmit = async () => {
    if (!user) return;
    setIsSaving(true);

    try {
      const { error } = await supabase
        .from('risk_profiles')
        .upsert({
          client_id: user.id,
          responses,
          created_at: new Date().toISOString()
        });

      if (error) throw error;
      navigate('/client/client-dashboard');
    } catch (error) {
      console.error('Error saving risk profile:', error);
      alert('Failed to save risk profile');
    } finally {
      setIsSaving(false);
    }
  };

  const currentQuestionData = riskProfileQuestions[currentQuestion];

  return (
    <div className="max-w-2xl mx-auto p-6 bg-white rounded-lg shadow-lg">
      <div className="mb-6">
        <div className="flex justify-between items-center mb-4">
          <h1 className="text-2xl font-bold">Risk Profile Assessment</h1>
          <span className="text-sm text-gray-500">
            Question {currentQuestion + 1} of {riskProfileQuestions.length}
          </span>
        </div>
        
        
        <div className="w-full h-2 bg-gray-200 rounded-full">
          <div 
            className="h-2 bg-blue-500 rounded-full transition-all duration-300"
            style={{ width: `${((currentQuestion + 1) / riskProfileQuestions.length) * 100}%` }}
          />
        </div>
      </div>

      <div className="mb-8">
        <h2 className="text-xl mb-4">{currentQuestionData.question}</h2>
        <div className="space-y-3">
          {currentQuestionData.answers.map((answer, index) => (
            <button
              key={index}
              onClick={() => handleAnswer(answer.score)}
              className="w-full p-4 text-left border rounded-lg hover:bg-blue-50 hover:border-blue-500 transition-colors"
            >
              {answer.text}
            </button>
          ))}
        </div>
      </div>

      <div className="flex justify-between">
        <button
          onClick={() => setCurrentQuestion(prev => Math.max(0, prev - 1))}
          disabled={currentQuestion === 0}
          className="px-4 py-2 text-blue-600 disabled:text-gray-400"
        >
          Previous
        </button>
        
        {currentQuestion === riskProfileQuestions.length - 1 && (
          <button
            onClick={handleSubmit}
            disabled={isSaving}
            className="px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-400"
          >
            {isSaving ? 'Saving...' : 'Complete Assessment'}
          </button>
        )}
      </div>
    </div>
  );
};

export default RiskAssessmentForm;

*/
</file>

<file path="src/components/Client/Risk/RiskProfileResults.tsx">
// Client/Risk/RiskProfile.tsx

import React from 'react';
import { RiskScores } from '../../../utils/riskAssessment';

interface RiskProfileResultsProps {
  riskData: RiskScores;
}

const RiskProfileResults: React.FC<RiskProfileResultsProps> = ({ riskData }) => {
  console.log('RiskProfileResults received data:', riskData);

  if (!riskData) {
    console.log('No risk data provided')
    return (
      <div className="text-center py-8">
        <p className="text-gray-500">No risk profile data available</p>
      </div>
    );
  }

  // Validate that all required fields are present
  const isValidRiskData = 
    riskData.knowledgeScore !== undefined &&
    riskData.attitudeScore !== undefined &&
    riskData.capacityScore !== undefined &&
    riskData.timeframeScore !== undefined &&
    riskData.overallScore !== undefined &&
    riskData.riskCategory !== undefined &&
    riskData.capacityForLoss !== undefined;

  if (!isValidRiskData) {
  console.log('Invalid risk data:', riskData);
    return (
      <div className="text-center py-8">
        <p className="text-gray-500">Incomplete risk profile data</p>
      </div>
    );
  }


    // Log individual pieces to ensure they exist
    console.log('Risk Category:', riskData.riskCategory);
    console.log('Overall Score:', riskData.overallScore);
    console.log('Capacity for Loss:', riskData.capacityForLoss);
    console.log('Individual Scores:', {
      knowledge: riskData.knowledgeScore,
      attitude: riskData.attitudeScore,
      capacity: riskData.capacityScore,
      timeframe: riskData.timeframeScore
    });
/*
  const scoreData = [
    { name: 'Investment Knowledge', score: riskData.knowledgeScore || 0 },
    { name: 'Risk Attitude', score: riskData.attitudeScore || 0 },
    { name: 'Risk Capacity', score: riskData.capacityScore || 0 },
    { name: 'Time Horizon', score: riskData.timeframeScore || 0 }
  ];

  const allocationData = [
    { name: 'Equities', value: riskData.recommendedAssetAllocation?.equities || 0 },
    { name: 'Bonds', value: riskData.recommendedAssetAllocation?.bonds || 0 },
    { name: 'Cash', value: riskData.recommendedAssetAllocation?.cash || 0 },
    { name: 'Other', value: riskData.recommendedAssetAllocation?.other || 0 }
  ];
*/
  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h3 className="text-lg font-medium">Risk Category</h3>
        <span className={`px-3 py-1 rounded-full text-sm font-medium ${
          riskData.riskCategory.includes('Conservative') ? 'bg-blue-100 text-blue-800' :
          riskData.riskCategory.includes('Moderate') ? 'bg-green-100 text-green-800' :
          'bg-yellow-100 text-yellow-800'
        }`}>
          {riskData.riskCategory}
        </span>
      </div>

      <div className="grid md:grid-cols-2 gap-4">
        <div className="bg-gray-50 p-4 rounded-lg">
          <div className="text-sm text-gray-500">Overall Score</div>
          <div className="text-2xl font-semibold">{riskData.overallScore.toFixed(1)}/4</div>
        </div>
        <div className="bg-gray-50 p-4 rounded-lg">
          <div className="text-sm text-gray-500">Capacity for Loss</div>
          <div className="text-2xl font-semibold">{riskData.capacityForLoss.category}</div>
        </div>
      </div>

      <div className="space-y-4">
        {[
          { label: 'Knowledge', score: riskData.knowledgeScore },
          { label: 'Attitude', score: riskData.attitudeScore },
          { label: 'Capacity', score: riskData.capacityScore },
          { label: 'Time Horizon', score: riskData.timeframeScore }
        ].map((item) => (
          <div key={item.label}>
            <div className="flex justify-between text-sm mb-1">
              <span>{item.label}</span>
              <span>{item.score.toFixed(1)}/4</span>
            </div>
            <div className="w-full h-2 bg-gray-200 rounded-full">
              <div 
                className="h-2 bg-blue-500 rounded-full"
                style={{ width: `${(item.score / 4) * 100}%` }}
              />
            </div>
          </div>
        ))}
      </div>

      <div>
        <h3 className="text-lg font-medium mb-4">Capacity for Loss Factors</h3>
        <div className="space-y-4">
          {riskData.capacityForLoss.factors.map((factor, index) => (
            <div key={index} className="bg-gray-50 p-4 rounded-lg">
              <div className="flex justify-between mb-1">
                <span className="font-medium">{factor.factor}</span>
                <span>{factor.score}/4</span>
              </div>
              <p className="text-sm text-gray-600 mt-1">{factor.explanation}</p>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
};

export default RiskProfileResults;
</file>

<file path="src/components/Client/AssetsForm.tsx">
import React from 'react';
import FinancialForm from './BaseForm';

const AssetsForm: React.FC = () => {
  return (
    <FinancialForm
      formType="assets"
      nextRoute="/client/liabilities"
      stepNumber={3}
      fields={[
        {
          name: 'type',
          type: 'select',
          label: 'Asset Type',
          options: [
            { value: 'Property', label: 'Property' },
            { value: 'Investments', label: 'Investments' },
            { value: 'ISA', label: 'ISA' },
            { value: 'Savings', label: 'Savings' },
            { value: 'Other', label: 'Other' }
          ]
        },
        {
          name: 'description',
          type: 'text',
          label: 'Description'
        },
        {
          name: 'value',
          type: 'number',
          label: 'Value'
        }
      ]}
      defaultEntry={{
        type: '',
        description: '',
        value: 0
      }}
    />
  );
};

export default AssetsForm;
</file>

<file path="src/components/Client/BaseForm.tsx">
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { supabase } from '../../services/supabaseClient';
import { AuthContext } from '../../context/AuthContext';


interface FormField {
  name: string;
  type: 'text' | 'number' | 'select';
  label: string;
  options?: { value: string; label: string }[];
  placeholder?: string;
  condition?: (values: Record<string, any>) => boolean;
}

interface FormEntry {
  id: string;
  client_id: string;
  [key: string]: string | number | undefined;
}

interface FinancialFormProps {
  formType: 'expenditures' | 'assets' | 'goals' | 'liabilities' | 'risk_assessments';
  nextRoute: string;
  stepNumber: number;
  fields: FormField[];
  defaultEntry: Record<string, any>;

  onSubmit?: (formData: Record<string, any>) => Promise<void>; 
}

const FinancialForm: React.FC<FinancialFormProps> = ({
  formType,
  nextRoute,
  stepNumber,
  fields,
  defaultEntry,
  onSubmit
}) => {
  const navigate = useNavigate();
  const { user } = React.useContext(AuthContext);
  const [entries, setEntries] = useState<FormEntry[]>([]);
  const [isSaving, setIsSaving] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      if (!user) {
        console.warn('No user found in AuthContext.');
        setIsLoading(false);
        return;
      }

      try {
        const { data, error } = await supabase
          .from(formType)
          .select('*')
          .eq('client_id', user.id);

          if (error) {
            throw new Error(`Failed to fetch ${formType}: ${error.message}`);
          }

          if (data && data.length > 0) {

            const filteredData = data.filter(entry => {
              // Check if at least one field has a value
              return fields.some(field => {
                const value = entry[field.name];
                return value !== undefined && value !== '' && value !== 0 && value !== null;
              });
            });

            setEntries(filteredData.length > 0 ? filteredData : [{ id: '', client_id: user.id, ...defaultEntry }]);
          } else {
            // Start with just one empty entry
            setEntries([{ id: '', client_id: user.id, ...defaultEntry }]);
          }
        } catch (error) {
          console.error(`Error fetching ${formType}:`, error);
          setError(`Unable to load existing ${formType}. You can still continue with empty forms.`);
          // Still set an empty entry
          if (user?.id) {
            setEntries([{ id: '', client_id: user.id, ...defaultEntry }]);
          }
        } finally {
          setIsLoading(false);
        }
      };


    fetchData();
  }, [user, formType, defaultEntry]);

  const handleRemoveEntry = async (index: number) => {
    const entryToRemove = entries[index];
    
    // If the entry has an ID, it exists in the database and needs to be deleted
    if (entryToRemove.id) {
      try {
        const { error } = await supabase
          .from(formType)
          .delete()
          .eq('id', entryToRemove.id);
          
        if (error) {
          console.error(`Error deleting ${formType}:`, error);
          setError(`Failed to delete entry. ${error.message}`);
          return;
        }
      } catch (err) {
        console.error(`Error deleting ${formType}:`, err);
        return;
      }
    }
    
    // Remove from local state
    const newEntries = [...entries];
    newEntries.splice(index, 1);
    
    // If we removed the last entry, add an empty one
    if (newEntries.length === 0) {
      newEntries.push({ id: '', client_id: user?.id || '', ...defaultEntry });
    }
    
    setEntries(newEntries);
  };

  const handleChange = (index: number, field: string, value: any) => {
    const newEntries = [...entries];
    newEntries[index] = {
      ...newEntries[index],
      [field]: value
    } 
    setEntries(newEntries);
  };

  

  const handleAddEntry = () => {
    if (!user) {
      console.warn('No user found');
      return;
    }
        
    setEntries([...entries, { id: '', client_id: user.id, ...defaultEntry }]);

  };

  const calculateProgress = () => {
    const filledEntries = entries.filter(entry => 
      fields.some(field => {
        const value = entry[field.name as keyof FormEntry];
        return value !== undefined && value !== '';
      })
    );
    return (filledEntries.length / entries.length) * 100;
  };

  const handleSubmit = async () => {
    if (!user) {
      alert('No user found');
      return;
    }

    setIsSaving(true);
    try {
      const validEntries = entries.filter(entry => 
        fields.some(field => {
          const value = entry[field.name as keyof FormEntry];
          return value !== undefined && value !== '';
        })
      );
      
      // If custom submit handler provided, use it
      if (typeof onSubmit === 'function') {
        const formData: Record<string, any> = {};
        // Combine all entries into a single object for risk assessment
        validEntries.forEach(entry => {
          fields.forEach(field => {
            formData[field.name] = entry[field.name];
          });
        });
        await onSubmit(formData);
        return;
      }
      // Handle existing entries
      const existingEntries = validEntries.filter(entry => entry.id);
      for (const entry of existingEntries) {
        const { error } = await supabase
          .from(formType)
          .update(entry)
          .eq('id', entry.id);

        if (error) throw error;
      }

      // Handle new entries
      const newEntries = validEntries
        .filter(entry => !entry.id)
        .map(({ id, ...entry }) => ({
          ...entry,
          client_id: user.id
        }));

      if (newEntries.length > 0) {
        const { error } = await supabase
          .from(formType)
          .insert(newEntries);

        if (error) throw error;
      }

      navigate(nextRoute);
    } catch (error) {
      console.error(`Error saving ${formType}:`, error);
      alert(`Failed to save ${formType} data. Please try again.`);
    } finally {
      setIsSaving(false);
    }
  };

  if (isLoading) {
    return (
      <div className="w-full max-w-md mx-auto p-6 bg-gray-800 rounded-lg shadow-md">
        <div className="text-gray-300 text-center">Loading {formType} data...</div>
      </div>
    );
  }

  return (
    <div className="w-full max-w-md mx-auto p-6 bg-gray-800 rounded-lg shadow-md">
      {/* Progress Section */}
      <div className="mb-6">
        <div className="flex justify-between items-center mb-2">
          <h1 className="text-2xl font-semibold text-gray-100">{formType.charAt(0).toUpperCase() + formType.slice(1)} Details</h1>
          <span className="text-sm text-gray-400">Step {stepNumber} of 6</span>
        </div>
        <div className="w-full h-2 bg-gray-700 rounded-full overflow-hidden">
          <div 
            className="h-full bg-blue-500 transition-all duration-300"
            style={{ width: `${calculateProgress()}%` }}
          />
        </div>
        <div className="mt-2 text-sm text-gray-400 text-right">
          {Math.round(calculateProgress())}% Complete
        </div>
      </div>

      <div className="space-y-4">
      {entries.map((entry, index) => (
        <div key={entry.id || index} className="space-y-2 p-4 bg-gray-700 rounded-lg">
          {fields.map((field) => {
            // Check if the field should be rendered based on condition
            if (field.condition && !field.condition(entry)) {
              return null; // Skip rendering if condition fails
            }

            return (
              <div key={field.name} className="space-y-1">
                <label className="block text-sm font-medium text-gray-300">
                  {field.label}
                </label>
                {field.type === 'select' ? (
                  <select
                    value={String(entry[field.name] || '')}
                    onChange={(e) => handleChange(index, field.name, e.target.value)}
                    className="w-full px-4 py-2 bg-gray-600 text-gray-100 border border-gray-500 rounded-lg focus:ring-2 focus:ring-blue-500 focus:outline-none"
                  >
                    <option value="">Select {field.label}</option>
                    {field.options?.map((option) => (
                      <option key={option.value} value={option.value}>
                        {option.label}
                      </option>
                    ))}
                  </select>
                ) : (
                  <input
                    type={field.type}
                    value={
                      field.type === 'number'
                        ? Number(entry[field.name] || 0)
                        : String(entry[field.name] || '')
                    }
                    onChange={(e) =>
                      handleChange(
                        index,
                        field.name,
                        field.type === 'number' ? Number(e.target.value) : e.target.value
                      )
                    }
                    className="w-full px-4 py-2 bg-gray-600 text-gray-100 border border-gray-500 rounded-lg focus:ring-2 focus:ring-blue-500 focus:outline-none"
                    placeholder={field.placeholder || `Enter ${field.label.toLowerCase()}`}
                  />
                )}
              </div>
            );
          })}
        </div>
      ))}
    </div>

      {/* Navigation */}
      <div className="mt-6 flex justify-between">
        <button
          onClick={handleAddEntry}
          className="px-4 py-2 text-sm font-medium bg-gray-600 text-gray-300 rounded-lg hover:bg-gray-500"
        >
          + Add Entry
        </button>
        <div className="flex gap-3">
          <button
            onClick={() => navigate(-1)}
            className="px-4 py-2 text-sm font-medium bg-gray-600 text-gray-300 rounded-lg hover:bg-gray-500"
          >
            Back
          </button>
          <button
            onClick={handleSubmit}
            disabled={isSaving || calculateProgress() === 0}
            className={`px-6 py-2 text-sm font-medium rounded-lg focus:outline-none ${
              isSaving || calculateProgress() === 0
                ? "bg-gray-500 text-gray-400 cursor-not-allowed"
                : "bg-blue-500 text-gray-100 hover:bg-blue-600"
            }`}
          >
            {isSaving ? "Saving..." : "Continue"}
          </button>
        </div>
      </div>
    </div>
  );
};

export default FinancialForm;
</file>

<file path="src/components/Client/Dashboard.tsx">
// src/components/Client/Dashboard.tsx

import React, { useEffect, useState, useContext, useMemo } from 'react';
import { financialCalculations } from 'utils/financialcalculationMetrics';
import type { FinancialData, Income } from '../../@types/financial';
import { useNavigate, Link } from 'react-router-dom';
import { supabase } from '../../services/supabaseClient';
import { Pie, Bar } from 'react-chartjs-2';
import { AuthContext } from '../../context/AuthContext';
import 'chart.js/auto';
import NetWorthCard from './Cards/NetWorthCard';
import RiskProfileResults from './Risk/RiskProfileResults';
import { RiskScores } from 'utils/riskAssessment';


interface IncomeItem {
  type: string;
  amount: number;
  frequency: string;
}


const ClientDashboard: React.FC = () => {
  const navigate = useNavigate();
  const { user, session } = useContext(AuthContext);
  const [financialData, setFinancialData] = useState<FinancialData | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [riskProfile, setRiskProfile] = useState<RiskScores | null>(null);


  const financialSummary = useMemo(() => {
    if (!financialData) return null;
    
    return financialCalculations.calculateFinancialSummary({
      incomes: financialData.incomes || [],
      expenditures: financialData.expenditures || [],
      assets: financialData.assets || [],
      liabilities: financialData.liabilities || [],
      goals: financialData.goals || []
    });
  }, [financialData]);


  useEffect(() => {
    

    const fetchFinancialData = async () => {
      if (!user || !session) {
        
        setError('User not authenticated.');
        setLoading(false);
       
        return;
      }

      
      try {
        const { data: testData, error: testError } = await supabase
          .from('profiles')
          .select('id')
          .eq('id', user.id)
          .single();
          
        
      } catch (e) {
        
      }

      // Insert the new code here
      try {
        // Fetch incomes with proper type casting and null checks
        const { data: incomesData, error: incomesError } = await supabase
          .from('incomes')
          .select('*')
          .eq('client_id', user.id);

  

        if (incomesError) {
          throw new Error(`Failed to fetch incomes: ${incomesError.message}`);
        }

        // Fetch expenditures
        const { data: expendituresData, error: expendituresError } = await supabase
          .from('expenditures')
          .select('*')
          .eq('client_id', user.id);


        if (expendituresError) {
          throw new Error(`Failed to fetch expenditures: ${expendituresError.message}`);
        }

        // Calculate total income, properly handling monthly vs annual frequencies
        const totalIncome = (incomesData || []).reduce((sum, income: Income) => {
          const amount = Number(income.amount) || 0;
          return sum + (income.frequency === 'Monthly' ? amount * 12 : amount);
        }, 0);

        const processedIncomes = (incomesData || [])
          .filter(income => income.amount && Number(income.amount) > 0)
          .reduce((unique: Income[], income: Income) => { // Specify the type here
            const existing = unique.find(item => item.type === income.type);
            if (!existing) {
              unique.push(income);
            } else {
              // If type already exists, add to the amount
              existing.amount = Number(existing.amount) + Number(income.amount);
            }
            return unique;
          }, []);

        // Transform expenditure data
        const expenditures = (expendituresData || []).map(exp => ({
          category: exp.category,
          amount: Number(exp.amount) || 0,
          client_id: exp.client_id,
          frequency: exp.frequency
        }));

              // Fetch assets
          const { data: assetsData, error: assetsError } = await supabase
          .from('assets')
          .select('*')
          .eq('client_id', user.id);

        if (assetsError) throw new Error(`Failed to fetch assets: ${assetsError.message}`);

        // Fetch liabilities
        const { data: liabilitiesData, error: liabilitiesError } = await supabase
          .from('liabilities')
          .select('*')
          .eq('client_id', user.id);

        if (liabilitiesError) throw new Error(`Failed to fetch liabilities: ${liabilitiesError.message}`);

        const totalAssets = assetsData?.reduce((sum, asset) => sum + (asset.value || 0), 0) || 0;
        const totalLiabilities = liabilitiesData?.reduce((sum, liability) => sum + (liability.amount || 0), 0) || 0;
        
        const { data: goalsData, error: goalsError } = await supabase
        .from('goals')
        .select('*')
        .eq('client_id', user.id);

        if (goalsError) throw new Error(`Failed to fetch goals: ${goalsError.message}`);


        // Update financial data state

        setFinancialData({
          incomes: incomesData || [],
          expenditures: expenditures || [],
          assets: assetsData || [], // Add assets fetch when implementing that feature
          liabilities: liabilitiesData || [], // Add liabilities fetch when implementing that feature
          goals: goalsData || [] // Add the goals data here
        });

      } catch (err) {
      
        setError(err instanceof Error ? err.message : 'Failed to fetch financial data');
      } finally {
        setLoading(false);
      }
    };

    fetchFinancialData();
  }, [user, session]);

  const RiskProfileSection: React.FC<{ riskProfileData: RiskScores | null }> = ({ riskProfileData }) => {
    if (!riskProfileData) {
      return (
        <section className="bg-white p-6 rounded-lg shadow mb-6">
          <div className="text-center py-8">
            <p className="text-gray-500 mb-4">Complete your risk assessment to see your investment risk profile</p>
            <button 
              onClick={() => navigate('/client/risk-assessment')}
              className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
            >
              Take Risk Assessment
            </button>
          </div>
        </section>
      );
    }
    return (
      <section className="bg-white p-6 rounded-lg shadow mb-6">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-xl font-semibold">Risk Profile</h2>
          <span className={`px-3 py-1 rounded-full text-sm font-medium ${
            riskProfileData.riskCategory.includes('Conservative') ? 'bg-blue-100 text-blue-800' :
            riskProfileData.riskCategory.includes('Moderate') ? 'bg-green-100 text-green-800' :
            'bg-yellow-100 text-yellow-800'
          }`}>
            {riskProfileData.riskCategory}
          </span>
        </div>
  
        <div className="grid grid-cols-2 gap-4 mb-4">
          <div className="p-3 bg-gray-50 rounded-lg">
            <div className="text-sm text-gray-500">Overall Score</div>
            <div className="text-xl font-semibold">{riskProfileData.overallScore.toFixed(1)}/4</div>
          </div>
          <div className="p-3 bg-gray-50 rounded-lg">
            <div className="text-sm text-gray-500">Capacity for Loss</div>
            <div className="text-xl font-semibold">{riskProfileData.capacityForLoss.category}</div>
          </div>
        </div>
  
        <div className="space-y-3">
          {[
            { label: 'Knowledge', score: riskProfileData.knowledgeScore },
            { label: 'Attitude', score: riskProfileData.attitudeScore },
            { label: 'Capacity', score: riskProfileData.capacityScore },
            { label: 'Time Horizon', score: riskProfileData.timeframeScore }
          ].map((item) => (
            <div key={item.label}>
              <div className="flex justify-between text-sm mb-1">
                <span>{item.label}</span>
                <span>{item.score.toFixed(1)}/4</span>
              </div>
              <div className="w-full h-2 bg-gray-200 rounded-full">
                <div 
                  className="h-2 bg-blue-500 rounded-full transition-all duration-300"
                  style={{ width: `${(item.score / 4) * 100}%` }}
                />
              </div>
            </div>
          ))}
        </div>
  
        <div className="mt-6">
          <h3 className="text-lg font-medium mb-3">Capacity for Loss Factors</h3>
          <div className="space-y-4">
            {riskProfileData.capacityForLoss.factors.map((factor, index) => (
              <div key={index} className="bg-gray-50 p-3 rounded-lg">
                <div className="flex justify-between mb-1">
                  <span className="font-medium">{factor.factor}</span>
                  <span>{factor.score}/4</span>
                </div>
                <p className="text-sm text-gray-600">{factor.explanation}</p>
              </div>
            ))}
          </div>
        </div>
      </section>
    );
  }

  useEffect(() => {
    const fetchRiskProfile = async () => {
      if (!user?.id) return;
  
      try {
        console.log('Fetching risk profile for user:', user.id);
        const { data, error } = await supabase
          .from('risk_assessments')
          .select('*')
          .eq('client_id', user.id)
          .order('created_at', { ascending: false })
          .limit(1)
          .maybeSingle();
        
        console.log('Risk profile query result:', { data, error });
  
        if (error) {
          console.error('Error fetching risk profile:', error);
          return;
        }
    
        if (data && data.calculated_scores) {
          const calculatedScores = data.calculated_scores;
          
          // Validate that the calculated_scores have the expected structure
          const isValidScores = 
            typeof calculatedScores.knowledgeScore === 'number' &&
            typeof calculatedScores.attitudeScore === 'number' &&
            typeof calculatedScores.capacityScore === 'number' &&
            typeof calculatedScores.timeframeScore === 'number' &&
            typeof calculatedScores.overallScore === 'number' &&
            typeof calculatedScores.riskCategory === 'string';
            

            if (isValidScores) {
              console.log('Setting validated risk profile:', calculatedScores);
              setRiskProfile({
                knowledgeScore: calculatedScores.knowledgeScore,
                attitudeScore: calculatedScores.attitudeScore,
                capacityScore: calculatedScores.capacityScore,
                timeframeScore: calculatedScores.timeframeScore,
                overallScore: calculatedScores.overallScore,
                riskCategory: calculatedScores.riskCategory,
                capacityForLoss: {
                  score: 2, // Default middle score
                  category: 'Medium',
                  factors: [
                    {
                      factor: 'Emergency Fund',
                      score: 2,
                      explanation: 'Estimated based on available data'
                    },
                    {
                      factor: 'Debt Service',
                      score: 2,
                      explanation: 'Estimated based on available data'
                    }
                  ]
                }
              });
            } else {
              console.warn('Invalid risk scores structure:', calculatedScores);
            }
          } else {
            console.warn('No calculated scores found in risk assessment');
          }
      
        } catch (error) {
          console.error('Error fetching risk assessment:', error);
        }
      };
  
      fetchRiskProfile();
    }, [user?.id]); 


  if (loading) {
    return (
      <div className="flex justify-center items-center min-h-screen">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mb-4"></div>
          <p>Loading your financial data...</p>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex justify-center items-center min-h-screen">
        <div className="bg-red-50 border border-red-200 rounded-lg p-4 max-w-md">
          <h3 className="text-red-800 font-medium">Error Loading Data</h3>
          <p className="text-red-600">{error}</p>
          <button 
            onClick={() => window.location.reload()}
            className="mt-4 px-4 py-2 bg-red-100 text-red-800 rounded hover:bg-red-200"
          >
            Retry
          </button>
        </div>
      </div>
    );
  }

if (!financialData) {
  return (
    <div className="flex flex-col items-center justify-center min-h-screen">
      <p className="mb-4">No financial data available.</p>
      <button
        onClick={() => navigate('/client/income')}
        className="bg-blue-500 text-white px-4 py-2 rounded"
      >
        Add Income Data
      </button>
    </div>
  );
}


  const NoDataPrompt = ({ type, url }: { type: string, url: string }) => (
    <div className="p-4 border rounded">
      <p>No {type} data available. <Link to={url}>Click here to add your {type}</Link></p>
    </div>
  );


  const expenditureChartData = {
    labels: financialData.expenditures.map((item) => item.category),
    datasets: [
      {
        label: 'Expenditure by Category',
        data: financialData.expenditures.map((item) => item.amount),
        backgroundColor: [
          '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40',
        ],
      },
    ],
  };

  const incomeChartData = {
    labels: financialData.incomes
      // Filter out empty or zero incomes
      .filter(inc => inc.amount && Number(inc.amount) > 0)
      // Group by type to prevent duplicates
      .reduce((unique: Income[], income: Income) => {
        const existing = unique.find(item => item.type === income.type);
        if (!existing) {
          unique.push(income);
        } else {
          // If type already exists, add to the amount
          existing.amount = Number(existing.amount) + Number(income.amount);
        }
        return unique;
      }, [])
      .map(inc => inc.type),
    datasets: [{
      label: 'Income Sources',
      data: financialData.incomes
        // Filter out empty or zero incomes
        .filter(inc => inc.amount && Number(inc.amount) > 0)
        // Group by type to prevent duplicates
        .reduce((unique: IncomeItem[], income) => {
          const existing = unique.find(item => item.type === income.type);
          if (!existing) {
            unique.push(income);
          } else {
            // If type already exists, add to the amount
            existing.amount = Number(existing.amount) + Number(income.amount);
          }
          return unique;
        }, [])
        .map(inc => inc.frequency === 'Monthly' ? inc.amount * 12 : inc.amount),
      backgroundColor: [
        '#4BC0C0', '#36A2EB', '#FFCE56', '#FF6384', '#9966FF', '#FF9F40'
      ],
    }]
  };

  const assetsLiabilitiesChartData = {
    labels: ['Assets', 'Liabilities'],
    datasets: [
      {
        label: 'Assets vs. Liabilities',
        data: [
          financialSummary?.totalAssets || 0,
          financialSummary?.totalLiabilities || 0
        ],
        backgroundColor: ['#4BC0C0', '#FF6384'],
      },
    ],
  };

  return (
    <div className="container mx-auto px-4 py-8">
      <header className="mb-8">
        <h1 className="text-2xl font-bold">Your Financial Dashboard</h1>
      </header>

      <div className="space-y-6">
      <NetWorthCard 
        assets={financialSummary?.totalAssets || 0}
        liabilities={financialSummary?.totalLiabilities || 0}
      />
      </div>

      <main className="grid grid-cols-1 md:grid-cols-2 gap-8">
      <section 
          onClick={() => navigate('/client/income')} 
          className="bg-white p-6 rounded-lg shadow hover:shadow-lg transition-shadow cursor-pointer"
        >
          <h2 className="text-xl font-semibold mb-4">Income Overview</h2>
              {financialData?.incomes.length > 0 ? (
                <Pie data={incomeChartData} />
              ) : (
                <NoDataPrompt type="income" url="/client/income" />
              )}
            
            <div className="space-y-2">
              <p className="font-medium">Total Annual Income: {financialCalculations.formatCurrency(financialSummary?.annualIncome || 0)}</p>
              <p className="font-medium">Monthly Average: {financialCalculations.formatCurrency(financialSummary?.monthlyIncome || 0)}</p>
            </div>
              <div className="max-h-40 overflow-y-auto mt-4">
              {financialData.incomes
                // Filter out empty or zero incomes
                .filter(inc => inc.amount && Number(inc.amount) > 0)
                // Group by type to prevent duplicates
                .reduce((unique: Income[], income) => {
                  const existing = unique.find(item => item.type === income.type);
                  if (!existing) {
                    unique.push(income);
                  } else {
                    // If type already exists, add to the amount
                    existing.amount = Number(existing.amount) + Number(income.amount);
                  }
                  return unique;
                }, [])
                .map((inc, index) => (
                  <div key={index} className="flex justify-between text-sm py-1">
                    <span>{inc.type}</span>
                    <span>
                      {financialCalculations.formatCurrency(inc.amount)}
                      <span className="text-gray-500 text-xs ml-1">
                        ({inc.frequency})
                      </span>
                    </span>
                  </div>
                ))
              }
            </div>
          
        </section>

      <section onClick={() => navigate('/client/expenditure')} 
      className="bg-white p-6 rounded-lg shadow hover:shadow-lg transition-shadow cursor-pointer">
          <h2>Expenditure Breakdown</h2>
            {financialData?.expenditures.length > 0 ? (
              <Pie data={expenditureChartData} />
            ) : (
              <NoDataPrompt type="expenditure" url="/client/expenditure" />
            )}
            <div className="space-y-2">
          <p>Total Monthly Expenses: {financialCalculations.formatCurrency(financialSummary?.monthlyExpenditure || 0)}</p>
          <div className="max-h-40 overflow-y-auto">
            {financialData?.expenditures.map((exp, index) => (
              <div key={index} className="flex justify-between text-sm py-1">
                <span>{exp.category}</span>
                <span>{financialCalculations.formatCurrency(exp.amount)}</span>
              </div>
            ))}
          </div>
        </div>
      </section>

        <section className="bg-white p-6 rounded-lg shadow hover:shadow-lg transition-shadow cursor-pointer"
        onClick={() => navigate('/client/assets')}>
        <h2>Assets and Liabilities</h2>
          {(financialSummary?.totalAssets || 0) > 0 || (financialSummary?.totalLiabilities || 0) > 0 ? (
            <>
              <p><strong>Total Assets:</strong> {financialCalculations.formatCurrency(financialSummary?.totalAssets || 0)}</p>
              <p><strong>Total Liabilities:</strong> {financialCalculations.formatCurrency(financialSummary?.totalLiabilities || 0)}</p>
              <p><strong>Net Worth:</strong> {financialCalculations.formatCurrency(financialSummary?.netWorth || 0)}</p>
              <Bar data={assetsLiabilitiesChartData} />
            </>
          ) : (
            <div>
              <NoDataPrompt type="assets" url="/client/assets" />
              <NoDataPrompt type="liabilities" url="/client/liabilities" />
            </div>
          )}
        </section>

        <section onClick={() => navigate('/client/goals')}
        className="bg-white p-6 rounded-lg shadow hover:shadow-lg transition-shadow cursor-pointer">
          <h2 className="text-xl font-semibold mb-4">Financial Goals</h2>
          {financialData?.goals && financialData.goals.length > 0 ? (
            <div className="space-y-4">
              {financialData.goals.map((goal, index) => (
                <div key={index} className="bg-gray-50 p-6 rounded-lg border border-gray-200">
                  <div className="grid gap-4 md:grid-cols-3">
                    <div>
                      <p className="text-sm text-gray-500">Goal</p>
                      <p className="text-lg font-medium">{goal.goal}</p>
                    </div>
                    
                    <div>
                      <p className="text-sm text-gray-500">Target Amount</p>
                      <p className="text-lg font-medium">{financialCalculations.formatCurrency(goal.target_amount)}</p>
                    </div>

                    <div>
                      <p className="text-sm text-gray-500">Time Horizon</p>
                      <p className="text-lg font-medium">{goal.time_horizon} years</p>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          ) : (
            <div className="text-center py-8">
              <p className="text-gray-500 mb-4">You haven't set any financial goals yet</p>
              <Link 
                to="/client/goals" 
                className="inline-flex items-center justify-center px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700"
              >
                Set Your Goals
              </Link>
            </div>
          )}
        </section>
        
        <section className="bg-white p-6 rounded-lg shadow mb-6">
          <h2 className="text-xl font-semibold mb-4">Risk Profile</h2>
          {riskProfile ? (
            <RiskProfileResults riskData={riskProfile} />
          ) : (
            <div className="text-center py-8">
              <p className="text-gray-500 mb-4">Complete your risk assessment to see your investment risk profile</p>
              <button 
                onClick={() => navigate('/client/risk-assessment')}
                className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
              >
                Take Risk Assessment
              </button>
            </div>
          )}
        </section>

        <section className="card">
          <h2>Actions</h2>
          <div className="flex justify-center gap-10">
            <button onClick={() => navigate('/client/income')}>Update Income</button>
            <button onClick={() => navigate('/client/expenditure')}>Update Expenditure</button>
            <button onClick={() => navigate('/client/assets')}>Update Assets</button>
            <button onClick={() => navigate('/client/liabilities')}>Update Liabilities</button>
            <button onClick={() => navigate('/client/goals')}>Set Goals</button>
            <button onClick={() => navigate('/client/risk-assessment')}>Update Risk Score</button>
          </div>
        </section>
      </main>
    </div>
  );
};

export default ClientDashboard;
</file>

<file path="src/components/Client/ExpenditureForm.tsx">
// ExpenditureForm.tsx
import React from 'react';
import FinancialForm from './BaseForm';

const ExpenditureForm: React.FC = () => {
  return (
    <FinancialForm
      formType="expenditures"
      nextRoute="/client/assets"
      stepNumber={2}
      fields={[
        {
          name: 'category',
          type: 'select',
          label: 'Category',
          options: [
            { value: 'Rent/Mortgage', label: 'Rent/Mortgage' },
            { value: 'Utilities', label: 'Utilities' },
            { value: 'Groceries', label: 'Groceries' },
            { value: 'Transportation', label: 'Transportation' },
            { value: 'Entertainment', label: 'Entertainment' },
            { value: 'Shopping', label: 'Shopping'},
            { value: 'Other', label: 'Other' }
          ]
        },
        {
          name: 'amount',
          type: 'number',
          label: 'Amount'
        },
        {
          name: 'frequency',
          type: 'select',
          label: 'Frequency',
          options: [
            { value: 'Monthly', label: 'Monthly' },
            { value: 'Annually', label: 'Annually' }
          ]
        }
      ]}
      defaultEntry={{
        category: '',
        amount: '',
        frequency: 'Monthly'
      }}
    />
  );
};

export default ExpenditureForm;


/*
// src/components/Client/ExpenditureForm.tsx
import React, { useState } from 'react';
import { supabase } from '../../services/supabaseClient';

interface ExpenditureEntry {
  category: string;
  amount: number;
  frequency: string;
}

interface ExpenditureFormProps {
  onComplete?: () => void;
}

const ExpenditureForm: React.FC = () => {
  const [expenditureEntries, setExpenditureEntries] = useState<ExpenditureEntry[]>([
    { category: '', amount: 0, frequency: '' },
  ]);

  const handleAddEntry = () => {
    setExpenditureEntries([
      ...expenditureEntries,
      { category: '', amount: 0, frequency: '' },
    ]);
  };

  const handleChange = (index: number, field: string, value: any) => {
    const entries = [...expenditureEntries];
    (entries[index] as any)[field] = value;
    setExpenditureEntries(entries);
  };

  const handleSubmit = async () => {
    const { data: user } = await supabase.auth.getUser();
    const clientId = user.user?.id;

    const { error } = await supabase.from('expenditures').insert(
      expenditureEntries.map((entry) => ({
        ...entry,
        client_id: clientId,
      }))
    );

    if (error) alert(error.message);
    else alert('Expenditure data submitted successfully!');
  };

  return (
    <div>
      <h2>Expenditure Details</h2>
      {expenditureEntries.map((entry, index) => (
        <div key={index}>
          <select
            value={entry.category}
            onChange={(e) => handleChange(index, 'category', e.target.value)}
          >
            <option value="">Select Category</option>
            <option value="Rent/Mortgage">Rent/Mortgage</option>
            <option value="Utilities">Utilities</option>
            <option value="Groceries">Groceries</option>
            <option value="Transportation">Transportation</option>
            <option value="Entertainment">Entertainment</option>
            <option value="Other">Other</option>
          </select>
          <input
            type="number"
            placeholder="Amount"
            value={entry.amount}
            onChange={(e) => handleChange(index, 'amount', Number(e.target.value))}
          />
          <select
            value={entry.frequency}
            onChange={(e) => handleChange(index, 'frequency', e.target.value)}
          >
            <option value="">Select Frequency</option>
            <option value="Monthly">Monthly</option>
            <option value="Annually">Annually</option>
          </select>
        </div>
      ))}
      <button onClick={handleAddEntry}>Add Another Expenditure</button>
      <button onClick={handleSubmit}>Submit Expenditure Data</button>
    </div>
  );
};

export default ExpenditureForm;
*/
</file>

<file path="src/components/Client/GoalsForm.tsx">
// src/components/Client/GoalsForm.tsx

import React, { useState } from 'react';
import FinancialForm from './BaseForm';

const GoalsForm: React.FC = () => {
  return (
    <FinancialForm
      formType="goals"
      nextRoute="/client/risk-assessment"
      stepNumber={4}
      fields={[
        {
          name: 'goal',
          type: 'select',
          label: 'Goal Type',
          options: [
            { value: 'Retirement', label: 'Retirement' },
            { value: 'House Purchase', label: 'House Purchase' },
            { value: 'Education', label: 'Education' },
            { value: 'Investment', label: 'Investment' },
            { value: 'Emergency Fund', label: 'Emergency Fund' },
            { value: 'Debt Repayment', label: 'Debt Repayment' },
            { value: 'Other', label: 'Other' }
          ]
        },
        {
          name: 'target_amount',
          type: 'number',
          label: 'Target Amount (£)'
        },
        {
          name: 'time_horizon',
          type: 'number',
          label: 'Time Horizon (Years)'
        }
      ]}
      defaultEntry={{
        goal: '',
        target_amount: '',
        time_horizon: ''
      }}
    />
  );
};

export default GoalsForm;
</file>

<file path="src/components/Client/IncomeForm.tsx">
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { supabase } from '../../services/supabaseClient';
import { AuthContext } from '../../context/AuthContext';

interface Income {
  id: string;
  client_id: string;
  type: string;
  amount: string;
  frequency: string;
}

interface User {
  id: string;
}

const IncomeForm: React.FC = () => {
  const navigate = useNavigate();
  const {user} = React.useContext(AuthContext);
  const [incomes, setIncomes] = useState<Income[]>([]);
  const [isSaving, setIsSaving] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);


  React.useEffect(() => {
    const fetchIncomes = async () => {
      if (!user) {
        console.warn('No user found in AuthContext.');
        setIsLoading(false);
        return;
      }

      try {

        if (!user.id) {
          console.warn('User ID is missing or undefined');
          throw new Error('User ID is required to fetch income data');
        }

        const { data: incomesData, error: incomesError } = await supabase
          .from('incomes')
          .select('*')
          .eq('client_id', user.id);

        if (incomesError) {
          console.error('Supabase error:', incomesError);
          throw new Error(`Failed to fetch incomes: ${incomesError.message}`);
        }

        if (incomesData && incomesData.length > 0) {
          // Filter out empty income entries (ones with no amount)
          const validIncomes = incomesData.filter(income => 
            income.amount !== null && 
            income.amount !== undefined && 
            income.amount.toString() !== '0' &&
            income.amount.toString() !== ''
          );
          
          if (validIncomes.length > 0) {
            const formattedIncomes = validIncomes.map(income => ({
              ...income,
              // Safely convert amount to string, handle null/undefined values
              amount: income.amount != null ? income.amount.toString() : ''
            }));
          setIncomes(formattedIncomes);
        } else {
          console.log('No existing income data, setting defaults');
          // Set default income types if no data exists
          setIncomes([
            { id: '', client_id: user.id, type: 'Salary', amount: '', frequency: 'Monthly' },
            { id: '', client_id: user.id, type: 'Investment', amount: '', frequency: 'Monthly' },
            { id: '', client_id: user.id, type: 'Rental', amount: '', frequency: 'Monthly' },
            { id: '', client_id: user.id, type: 'Business', amount: '', frequency: 'Monthly' },
            { id: '', client_id: user.id, type: 'Other', amount: '', frequency: 'Monthly' }
          ]);
        }
      } else {
        // Set default income types if no data exists
        console.log('No existing income data, setting defaults');
        setIncomes([
          { id: '', client_id: user.id, type: 'Salary', amount: '', frequency: 'Monthly' }
        ]);
      }
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        console.error('Error fetching incomes:', errorMessage);
        setError('Failed to load existing income data. You can still continue with empty forms.');
        
        // Still set default incomes even if there was an error
        if (user?.id) {
          setIncomes([
            { id: '', client_id: user.id, type: 'Salary', amount: '', frequency: 'Monthly' }
          ]);
        }
      } finally {
        setIsLoading(false);
    }
  };

    fetchIncomes();
  }, [user]);

  const handleAmountChange = (index: number, value: string) => {
    const newIncomes = [...incomes];
    newIncomes[index].amount = value;
    setIncomes(newIncomes);
  };

  const handleRemoveIncome = (index: number) => {
    // Get the income to be removed
    const incomeToRemove = incomes[index];
    
    // If it has an ID, it's an existing record in the database
    if (incomeToRemove.id) {
      // Delete from database
      supabase
        .from('incomes')
        .delete()
        .eq('id', incomeToRemove.id)
        .then(({ error }) => {
          if (error) {
            console.error('Error deleting income:', error);
            alert('Failed to delete income.');
          }
        });
    }
    
    // Remove from the local state
    const newIncomes = [...incomes];
    newIncomes.splice(index, 1);
    
    // If we've removed all incomes, add one empty income field
    if (newIncomes.length === 0) {
      newIncomes.push({
        id: '',
        client_id: user?.id || '',
        type: 'Salary',
        amount: '',
        frequency: 'Monthly'
      });
    }
    
    setIncomes(newIncomes);
  };

  const handleFrequencyChange = (index: number, value: string) => {
    const newIncomes = [...incomes];
    newIncomes[index].frequency = value;
    setIncomes(newIncomes);
  };

  const handleAddIncome = () => {
    if (!user) {
      console.warn('No user found');
      return;
    }
    
    setIncomes([...incomes, {
      id: '',
      client_id: user.id,
      type: 'Other',
      amount: '',
      frequency: 'Monthly'
    }]);
  };

  const calculateProgress = () => {
    const filledIncomes = incomes.filter(income => income.amount !== '');
    return (filledIncomes.length / incomes.length) * 100;
  };

  const handleSubmit = async () => {
    if (!user) {
      alert('No user found');
      return;
    }

    setIsSaving(true);
    try {
      const validIncomes = incomes.filter(income => income.amount > '');
      
      // Handle existing incomes
      const existingIncomes = validIncomes.filter(income => income.id);
      for (const income of existingIncomes) {
        const { error } = await supabase
          .from('incomes')
          .update({
            type: income.type,
            amount: parseFloat(income.amount) || 0,
            frequency: income.frequency
          })
          .eq('id', income.id);

        if (error) throw error;
      }

      // Handle new incomes
      const newIncomes = validIncomes
        .filter(income => !income.id)
        .map(({ id, ...income }) => ({
          ...income,
      amount: parseFloat(income.amount) || 0,
      client_id: user.id
    })); // Remove empty id field

      if (newIncomes.length > 0) {
        const { error } = await supabase
          .from('incomes')
          .insert(newIncomes);

        if (error) throw error;
      }

      navigate('/client/expenditure');
    } catch (error) {
      console.error('Error saving income:', error);
      alert('Failed to save income data. Please try again.');
    } finally {
      setIsSaving(false);
    }
  };

  if (isLoading) {
    return (
      <div className="w-full max-w-md mx-auto p-6 bg-gray-800 rounded-lg shadow-md">
        <div className="text-gray-300 text-center">Loading income data...</div>
      </div>
    );
  }

  return (
    <div className="w-full max-w-md mx-auto p-6 bg-gray-800 rounded-lg shadow-md">

    {error && (
        <div className="mb-4 p-3 bg-red-900 border border-red-800 text-red-100 rounded">
          {error} 
      </div>
    )}
  
      {/* Progress Section */}
      <div className="mb-6">
        <div className="flex justify-between items-center mb-2">
          <h1 className="text-2xl font-semibold text-gray-100">Income Details</h1>
          <span className="text-sm text-gray-400">Step 1 of 6</span>
        </div>
        <div className="w-full h-2 bg-gray-700 rounded-full overflow-hidden">
          <div 
            className="h-full bg-blue-500 transition-all duration-300"
            style={{ width: `${calculateProgress()}%` }}
          />
        </div>
        <div className="mt-2 text-sm text-gray-400 text-right">
          {Math.round(calculateProgress())}% Complete
        </div>
      </div>

      {/* Form */}
      <div className="space-y-4">
        {incomes.map((income, index) => (
          <div key={income.id || index} className="space-y-2">
            <label className="block text-sm font-medium text-gray-300">
              {income.type} Income
            </label>
            <button
                type="button"
                onClick={() => handleRemoveIncome(index)}
                className="p-1 text-gray-400 hover:text-red-400 transition-colors"
                aria-label="Remove income"
              >
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clipRule="evenodd" />
                </svg>
              </button>
            <div className="space-y-2">
              <input
                type="text"
                value={income.amount}
                placeholder="Amount"
                onChange={(e) => handleAmountChange(index, e.target.value)}
                className="w-full px-4 py-2 bg-gray-700 text-gray-100 border border-gray-600 rounded-lg focus:ring-2 focus:ring-blue-500 focus:outline-none"
              />
              <select
                value={income.frequency}
                onChange={(e) => handleFrequencyChange(index, e.target.value)}
                className="w-full px-4 py-2 bg-gray-700 text-gray-100 border border-gray-600 rounded-lg focus:ring-2 focus:ring-blue-500 focus:outline-none"
              >
                <option value="Monthly">Monthly</option>
                <option value="Annual">Annual</option>
              </select>
            </div>
          </div>
        ))}
      </div>

      {/* Navigation */}
      <div className="mt-6 flex justify-between">
        <button
          onClick={handleAddIncome}
          className="px-4 py-2 text-sm font-medium bg-gray-600 text-gray-300 rounded-lg hover:bg-gray-500"
        >
          + Add Income Source
        </button>
        <div className="flex gap-3">
          <button
            onClick={() => navigate(-1)}
            className="px-4 py-2 text-sm font-medium bg-gray-600 text-gray-300 rounded-lg hover:bg-gray-500"
          >
            Back
          </button>
          <button
            onClick={handleSubmit}
            disabled={isSaving || calculateProgress() === 0}
            className={`px-6 py-2 text-sm font-medium rounded-lg focus:outline-none ${
              isSaving || calculateProgress() === 0
                ? "bg-gray-500 text-gray-400 cursor-not-allowed"
                : "bg-blue-500 text-gray-100 hover:bg-blue-600"
            }`}
          >
            {isSaving ? "Saving..." : "Continue"}
          </button>
        </div>
      </div>
    </div>
  );
};

export default IncomeForm;
</file>

<file path="src/components/Client/LiabilitiesForm.tsx">
// LiabilitiesForm.tsx
import React from 'react';
import FinancialForm from './BaseForm';

const LiabilitiesForm: React.FC = () => {
  return (
    <FinancialForm
      formType="liabilities"
      nextRoute="/client/goals"
      stepNumber={3}
      fields={[
        {
          name: 'type',
          type: 'select',
          label: 'Liability Type',
          options: [
            { value: 'Credit Card', label: 'Credit Card' },
            { value: 'Loan', label: 'Loan' },
            { value: 'Mortgage', label: 'Mortgage' },
            { value: 'Overdraft', label: 'Overdraft' },
            { value: 'Other', label: 'Other' }
          ]
        },
        {
          name: 'description',
          type: 'text',
          label: 'Description'
        },
        {
          name: 'amount',
          type: 'number',
          label: 'Amount'
        },
        {
          name: 'interest_rate',
          type: 'number',
          label: 'Interest Rate (%)'
        },
        {
          name: 'term',
          type: 'number',
          label: 'Term (Years)',
          placeholder: 'e.g., 5',
          condition: (values: any) => ['Loan', 'Mortgage'].includes(values.type), // Show only for Loan/Mortgage
        },
      ]}
      defaultEntry={{
        type: '',
        description: '',
        amount: '',
        interest_rate: '',
        term: '',
      }}
    />
  );
};

export default LiabilitiesForm;
</file>

<file path="src/components/Client/ProfileForm.tsx">
import React, { useState, useEffect, useContext } from 'react';
import { useNavigate } from 'react-router-dom';
import { supabase } from '../../services/supabaseClient';
import { AuthContext } from '../../context/AuthContext';

interface KYCData {
  date_of_birth: string;
  address_line1: string;
  address_line2: string;
  city: string;
  postal_code: string;
  country: string;
  phone_number: string;
  national_insurance_number: string;
}

const ProfileForm: React.FC = () => {
  const navigate = useNavigate();
  const { user } = useContext(AuthContext);
  const [kycData, setKycData] = useState<KYCData>({
    date_of_birth: '',
    address_line1: '',
    address_line2: '',
    city: '',
    postal_code: '',
    country: 'United Kingdom',
    phone_number: '',
    national_insurance_number: ''
  });
  const [isSaving, setIsSaving] = useState(false);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const fetchKYCData = async () => {
      if (!user) return;

      try {
        const { data, error } = await supabase
          .from('kyc_data')
          .select('*')
          .eq('profile_id', user.id)
          .single();

        if (error && error.code !== 'PGRST116') throw error;
        if (data) setKycData(data);
      } catch (err) {
        console.error('Error fetching KYC data:', err);
      } finally {
        setIsLoading(false);
      }
    };

    fetchKYCData();
  }, [user]);

  const handleChange = (field: keyof KYCData, value: string) => {
    setKycData(prev => ({ ...prev, [field]: value }));
  };

  const handleSubmit = async () => {
    if (!user) return;

    setIsSaving(true);
    try {
      const { error } = await supabase
        .from('kyc_data')
        .upsert({
          profile_id: user.id,
          ...kycData
        });

      if (error) throw error;

      alert('Profile updated successfully');
      navigate('/client/client-dashboard');
    } catch (err) {
      console.error('Error updating profile:', err);
      alert('Failed to update profile. Please try again.');
    } finally {
      setIsSaving(false);
    }
  };

  if (isLoading) {
    return <div>Loading profile...</div>;
  }

  return (
    <div className="container mx-auto max-w-lg p-6 bg-gray-800 rounded-lg shadow-md">
      <h1 className="text-2xl font-semibold text-gray-100 mb-4">Your Profile</h1>
      <form className="space-y-4">
        <div>
          <label className="block text-sm font-medium text-gray-300">Date of Birth</label>
          <input
            type="date"
            value={kycData.date_of_birth}
            onChange={(e) => handleChange('date_of_birth', e.target.value)}
            className="w-full px-4 py-2 bg-gray-600 text-gray-100 border border-gray-500 rounded-lg focus:ring-2 focus:ring-blue-500 focus:outline-none"
          />
        </div>

        <div>
          <label className="block text-sm font-medium text-gray-300">Address Line 1</label>
          <input
            type="text"
            value={kycData.address_line1}
            onChange={(e) => handleChange('address_line1', e.target.value)}
            className="w-full px-4 py-2 bg-gray-600 text-gray-100 border border-gray-500 rounded-lg focus:ring-2 focus:ring-blue-500 focus:outline-none"
          />
        </div>

        <div>
          <label className="block text-sm font-medium text-gray-300">Address Line 2</label>
          <input
            type="text"
            value={kycData.address_line2}
            onChange={(e) => handleChange('address_line2', e.target.value)}
            className="w-full px-4 py-2 bg-gray-600 text-gray-100 border border-gray-500 rounded-lg focus:ring-2 focus:ring-blue-500 focus:outline-none"
          />
        </div>

        <div>
          <label className="block text-sm font-medium text-gray-300">City</label>
          <input
            type="text"
            value={kycData.city}
            onChange={(e) => handleChange('city', e.target.value)}
            className="w-full px-4 py-2 bg-gray-600 text-gray-100 border border-gray-500 rounded-lg focus:ring-2 focus:ring-blue-500 focus:outline-none"
          />
        </div>

        <div>
          <label className="block text-sm font-medium text-gray-300">Postal Code</label>
          <input
            type="text"
            value={kycData.postal_code}
            onChange={(e) => handleChange('postal_code', e.target.value)}
            className="w-full px-4 py-2 bg-gray-600 text-gray-100 border border-gray-500 rounded-lg focus:ring-2 focus:ring-blue-500 focus:outline-none"
          />
        </div>

        <div>
          <label className="block text-sm font-medium text-gray-300">Phone Number</label>
          <input
            type="tel"
            value={kycData.phone_number}
            onChange={(e) => handleChange('phone_number', e.target.value)}
            className="w-full px-4 py-2 bg-gray-600 text-gray-100 border border-gray-500 rounded-lg focus:ring-2 focus:ring-blue-500 focus:outline-none"
          />
        </div>

        <div>
          <label className="block text-sm font-medium text-gray-300">National Insurance Number</label>
          <input
            type="text"
            value={kycData.national_insurance_number}
            onChange={(e) => handleChange('national_insurance_number', e.target.value)}
            className="w-full px-4 py-2 bg-gray-600 text-gray-100 border border-gray-500 rounded-lg focus:ring-2 focus:ring-blue-500 focus:outline-none"
          />
        </div>

        <div className="flex justify-between items-center">
          <button
            type="button"
            onClick={() => navigate('/client/client-dashboard')}
            className="px-4 py-2 bg-gray-600 text-gray-300 rounded-lg hover:bg-gray-500"
          >
            Back
          </button>
          <button
            type="button"
            onClick={handleSubmit}
            disabled={isSaving}
            className={`px-6 py-2 text-sm font-medium rounded-lg focus:outline-none ${
              isSaving
                ? 'bg-gray-500 text-gray-400 cursor-not-allowed'
                : 'bg-blue-500 text-gray-100 hover:bg-blue-600'
            }`}
          >
            {isSaving ? 'Saving...' : 'Save Changes'}
          </button>
        </div>
      </form>
    </div>
  );
};

export default ProfileForm;
</file>

<file path="src/components/Common/Documents/ClientDocumentList.tsx">
// src/components/Common/Documents/ClientDocumentsList.tsx
import React, { useState, useEffect } from 'react';
import { supabase } from '../../../services/supabaseClient';
import { File, FileText, Image, PenTool, AlertTriangle, CheckCircle, Eye, Trash2, ArrowUpRight } from 'lucide-react';
import { Link } from 'react-router-dom';
import { ClientDocument } from '../../../@types/documents';



interface ClientDocumentsListProps {
  clientId: string;
  compact?: boolean;
  limit?: number;
  showActions?: boolean;
  className?: string;
  onViewAll?: () => void;
}

const ClientDocumentsList: React.FC<ClientDocumentsListProps> = ({
  clientId,
  compact = false,
  limit = 5,
  showActions = true,
  className = '',
  onViewAll
}) => {
  const [documents, setDocuments] = useState<ClientDocument[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetchDocuments();
  }, [clientId]);

  const fetchDocuments = async () => {
    try {
      setLoading(true);
      setError(null);

      const { data, error } = await supabase
        .from('client_documents')
        .select('*')
        .eq('client_id', clientId)
        .order('upload_date', { ascending: false })
        .limit(limit);

      if (error) throw error;

      setDocuments(data || []);
    } catch (err) {
      console.error('Error fetching documents:', err);
      setError('Failed to load documents');
    } finally {
      setLoading(false);
    }
  };

  const handleDeleteDocument = async (docId: string) => {
    if (!window.confirm('Are you sure you want to delete this document?')) return;

    try {
      // Find the document to get its file path
      const doc = documents.find((d) => d.id === docId);
      
      if (!doc) return;
      
      // First delete the file from storage
      const { error: storageError } = await supabase.storage
        .from('documents')
        .remove([doc.file_path]);
      
      if (storageError) throw storageError;
      
      // Then delete the record from the database
      const { error: dbError } = await supabase
        .from('client_documents')
        .delete()
        .eq('id', docId);
      
      if (dbError) throw dbError;
      
      // Update state
      setDocuments(documents.filter((d) => d.id !== docId));
      
    } catch (error) {
      console.error('Error deleting document:', error);
      alert('Failed to delete document');
    }
  };

  const getFileIcon = (fileType: string) => {
    const lowerType = fileType.toLowerCase();
    
    if (['jpg', 'jpeg', 'png', 'gif'].includes(lowerType)) {
      return <Image className="h-4 w-4 text-purple-500" />;
    } else if (lowerType === 'pdf') {
      return <FileText className="h-4 w-4 text-red-500" />;
    } else if (['doc', 'docx'].includes(lowerType)) {
      return <FileText className="h-4 w-4 text-blue-600" />;
    } else if (['xls', 'xlsx', 'csv'].includes(lowerType)) {
      return <FileText className="h-4 w-4 text-green-600" />;
    } else {
      return <File className="h-4 w-4 text-gray-500" />;
    }
  };

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString('en-GB', {
      day: '2-digit',
      month: 'short',
      year: 'numeric',
    });
  };

  const getDocumentTypeLabel = (type?: string) => {
    if (!type) return 'Unknown';
    
    return type
      .split('_')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
  };

  if (loading) {
    return (
      <div className={`bg-white rounded-lg shadow ${className} p-4`}>
        <div className="flex items-center justify-center h-24">
          <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-500"></div>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className={`bg-white rounded-lg shadow ${className} p-4`}>
        <div className="p-3 bg-red-50 border border-red-200 rounded-lg text-red-700 flex items-center">
          <AlertTriangle className="h-5 w-5 mr-2 flex-shrink-0" />
          <span>{error}</span>
        </div>
      </div>
    );
  }

  if (documents.length === 0) {
    return (
      <div className={`bg-white rounded-lg shadow ${className} p-4`}>
        <h3 className="text-lg font-semibold mb-2">Documents</h3>
        <div className="text-center py-6 border-2 border-dashed rounded-lg">
          <p className="text-gray-500">No documents uploaded yet</p>
        </div>
      </div>
    );
  }

  return (
    <div className={`bg-white rounded-lg shadow ${className}`}>
      <div className="flex items-center justify-between p-4 border-b">
        <h3 className="text-lg font-semibold">Documents</h3>
        {onViewAll && documents.length > 0 && (
          <button 
            onClick={onViewAll}
            className="text-sm text-blue-600 hover:text-blue-800 flex items-center"
          >
            View All <ArrowUpRight className="ml-1 h-3 w-3" />
          </button>
        )}
      </div>

      <div className="divide-y">
        {documents.map((doc) => (
          <div key={doc.id} className={`${compact ? 'p-2' : 'p-4'} hover:bg-gray-50`}>
            <div className="flex items-center justify-between">
              <div className="flex items-center min-w-0">
                {getFileIcon(doc.file_type)}
                <div className={`ml-3 ${compact ? 'truncate' : ''}`}>
                  <p className={`font-medium text-gray-800 ${compact ? 'text-sm' : ''} truncate`}>{doc.file_name}</p>
                  <div className="flex items-center mt-1">
                    {!compact && (
                      <span className="text-xs text-gray-500 mr-2">
                        {formatDate(doc.upload_date)}
                      </span>
                    )}
                    {doc.document_type && (
                      <span className="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800">
                        {getDocumentTypeLabel(doc.document_type)}
                      </span>
                    )}
                    {doc.processed && (
                      <span className="ml-2 inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-green-100 text-green-800">
                        <CheckCircle className="mr-1 h-3 w-3" /> Processed
                      </span>
                    )}
                  </div>
                </div>
              </div>

              {showActions && (
                <div className="flex space-x-2 ml-2">
                  <a 
                    href={doc.file_url}
                    target="_blank" 
                    rel="noopener noreferrer"
                    className="text-blue-600 hover:text-blue-800"
                    title="View document"
                  >
                    <Eye className="h-4 w-4" />
                  </a>
                  <button
                    onClick={() => handleDeleteDocument(doc.id)}
                    className="text-red-600 hover:text-red-800"
                    title="Delete document"
                  >
                    <Trash2 className="h-4 w-4" />
                  </button>
                </div>
              )}
            </div>
          </div>
        ))}
      </div>

      {onViewAll && documents.length > 0 && (
        <div className="p-2 border-t text-center">
          <button 
            onClick={onViewAll}
            className="text-sm text-blue-600 hover:text-blue-800"
          >
            View All Documents
          </button>
        </div>
      )}
    </div>
  );
};

export default ClientDocumentsList;
</file>

<file path="src/components/Common/Documents/DocumentDetails.tsx">
// src/components/Common/Documents/DocumentDetails.tsx
import React from 'react';
import { ClientDocument } from '../../../@types/documents';
import { Transaction } from '../../../@types/transactions';

interface DocumentDetailsProps {
  document: ClientDocument;
  onApplyData: (id: string) => void;
}

const DocumentDetails: React.FC<DocumentDetailsProps> = ({ document, onApplyData }) => {
  return (
    <div className="mt-8 bg-white p-6 rounded-lg shadow-md">
      <h2 className="text-xl font-bold mb-4">Document Analysis</h2>
      
      <div className="flex items-center gap-2 mb-4">
        <span className="font-medium">Document:</span>
        <span className="text-gray-700">{document.file_name}</span>
        <span className="inline-flex items-center px-2 py-0.5 ml-2 rounded text-xs font-medium bg-green-100 text-green-800">
          {document.document_type?.replace('_', ' ').replace(/\b\w/g, (l: string) => l.toUpperCase()) || 'Processed'}
        </span>
      </div>
      
      <div className="border-t border-gray-200 pt-4">
        <h3 className="text-lg font-semibold mb-3">Extracted Information</h3>
        
        <div className="grid md:grid-cols-2 gap-6">
          {/* Left Column: Basic Information */}
          <div className="space-y-4">
          {(document.extracted_data?.addresses?.length ?? 0) > 0 && (
            <div>
                <h4 className="font-medium text-gray-700 mb-2">Addresses</h4>
                <ul className="list-disc pl-5 space-y-1">
                {(document.extracted_data?.addresses ?? []).map((addr: string, idx: number) => (
                    <li key={idx} className="text-gray-600">{addr}</li>
                ))}
                </ul>
            </div>
            )}

            {(document.extracted_data?.postcodes?.length ?? 0) > 0 && (
              <div>
                <h4 className="font-medium text-gray-700 mb-2">Postcodes</h4>
                <div className="flex flex-wrap gap-2">
                  {(document.extracted_data?.postcodes ?? []).map((postcode: string, idx: number) => (
                    <span key={idx} className="px-2 py-1 bg-gray-100 rounded text-sm">{postcode}</span>
                  ))}
                </div>
              </div>
            )}

            {(document.extracted_data?.phoneNumbers?.length ?? 0) > 0 && (
              <div>
                <h4 className="font-medium text-gray-700 mb-2">Phone Numbers</h4>
                <div className="flex flex-wrap gap-2">
                  {document.extracted_data?.phoneNumbers?.map((phone: string, idx: number) => (
                    <span key={idx} className="px-2 py-1 bg-gray-100 rounded text-sm">{phone}</span>
                  )) ?? []}
                </div>
              </div>
            )}
          </div>
          
          {/* Right Column: Financial Information */}
          <div className="space-y-4">
            {(document.extracted_data?.emails?.length ?? 0) > 0 && (
              <div>
                <h4 className="font-medium text-gray-700 mb-2">Email Addresses</h4>
                <div className="flex flex-wrap gap-2">
                  {document.extracted_data?.emails?.map((email: string, idx: number) => (
                    <span key={idx} className="px-2 py-1 bg-gray-100 rounded text-sm">{email}</span>
                  )) ?? []}
                </div>
              </div>
            )}

            {(document.extracted_data?.monetaryValues?.length ?? 0) > 0 && (
              <div>
                <h4 className="font-medium text-gray-700 mb-2">Monetary Values</h4>
                <div className="flex flex-wrap gap-2">
                  {document.extracted_data?.monetaryValues?.map((value: string, idx: number) => (
                    <span key={idx} className="px-2 py-1 bg-gray-100 rounded text-sm">{value}</span>
                  )) ?? []}
                </div>
              </div>
            )}

            {/* Bank Statement Specific Data */}
            {document.document_type === 'bank_statement' && document.extracted_data?.accountNumber && (
              <div>
                <h4 className="font-medium text-gray-700 mb-2">Bank Account Details</h4>
                <div className="space-y-1">
                  {document.extracted_data?.accountNumber && (
                    <p className="text-sm">Account Number: <span className="font-medium">{document.extracted_data?.accountNumber}</span></p>
                  )}
                  {document.extracted_data?.sortCode && (
                    <p className="text-sm">Sort Code: <span className="font-medium">{document.extracted_data?.sortCode}</span></p>
                  )}
                </div>
              </div>
            )}

            {/* Investment Details */}
            {document.document_type === 'investment_statement' && document.extracted_data?.portfolioValue && (
              <div>
                <h4 className="font-medium text-gray-700 mb-2">Investment Details</h4>
                <p className="text-sm mb-1">Portfolio Value: <span className="font-medium">£{document.extracted_data?.portfolioValue}</span></p>
              </div>
            )}
          </div>
        </div>
        
        {/* Transactions Table (for Bank Statements) */}
        {document.document_type === 'bank_statement' &&
         document.extracted_data?.transactions &&
         document.extracted_data?.transactions.length > 0 && (
          <div className="mt-6">
            <h4 className="font-medium text-gray-700 mb-2">Transactions</h4>
            <div className="overflow-x-auto">
              <table className="min-w-full divide-y divide-gray-200">
                <thead className="bg-gray-50">
                  <tr>
                    <th className="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Date</th>
                    <th className="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Description</th>
                    <th className="px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">Amount</th>
                    <th className="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Type</th>
                  </tr>
                </thead>
                <tbody className="bg-white divide-y divide-gray-200">
                  {document.extracted_data?.transactions.slice(0, 10).map((transaction: Transaction, idx: number) => (
                    <tr key={idx} className={transaction.type === 'credit' ? 'text-green-700' : 'text-red-700'}>
                      <td className="px-4 py-2 text-sm">{transaction.date}</td>
                      <td className="px-4 py-2 text-sm">{transaction.description}</td>
                      <td className="px-4 py-2 text-sm text-right">
                        {transaction.amount < 0 ? '-' : ''}£{Math.abs(transaction.amount).toFixed(2)}
                      </td>
                      <td className="px-4 py-2 text-sm capitalize">{transaction.type}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
              {document.extracted_data?.transactions.length > 10 && (
                <p className="text-right text-sm text-gray-500 mt-2">
                  Showing 10 of {document.extracted_data?.transactions.length} transactions
                </p>
              )}
            </div>
          </div>
        )}
        
        <div className="mt-6 flex justify-end">
          <button
            onClick={() => onApplyData(document.id)}
            className="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700"
          >
            Apply Data to Client Profile
          </button>
        </div>
      </div>
    </div>
  );
};

export default DocumentDetails;
</file>

<file path="src/components/Common/Documents/DocumentList.tsx">
// src/components/Common/Documents/DocumentList.tsx
import React, { useState, useEffect, useContext } from 'react';
import { useNavigate } from 'react-router-dom';
import { AuthContext } from '../../../context/AuthContext';
import { supabase } from '../../../services/supabaseClient';
import { FileText, Eye, Download, BarChart2, Trash2, AlertCircle, CheckCircle, Loader2, FileCheck } from 'lucide-react';
import { ClientDocument, DocumentType, Transaction, DocumentListProps } from '../../../@types/documents';

const DocumentList: React.FC<DocumentListProps> = ({
  clientId,
  showExtractedData = true,
  onSelectDocument,
  adviserMode = false,
  limit = 10,
  className = '',
}) => {
  const { user } = useContext(AuthContext);
  const navigate = useNavigate();
  const [documents, setDocuments] = useState<ClientDocument[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [signedUrls, setSignedUrls] = useState<Record<string, string>>({});
  const [deletingId, setDeletingId] = useState<string | null>(null);
  const [processingId, setProcessingId] = useState<string | null>(null);
  const [searchTerm, setSearchTerm] = useState('');
  const [sortBy, setSortBy] = useState<'date' | 'name' | 'type'>('date');
  const [sortDirection, setSortDirection] = useState<'asc' | 'desc'>('desc');
  const [selectedDocId, setSelectedDocId] = useState<string | null>(null);
  
  useEffect(() => {
    fetchDocuments();
  }, [clientId, user?.id]);
  
  const fetchDocuments = async () => {
    setIsLoading(true);
    setError(null);
    
    try {
      // Determine which client ID to use
      const targetClientId = clientId || user?.id;
      
      if (!targetClientId) {
        throw new Error('No client ID available');
      }
      
      const { data, error } = await supabase
        .from('client_documents')
        .select('*')
        .eq('client_id', targetClientId)
        .order('upload_date', { ascending: false })
        .limit(limit);
      
      if (error) throw error;
      
      if (data) {
        setDocuments(data);
        
        // Generate signed URLs for each document
        const urls: Record<string, string> = {};
        for (const doc of data) {
          if (doc.file_path) {
            try {
              const { data: urlData, error: urlError } = await supabase.storage
                .from('documents')
                .createSignedUrl(doc.file_path, 3600); // 1 hour expiry
              
              if (!urlError && urlData?.signedUrl) {
                urls[doc.id] = urlData.signedUrl;
              } else {
                console.warn(`Failed to get URL for ${doc.file_name}:`, urlError?.message);
              }
            } catch (err) {
              console.error(`Error getting URL for ${doc.file_name}:`, err);
            }
          }
        }
        setSignedUrls(urls);
      }
    } catch (error) {
      console.error('Error fetching documents:', error);
      setError(error instanceof Error ? error.message : 'Failed to load documents');
    } finally {
      setIsLoading(false);
    }
  };
  
  // Filter and sort documents
  const filteredDocuments = documents
    .filter(doc => {
      if (searchTerm === '') return true;
      
      const searchLower = searchTerm.toLowerCase();
      return (
        doc.file_name.toLowerCase().includes(searchLower) ||
        (doc.document_type || '').toLowerCase().includes(searchLower)
      );
    })
    .sort((a, b) => {
      if (sortBy === 'date') {
        const dateA = new Date(a.upload_date).getTime();
        const dateB = new Date(b.upload_date).getTime();
        return sortDirection === 'asc' ? dateA - dateB : dateB - dateA;
      }
      
      if (sortBy === 'name') {
        return sortDirection === 'asc'
          ? a.file_name.localeCompare(b.file_name)
          : b.file_name.localeCompare(a.file_name);
      }
      
      if (sortBy === 'type') {
        const typeA = a.document_type || '';
        const typeB = b.document_type || '';
        return sortDirection === 'asc'
          ? typeA.localeCompare(typeB)
          : typeB.localeCompare(typeA);
      }
      
      return 0;
    });
  
  const handleDeleteDocument = async (docId: string) => {
    if (!window.confirm('Are you sure you want to delete this document?')) {
      return;
    }
    
    try {
      setDeletingId(docId);
      
      // Find the document to get its file path
      const doc = documents.find((d) => d.id === docId);
      
      if (!doc) return;
      
      // First delete the file from storage
      if (doc.file_path) {
        const { error: storageError } = await supabase.storage
          .from('documents')
          .remove([doc.file_path]);
        
        if (storageError) {
          console.error('Storage delete error:', storageError);
          // Continue anyway to ensure DB record is removed
        }
      }
      
      // Then delete the record from the database
      const { error: dbError } = await supabase
        .from('client_documents')
        .delete()
        .eq('id', docId);
      
      if (dbError) throw dbError;
      
      // Update state
      setDocuments(documents.filter((d) => d.id !== docId));
      
      // Clear selection if the deleted document was selected
      if (selectedDocId === docId) {
        setSelectedDocId(null);
      }
      
      // Remove signed URL
      if (signedUrls[docId]) {
        const newUrls = { ...signedUrls };
        delete newUrls[docId];
        setSignedUrls(newUrls);
      }
    } catch (error) {
      console.error('Error deleting document:', error);
      alert('Failed to delete document');
    } finally {
      setDeletingId(null);
    }
  };
  
  const handleProcessDocument = async (docId: string) => {
    try {
      setProcessingId(docId);
      
      const doc = documents.find((d) => d.id === docId);
      
      if (!doc) return;
      
      // Call serverless function to process document
      const response = await fetch('/.netlify/functions/process-document', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          documentId: docId,
          clientId: doc.client_id,
          filePath: doc.file_path,
        }),
      });
      
      if (!response.ok) {
        throw new Error(`Processing failed: ${response.statusText}`);
      }
      
      const result = await response.json();
      
      if (result.error) {
        throw new Error(result.error);
      }
      
      // Update the document in the UI
      setDocuments((docs) =>
        docs.map((d) => {
          if (d.id === docId) {
            return {
              ...d,
              processed: true,
              processed_date: new Date().toISOString(),
              document_type: result.documentType,
              extracted_data: result.extractedData,
            };
          }
          return d;
        })
      );
      
      // If the processed document was selected, update the selection to show new data
      if (selectedDocId === docId && onSelectDocument) {
        const updatedDoc = documents.find(d => d.id === docId);
        if (updatedDoc) {
          onSelectDocument({
            ...updatedDoc,
            processed: true,
            processed_date: new Date().toISOString(),
            document_type: result.documentType,
            extracted_data: result.extractedData,
            signedUrl: signedUrls[docId]
          });
        }
      }
    } catch (error) {
      console.error('Error processing document:', error);
      alert('Failed to process document');
    } finally {
      setProcessingId(null);
    }
  };
  
  const handleApplyData = async (docId: string) => {
    try {
      const doc = documents.find((d) => d.id === docId);
      if (!doc || !doc.extracted_data) return;
      
      // Call function to apply extracted data to client profile
      const response = await fetch('/.netlify/functions/apply-extracted-data', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          clientId: doc.client_id,
          documentId: docId,
          extractedData: doc.extracted_data,
          documentType: doc.document_type
        }),
      });
      
      if (!response.ok) {
        throw new Error(`Failed to apply data: ${response.statusText}`);
      }
      
      const result = await response.json();
      
      if (result.error) {
        throw new Error(result.error);
      }
      
      alert('Document data applied to client profile successfully');
    } catch (error) {
      console.error('Error applying data:', error);
      alert('Failed to apply document data');
    }
  };
  
  const handleViewDocument = (document: ClientDocument) => {
    const url = signedUrls[document.id];
    if (url) {
      window.open(url, '_blank');
    } else if (document.file_path) {
      // If URL not in state, try to generate it on-demand
      const generateAndOpenUrl = async () => {
        try {
          const { data, error } = await supabase.storage
            .from('documents')
            .createSignedUrl(document.file_path, 3600);
            
          if (error) throw error;
          
          if (data?.signedUrl) {
            // Save for future reference
            setSignedUrls(prev => ({
              ...prev,
              [document.id]: data.signedUrl
            }));
            // Open in new tab
            window.open(data.signedUrl, '_blank');
          }
        } catch (err) {
          console.error('Error generating signed URL:', err);
          alert('Unable to view document at this time');
        }
      };
      
      generateAndOpenUrl();
    }
  };
  
  const handleSelectDocument = (document: ClientDocument) => {
    setSelectedDocId(document.id);
    
    if (onSelectDocument) {
      onSelectDocument({
        ...document,
        signedUrl: signedUrls[document.id]
      });
    }
  };
  
  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString(undefined, {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
    });
  };
  
  const getDocumentTypeLabel = (type?: DocumentType) => {
    switch (type) {
      case 'bank_statement':
        return 'Bank Statement';
      case 'investment_statement':
        return 'Investment Statement';
      case 'utility_bill':
        return 'Utility Bill';
      case 'identity_document':
        return 'ID Document';
      case 'tax_return':
        return 'Tax Return';
      case 'payslip':
        return 'Payslip';
      case 'pension_statement':
        return 'Pension Statement';
      case 'insurance_policy':
        return 'Insurance Policy';
      case 'mortgage_statement':
        return 'Mortgage Statement';
      case 'credit_report':
        return 'Credit Report';
      default:
        return 'Document';
    }
  };
  
  const getFileIcon = (fileType: string) => {
    const lowerType = fileType.toLowerCase();
    
    if (['.jpg', '.jpeg', '.png', '.gif', 'jpg', 'jpeg', 'png', 'gif'].some(ext => lowerType.includes(ext))) {
      return (
        <svg
          className="w-6 h-6 text-blue-500"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v14a2 2 0 002 2z"
          />
        </svg>
      );
    } else if (lowerType.includes('pdf')) {
      return (
        <svg
          className="w-6 h-6 text-red-500"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
          />
        </svg>
      );
    } else if (['doc', 'docx'].some(ext => lowerType.includes(ext))) {
      return (
        <svg
          className="w-6 h-6 text-blue-600"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
          />
        </svg>
      );
    } else {
      return (
        <svg
          className="w-6 h-6 text-gray-500"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z"
          />
        </svg>
      );
    }
  };
  
  if (isLoading) {
    return (
      <div className={`p-6 bg-white rounded-lg shadow-md ${className}`}>
        <div className="flex justify-center items-center h-40">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
        </div>
      </div>
    );
  }
  
  if (error) {
    return (
      <div className={`p-6 bg-white rounded-lg shadow-md ${className}`}>
        <div className="p-4 bg-red-50 border border-red-200 rounded-lg text-red-700">
          {error}
        </div>
      </div>
    );
  }
  
  return (
    <div className={`p-6 bg-white rounded-lg shadow-md ${className}`}>
      <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-6 gap-4">
        <h3 className="text-xl font-semibold">Documents</h3>
        
        <div className="flex flex-col sm:flex-row gap-2 w-full sm:w-auto">
          <input
            type="text"
            placeholder="Search documents..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="px-3 py-2 border border-gray-300 rounded-md"
          />
          
          <div className="flex">
            <select
              value={sortBy}
              onChange={(e) => setSortBy(e.target.value as any)}
              className="px-3 py-2 border border-gray-300 rounded-l-md"
            >
              <option value="date">Date</option>
              <option value="name">Name</option>
              <option value="type">Type</option>
            </select>
            
            <button
              onClick={() => setSortDirection(prev => prev === 'asc' ? 'desc' : 'asc')}
              className="px-3 py-2 border border-l-0 border-gray-300 bg-gray-50 rounded-r-md"
            >
              {sortDirection === 'asc' ? '↑' : '↓'}
            </button>
          </div>
        </div>
      </div>
      
      {filteredDocuments.length === 0 ? (
        <div className="text-center py-8 border-2 border-dashed rounded-lg">
          <p className="text-gray-500">
            {searchTerm ? 'No matching documents found' : 'No documents uploaded yet'}
          </p>
        </div>
      ) : (
        <div className="grid md:grid-cols-1 gap-6">
          {/* Document list */}
          <div className="border rounded-lg overflow-hidden">
            <h4 className="p-3 bg-gray-50 border-b font-medium">Uploaded Files</h4>
            <div className="divide-y max-h-[600px] overflow-y-auto">
              {filteredDocuments.map((doc) => (
                <div 
                  key={doc.id}
                  className={`p-4 hover:bg-gray-50 cursor-pointer transition ${selectedDocId === doc.id ? 'bg-blue-50' : ''}`}
                  onClick={() => handleSelectDocument(doc)}
                >
                  <div className="flex items-start">
                    <div className="mr-3">
                      {getFileIcon(doc.file_type)}
                    </div>
                    <div className="flex-1 min-w-0">
                      <p className="font-medium text-gray-800 truncate">{doc.file_name}</p>
                      <p className="text-sm text-gray-500">{formatDate(doc.upload_date)}</p>
                      <div className="flex items-center mt-1">
                        {doc.processed ? (
                          <span className="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-green-100 text-green-800">
                            {doc.document_type ? getDocumentTypeLabel(doc.document_type) : 'Processed'}
                          </span>
                        ) : (
                          <span className="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-gray-100 text-gray-800">
                            Not Processed
                          </span>
                        )}
                      </div>
                    </div>
                    <div className="ml-2 flex-shrink-0 flex flex-col space-y-2">
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          handleViewDocument(doc);
                        }}
                        className="text-sm text-blue-600 hover:text-blue-800 flex items-center"
                      >
                        <Eye className="w-4 h-4 mr-1" /> View
                      </button>
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          handleDeleteDocument(doc.id);
                        }}
                        className={`text-sm text-red-600 hover:text-red-800 flex items-center ${
                          deletingId === doc.id ? 'opacity-50 cursor-not-allowed' : ''
                        }`}
                        disabled={deletingId === doc.id}
                      >
                        {deletingId === doc.id ? (
                          <Loader2 className="w-4 h-4 mr-1 animate-spin" />
                        ) : (
                          <Trash2 className="w-4 h-4 mr-1" />
                        )}
                        Delete
                      </button>
                    </div>
                  </div>
                  
                  <div className="mt-3 flex justify-end space-x-2">
                    {!doc.processed && (
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          handleProcessDocument(doc.id);
                        }}
                        className={`text-xs px-2 py-1 bg-blue-600 text-white rounded hover:bg-blue-700 flex items-center ${
                          processingId === doc.id ? 'opacity-50 cursor-wait' : ''
                        }`}
                        disabled={processingId === doc.id}
                      >
                        {processingId === doc.id ? (
                          <>
                            <Loader2 className="w-3 h-3 mr-1 animate-spin" />
                            Processing...
                          </>
                        ) : (
                          <>
                            <FileCheck className="w-3 h-3 mr-1" />
                            Process Document
                          </>
                        )}
                      </button>
                    )}
                    
                    {doc.processed && doc.extracted_data && (
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          handleApplyData(doc.id);
                        }}
                        className="text-xs px-2 py-1 bg-green-600 text-white rounded hover:bg-green-700 flex items-center"
                      >
                        <CheckCircle className="w-3 h-3 mr-1" />
                        Apply to Profile
                      </button>
                    )}
                    
                    {adviserMode && doc.processed && (
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          // Navigate to insights or analysis page
                          navigate(`/adviser/document/${doc.id}/insights`);
                        }}
                        className="text-xs px-2 py-1 bg-indigo-600 text-white rounded hover:bg-indigo-700 flex items-center"
                      >
                        <BarChart2 className="w-3 h-3 mr-1" />
                        View Insights
                      </button>
                    )}
                  </div>
                </div>
              ))}
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default DocumentList;
</file>

<file path="src/components/Common/Documents/DocumentUpload.tsx">
// src/components/Common/Documents/EnhancedDocumentUpload.tsx
import React, { useState, useRef, useContext } from 'react';
import { AuthContext } from '../../../context/AuthContext';
import { supabase } from '../../../services/supabaseClient';
import { UploadCloud, X, AlertCircle, CheckCircle, Loader2, File, Upload } from 'lucide-react';


export interface DocumentUploadProps {
  onUploadSuccess: (url: string, fileType: string, fileName: string) => void;
  allowedFileTypes?: string[];
  maxFileSizeMB?: number;
  bucketName?: string;
  clientId?: string;
  adviserMode?: boolean;
  className?: string;
}

const DocumentUpload: React.FC<DocumentUploadProps> = ({
  onUploadSuccess,
  allowedFileTypes = ['.pdf', '.jpg', '.jpeg', '.png', '.doc', '.docx', '.csv', '.xls', '.xlsx'],
  maxFileSizeMB = 10,
  bucketName = 'documents',
  clientId,
  adviserMode = false,
  className = '',
}) => {
  const { user } = useContext(AuthContext);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [file, setFile] = useState<File | null>(null);
  const [isUploading, setIsUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  const [error, setError] = useState<string | null>(null);
  const [documentType, setDocumentType] = useState<string>('');
  const [documentNote, setDocumentNote] = useState<string>('');
  
  const financialDocumentTypes = [
    { value: 'bank_statement', label: 'Bank Statement' },
    { value: 'investment_statement', label: 'Investment Statement' },
    { value: 'utility_bill', label: 'Utility Bill' },
    { value: 'identity_document', label: 'ID Document' },
    { value: 'tax_return', label: 'Tax Return' },
    { value: 'payslip', label: 'Payslip' },
    { value: 'pension_statement', label: 'Pension Statement' },
    { value: 'insurance_policy', label: 'Insurance Policy' },
    { value: 'mortgage_statement', label: 'Mortgage Statement' },
    { value: 'credit_report', label: 'Credit Report' },
    { value: 'other', label: 'Other Document' }
  ];
  
  const handleFileDrop = (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();
    
    if (e.dataTransfer.files && e.dataTransfer.files[0]) {
      validateAndSetFile(e.dataTransfer.files[0]);
    }
  };
  
  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files[0]) {
      validateAndSetFile(e.target.files[0]);
    }
  };
  
  const validateAndSetFile = (file: File) => {
    setError(null);
    
    // Check file type
    const fileExtension = `.${file.name.split('.').pop()?.toLowerCase()}`;
    if (!allowedFileTypes.includes(fileExtension)) {
      setError(`Invalid file type. Allowed types: ${allowedFileTypes.join(', ')}`);
      return;
    }
    
    // Check file size
    const fileSizeMB = file.size / (1024 * 1024);
    if (fileSizeMB > maxFileSizeMB) {
      setError(`File size exceeds ${maxFileSizeMB}MB limit`);
      return;
    }
    
    setFile(file);
  };
  
  const clearFile = () => {
    setFile(null);
    setDocumentType('');
    setDocumentNote('');
    setError(null);
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  const simulateProgress = () => {
    // Simulate upload progress for better UX
    const timer = setInterval(() => {
      setUploadProgress((prev) => {
        if (prev >= 90) {
          clearInterval(timer);
          return prev;
        }
        return prev + 10;
      });
    }, 300);

    return () => clearInterval(timer);
  };
  
  const uploadFile = async () => {
    if (!file || !user) return;
    
    // Validate document type selection
    if (!documentType) {
      setError('Please select a document type');
      return;
    }
    
    try {
      setIsUploading(true);
      setUploadProgress(0);
      setError(null);
      
      // Start simulated progress
      const stopSimulation = simulateProgress();
      
      // Determine the client ID to use
      const targetClientId = adviserMode && clientId ? clientId : user.id;
      
      // Create a unique file path including client ID for better organization
      const fileExtension = file.name.split('.').pop() || '';
      const timestamp = new Date().getTime();
      const sanitizedFileName = file.name.replace(/[^a-z0-9.]/gi, '_').toLowerCase();
      const filePath = `${targetClientId}/${timestamp}_${sanitizedFileName}`;
      
      // Upload file to Supabase Storage
      const { data, error: uploadError } = await supabase.storage
        .from(bucketName)
        .upload(filePath, file, {
          cacheControl: '3600',
          upsert: false
        });
      
      if (uploadError) throw uploadError;
      
      // Stop simulated progress
      stopSimulation();
      setUploadProgress(95);
      
      // Get the public URL for the uploaded file
      const { data: { publicUrl } } = supabase.storage
        .from(bucketName)
        .getPublicUrl(filePath);
      
      // Record the file in the client_documents table 
      const { error: dbError } = await supabase
        .from('client_documents')
        .insert({
          client_id: targetClientId,
          file_name: file.name,
          file_type: fileExtension,
          file_path: filePath,
          file_url: publicUrl,
          upload_date: new Date().toISOString(),
          uploaded_by: user.id,
          processed: false,
          document_type: documentType,
          notes: documentNote || null
        });
      
      if (dbError) throw dbError;
      
      // Complete the progress
      setUploadProgress(100);
      
      // Notify parent component of successful upload
      if (onUploadSuccess) {
        onUploadSuccess(publicUrl, fileExtension, file.name);
      }
      
      // Clear the form after a short delay
      setTimeout(() => {
        setIsUploading(false);
        clearFile();
      }, 1000);
      
    } catch (error) {
      setIsUploading(false);
      console.error('Upload error:', error);
      setError(error instanceof Error ? error.message : 'Failed to upload file');
    }
  };

  const displayFileSize = (size: number) => {
    if (size < 1024) {
      return `${size} B`;
    } else if (size < 1024 * 1024) {
      return `${(size / 1024).toFixed(1)} KB`;
    } else {
      return `${(size / (1024 * 1024)).toFixed(2)} MB`;
    }
  };

  const getFileIcon = (fileName: string) => {
    const extension = fileName.split('.').pop()?.toLowerCase();
    
    switch (extension) {
      case 'pdf':
        return <File className="h-6 w-6 text-red-500" />;
      case 'doc':
      case 'docx':
        return <File className="h-6 w-6 text-blue-600" />;
      case 'xls':
      case 'xlsx':
      case 'csv':
        return <File className="h-6 w-6 text-green-600" />;
      case 'jpg':
      case 'jpeg':
      case 'png':
        return <File className="h-6 w-6 text-purple-500" />;
      default:
        return <File className="h-6 w-6 text-gray-500" />;
    }
  };
  
  return (
    <div className={`bg-white p-6 rounded-lg shadow-md ${className}`}>
      <h3 className="text-xl font-semibold mb-4 flex items-center">
        <UploadCloud className="mr-2 h-5 w-5" />
        Document Upload
      </h3>
      
      {/* Drop zone */}
      {!file ? (
        <div 
          className="border-2 border-dashed rounded-lg p-8 text-center mb-4 cursor-pointer
            border-gray-300 hover:border-blue-400 hover:bg-blue-50 transition-colors"
          onDragOver={(e) => e.preventDefault()}
          onDrop={handleFileDrop}
          onClick={() => fileInputRef.current?.click()}
        >
          <input
            type="file"
            ref={fileInputRef}
            onChange={handleFileChange}
            className="hidden"
            accept={allowedFileTypes.join(',')}
          />
          
          <div>
            <Upload className="w-12 h-12 text-gray-400 mx-auto mb-3" />
            <p className="text-lg text-gray-600 mb-1">Drag and drop files here</p>
            <p className="text-sm text-gray-500">or click to browse</p>
            <p className="text-xs text-gray-400 mt-2">
              Supported formats: {allowedFileTypes.join(', ')} (Max: {maxFileSizeMB}MB)
            </p>
          </div>
        </div>
      ) : (
        <div className="mb-4">
          {/* Selected file preview */}
          <div className="bg-blue-50 border border-blue-100 rounded-lg p-4 mb-4">
            <div className="flex justify-between items-start">
              <div className="flex items-center">
                {getFileIcon(file.name)}
                <div className="ml-3">
                  <p className="font-medium text-gray-800">{file.name}</p>
                  <p className="text-xs text-gray-500">{displayFileSize(file.size)}</p>
                </div>
              </div>
              <button 
                onClick={(e) => {
                  e.stopPropagation();
                  clearFile();
                }}
                className="text-gray-500 hover:text-red-500 transition-colors"
                disabled={isUploading}
              >
                <X className="h-5 w-5" />
              </button>
            </div>
          </div>
          
          {/* Document type selection */}
          <div className="mb-4">
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Document Type <span className="text-red-500">*</span>
            </label>
            <select
              value={documentType}
              onChange={(e) => setDocumentType(e.target.value)}
              className="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500"
              disabled={isUploading}
              required
            >
              <option value="">-- Select Document Type --</option>
              {financialDocumentTypes.map((type) => (
                <option key={type.value} value={type.value}>
                  {type.label}
                </option>
              ))}
            </select>
          </div>
          
          {/* Notes field */}
          <div className="mb-4">
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Notes (Optional)
            </label>
            <textarea
              value={documentNote}
              onChange={(e) => setDocumentNote(e.target.value)}
              className="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500"
              rows={3}
              placeholder="Add any relevant notes about this document"
              disabled={isUploading}
            />
          </div>
        </div>
      )}
      
      {/* Error message */}
      {error && (
        <div className="mb-4 p-3 bg-red-50 border border-red-200 rounded-lg text-red-700 flex items-center">
          <AlertCircle className="h-5 w-5 mr-2 flex-shrink-0" />
          <span>{error}</span>
        </div>
      )}
      
      {/* Upload progress */}
      {isUploading && (
        <div className="mb-4">
          <div className="flex justify-between text-sm mb-1">
            <span className="flex items-center">
              <Loader2 className="h-4 w-4 mr-2 animate-spin" />
              Uploading...
            </span>
            <span>{uploadProgress}%</span>
          </div>
          <div className="w-full h-2 bg-gray-200 rounded-full overflow-hidden">
            <div 
              className="h-2 bg-blue-600 rounded-full transition-all duration-300"
              style={{ width: `${uploadProgress}%` }}
            />
          </div>
        </div>
      )}
      
      {/* Upload success message */}
      {uploadProgress === 100 && !isUploading && (
        <div className="mb-4 p-3 bg-green-50 border border-green-200 rounded-lg text-green-700 flex items-center">
          <CheckCircle className="h-5 w-5 mr-2 flex-shrink-0" />
          <span>Document uploaded successfully!</span>
        </div>
      )}
      
      {/* Upload button */}
      {file && (
        <button
          onClick={uploadFile}
          disabled={!file || isUploading || !documentType}
          className={`w-full px-4 py-2 rounded-lg flex items-center justify-center ${
            !file || isUploading || !documentType
              ? 'bg-gray-300 cursor-not-allowed'
              : 'bg-blue-600 hover:bg-blue-700 text-white'
          }`}
        >
          {isUploading ? (
            <>
              <Loader2 className="h-5 w-5 mr-2 animate-spin" />
              Uploading...
            </>
          ) : (
            <>
              <Upload className="h-5 w-5 mr-2" />
              Upload Document
            </>
          )}
        </button>
      )}
      
      {/* Select another file button */}
      {!file && (
        <button
          onClick={() => fileInputRef.current?.click()}
          className="w-full px-4 py-2 rounded-lg bg-blue-600 hover:bg-blue-700 text-white flex items-center justify-center"
        >
          <UploadCloud className="h-5 w-5 mr-2" />
          Select Document
        </button>
      )}
    </div>
  );
};

export default DocumentUpload;
</file>

<file path="src/components/Navbar.css">
/* src/components/Navbar.css */

.navbar {
    background-color: var(--primary-color);
    padding: 10px 20px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }
  
  .navbar-container {
    display: flex;
    align-items: center;
    justify-content: space-between;
    max-width: 1200px;
    margin: 0 auto;
  }
  
  .navbar-logo {
    color: #ffffff;
    text-decoration: none;
    font-size: 24px;
    font-weight: 700;
  }
  
  .navbar-menu {
    display: flex;
    list-style: none;
    gap: 15px;
  }
  
  .navbar-item {
    display: flex;
    align-items: center;
  }
  
  .navbar-link, .navbar-button {
    color: #ffffff;
    text-decoration: none;
    font-size: 16px;
    padding: 8px 12px;
    border: none;
    background: none;
    cursor: pointer;
    transition: background-color 0.3s ease;
  }
  
  .navbar-link:hover, .navbar-button:hover {
    background-color: rgba(255, 255, 255, 0.2);
    border-radius: 5px;
  }
  
  .navbar-button {
    font: inherit;
  }
</file>

<file path="src/components/Navbar.tsx">
// src/components/Navbar.tsx

import React, { useContext } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import { AuthContext } from '../context/AuthContext';
import { supabase } from '../services/supabaseClient';
import './Navbar.css'; // We'll create this file for specific navbar styles

const Navbar: React.FC = () => {
  const { user } = useContext(AuthContext);
  const navigate = useNavigate();

  const handleSignOut = async () => {
    const { error } = await supabase.auth.signOut();
    if (error) {
      console.error('Error signing out:', error.message);
      alert('Failed to sign out. Please try again.');
    } else {
      navigate('/');
    }
  };

  return (
    <nav className="navbar">
      <div className="navbar-container">
        <Link to="/" className="navbar-logo">
          Workflow
        </Link>
        <ul className="navbar-menu">
        {user && user.user_metadata.role === 'client' && (
          <li className="navbar-item">
            <Link to="/client/client-dashboard" className="navbar-link">
              Dashboard
            </Link>
          </li>
          )}
          {user && user.user_metadata.role === 'client' && (
          <li className="navbar-item">
            <Link to="/client/profile" className="navbar-link">
              Profile
            </Link>
          </li>
          )}
          {user && user.user_metadata.role === 'client' && (
          <li className="navbar-item">
            <Link to="/chat/chat" className="navbar-link">
              Chat
            </Link>
          </li>
          )}
          {user && user.user_metadata.role === 'adviser' && (
            <li className="navbar-item">
              <Link to="/adviser/adviser-dashboard" className="navbar-link">
                Adviser
              </Link>
            </li>
          )}
          {!user ? (
            <li className="navbar-item">
              <Link to="/" className="navbar-link">
                Sign In
              </Link>
            </li>
          ) : (
            <li className="navbar-item">
              <button onClick={handleSignOut} className="navbar-button">
                Sign Out
              </button>
            </li>
          )}
          
        </ul>
      </div>
    </nav>
  );
};

export default Navbar;
</file>

<file path="src/components/ProtectedRoute.tsx">
// src/components/ProtectedRoute.tsx
import React, { useContext } from 'react';
import { Navigate } from 'react-router-dom';
import { AuthContext } from '../context/AuthContext';

interface ProtectedRouteProps {
  children: React.ReactNode; // Changed from JSX.Element to React.ReactNode
  requiredRole?: string;
}

const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children, requiredRole }) => {
  const { user } = useContext(AuthContext);

  if (!user) {
    return <Navigate to="/" replace />;
  }

  if (requiredRole && user.user_metadata.role !== requiredRole) {
    return <Navigate to="/" replace/>;
  }

  return <>{children}</>; // Use fragment to wrap children
};

export default ProtectedRoute;
</file>

<file path="src/config/openai.ts">
import OpenAI from 'openai';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export default openai;
</file>

<file path="src/context/AuthContext.tsx">
// src/context/AuthContext.tsx
import React, { createContext, useEffect, useState } from 'react';
import { supabase } from '../services/supabaseClient';
import { AuthSession, User } from '@supabase/supabase-js';

interface AuthContextProps {
    user: User | null;
    session: AuthSession | null;
    loading: boolean;
}

const initialState: AuthContextProps = {
    user: null,
    session: null,
    loading: true
};

export const AuthContext = createContext<AuthContextProps>(initialState);

export const useAuth = () => {
    const context = React.useContext(AuthContext);
    if (!context) {
        throw new Error('useAuth must be used within an AuthProvider');
    }
    return context;
};


export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const [user, setUser] = useState<User | null>(null);
    const [session, setSession] = useState<AuthSession | null>(null);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        // Try to recover session from storage
        const initializeAuth = async () => {
            try {
                // Get current session
                const { data: { session: currentSession }, error } = await supabase.auth.getSession();
                
                

                if (currentSession) {
                    setSession(currentSession);
                    setUser(currentSession.user);
                }
            } catch (error) {
                console.error('Session retrieval error:', error);
            } finally {
                setLoading(false);
            }
        };

        initializeAuth();

        // Listen for auth changes
        const { data: { subscription } } = supabase.auth.onAuthStateChange(async (event, newSession) => {
                        
            setSession(newSession);
            setUser(newSession?.user ?? null);
            setLoading(false);
        });

        return () => {
            subscription.unsubscribe();
        };
    }, []);

    const contextValue = {
        user,
        session,
        loading
    };

    if (loading) {
        return <div>Loading auth state...</div>;
    }

    return (
        <AuthContext.Provider value={contextValue}>
            {children}
        </AuthContext.Provider>
    );
};


/*
    useEffect(() => {
        // Get initial session
        supabase.auth.getSession().then(({ data: { session } }) => {
            console.log('Initial session:', session);
            setSession(session);
            setUser(session?.user ?? null);
            setLoading(false);
        });

        // Listen for auth changes
        const { data: { subscription } } = supabase.auth.onAuthStateChange(async (event, session) => {
            console.log('Auth state changed:', event, session);
            setSession(session);
            setUser(session?.user ?? null);

            if (event === 'SIGNED_IN' && session?.user) {
                // Check if profile exists
                const { data: profile } = await supabase
                    .from('profiles')
                    .select('*')
                    .eq('id', session.user.id)
                    .single();

                // If no profile exists, create one
                if (!profile) {
                    const { error: profileError } = await supabase
                        .from('profiles')
                        .insert({
                            id: session.user.id,
                            email: session.user.email,
                            role: 'client',
                            created_at: new Date().toISOString()
                        });

                    if (profileError) {
                        console.error('Error creating profile:', profileError);
                    }
                }
            }
        });

        return () => subscription.unsubscribe();
    }, []);

    // Don't return loading component here
    return (
        <AuthContext.Provider value={{ user, session, loading }}>
            {children}
        </AuthContext.Provider>
    );
};


useEffect(() => {
    const { data: { subscription } } = supabase.auth.onAuthStateChange(async (event, session) => {
      if (event === 'SIGNED_IN' && session?.user) {
        // Check if profile exists
        const { data: profile } = await supabase
          .from('profiles')
          .select('*')
          .eq('id', session.user.id)
          .single();
  
        // If no profile exists, create one
        if (!profile) {
          const { error: profileError } = await supabase
            .from('profiles')
            .insert({
              id: session.user.id,
              email: session.user.email,
              role: 'client',
              created_at: new Date().toISOString()
            });
  
          if (profileError) {
            console.error('Error creating profile:', profileError);
          }
        }
      }
    });
  
    return () => subscription.unsubscribe();
  }, []);

    if (loading) {
        return <div>Loading...</div>; // Or your loading component
    }

    return (
        <AuthContext.Provider value={{ user, session }}>
            {children}
        </AuthContext.Provider>
    );
};

*/
</file>

<file path="src/hooks/useAuthRedirect.ts">
// src/hooks/useAuthRedirect.ts
import { useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { useContext } from 'react';
import { AuthContext } from '../context/AuthContext';

export const useAuthRedirect = () => {
  const { user } = useContext(AuthContext);
  const navigate = useNavigate();

  useEffect(() => {

    console.log('Auth redirect check:', { 
      hasUser: !!user, 
      userRole: user?.user_metadata?.role 
    });

    if (user) {
      const role = user.user_metadata.role;
      if (role === 'adviser') {
        navigate('/adviser/adviser-dashboard');
      } else if (role === 'client') {
        navigate('/client/client-dashboard');
      }
    }
  }, [user, navigate]);
};
</file>

<file path="src/hooks/useFinancialData.ts">
// src/hooks/useFinancialData.ts
import { useState, useEffect } from 'react';
import { supabase } from '../services/supabaseClient';
import { useAuth } from '../context/AuthContext';

export interface FinancialData {
  income: number;
  expenditure: { category: string; amount: number }[];
  assets: number;
  liabilities: number;
  goals?: {
    id: string;
    goal: string;
    target_amount: number;
    time_horizon: number;
  }[];
  incomes?: { type: string; amount: number }[]; // Add this line
}

export const useFinancialData = () => {
  const { user } = useAuth();
  const [data, setData] = useState<FinancialData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchData = async () => {
    if (!user) return;
    
    try {
      // Fetch all data in parallel
      const [
        { data: incomesData, error: incomesError },
        { data: expendituresData, error: expendituresError },
        { data: assetsData, error: assetsError },
        { data: liabilitiesData, error: liabilitiesError },
        { data: goalsData, error: goalsError }
      ] = await Promise.all([
        supabase.from('incomes').select('*').eq('client_id', user.id),
        supabase.from('expenditures').select('*').eq('client_id', user.id),
        supabase.from('assets').select('*').eq('client_id', user.id),
        supabase.from('liabilities').select('*').eq('client_id', user.id),
        supabase.from('goals').select('*').eq('client_id', user.id)
      ]);

      if (incomesError || expendituresError || assetsError || liabilitiesError || goalsError) {
        throw new Error('Error fetching financial data');
      }

      const processedIncomes = (incomesData || [])
      .filter(income => income.amount && Number(income.amount) > 0)
      .reduce((unique: any[], income: any) => {
        const existing = unique.find(item => item.type === income.type);
        if (!existing) {
          unique.push({...income});
        } else {
          // If type already exists, add to the amount
          existing.amount = Number(existing.amount) + Number(income.amount);
        }
        return unique;
      }, []);

      const totalIncome = (incomesData || []).reduce((sum, income) => {
        const amount = Number(income.amount) || 0;
        return sum + (income.frequency === 'Monthly' ? amount * 12 : amount);
      }, 0);

      const expenditures = (expendituresData || []).map(exp => ({
        category: exp.category,
        amount: Number(exp.amount) || 0
      }));

      const filteredAssets = (assetsData || []).filter(asset => asset.value && Number(asset.value) > 0);
      const filteredLiabilities = (liabilitiesData || []).filter(liability => 
        liability.amount && Number(liability.amount) > 0
      );

      const totalAssets = assetsData?.reduce((sum, asset) => sum + (asset.value || 0), 0) || 0;
      const totalLiabilities = liabilitiesData?.reduce((sum, liability) => sum + (liability.amount || 0), 0) || 0;

      setData({
        income: totalIncome,
        expenditure: expenditures,
        assets: totalAssets,
        liabilities: totalLiabilities,
        goals: goalsData || [],
        incomes: processedIncomes 
      });
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred');
    } finally {
      setLoading(false);
    }
  };
  

  useEffect(() => {
    fetchData();
  }, [user]);

  return { data, loading, error, refetch: fetchData };
};
</file>

<file path="src/migrations/migrateTo_v2_addFileNotes.ts">
// src/migrations/migrateTo_v2_addFileNotes.ts
import { supabase } from '../services/supabaseClient';

/**
 * Run this migration to add the file_notes and client_summaries tables
 * to your existing database.
 */
export const migrateToV2AddFileNotes = async () => {
  console.log('Starting migration to add file_notes and client_summaries tables...');
  
  try {
    // Check if the tables already exist
    const { data: tablesData, error: tablesError } = await supabase
      .from('pg_tables')
      .select('tablename')
      .in('tablename', ['file_notes', 'client_summaries']);
    
    if (tablesError) {
      console.error('Error checking existing tables:', tablesError);
      return { success: false, message: 'Error checking existing tables' };
    }
    
    const existingTables = tablesData.map(t => t.tablename);
    
    // Create file_notes table if it doesn't exist
    if (!existingTables.includes('file_notes')) {
      const { error: createNotesError } = await supabase.rpc('create_file_notes_table');
      
      if (createNotesError) {
        console.error('Error creating file_notes table:', createNotesError);
        return { success: false, message: 'Error creating file_notes table' };
      }
      
      console.log('Created file_notes table successfully');
    } else {
      console.log('file_notes table already exists, skipping creation');
    }
    
    // Create client_summaries table if it doesn't exist
    if (!existingTables.includes('client_summaries')) {
      const { error: createSummariesError } = await supabase.rpc('create_client_summaries_table');
      
      if (createSummariesError) {
        console.error('Error creating client_summaries table:', createSummariesError);
        return { success: false, message: 'Error creating client_summaries table' };
      }
      
      console.log('Created client_summaries table successfully');
    } else {
      console.log('client_summaries table already exists, skipping creation');
    }
    
    return { success: true, message: 'Migration completed successfully' };
  } catch (error) {
    console.error('Migration failed:', error);
    return { 
      success: false, 
      message: error instanceof Error ? error.message : 'Unknown migration error' 
    };
  }
};

// This helps to run the migration from the browser console or a script
export const runMigration = async () => {
  const result = await migrateToV2AddFileNotes();
  console.log('Migration result:', result);
  return result;
};
</file>

<file path="src/services/DocumentService.ts">
// src/services/DocumentService.ts
import { supabase } from './supabaseClient';
import { ClientDocument, ExtractedDocumentData } from '../@types/documents';

export class DocumentService {
  /**
   * Fetch all documents for a specific client
   * @param clientId The ID of the client whose documents to fetch
   * @returns Array of financial documents
   */
  static async getDocuments(clientId: string): Promise<ClientDocument[]> {
    try {
      const { data, error } = await supabase
        .from('client_documents')
        .select('*')
        .eq('client_id', clientId)
        .order('upload_date', { ascending: false });
        
      if (error) throw error;
      
      return data || [];
    } catch (error) {
      console.error('Error fetching documents:', error);
      throw error;
    }
  }
  
  /**
   * Get a single document by ID
   * @param documentId The ID of the document to retrieve
   * @returns A document object if found
   */
  static async getDocumentById(documentId: string): Promise<ClientDocument | null> {
    try {
      const { data, error } = await supabase
        .from('client_documents')
        .select('*')
        .eq('id', documentId)
        .single();
        
      if (error) throw error;
      
      return data;
    } catch (error) {
      console.error('Error fetching document:', error);
      throw error;
    }
  }
  
  /**
   * Create a signed URL for a document
   * @param filePath The path of the file in storage
   * @param expiresIn Expiry time in seconds (default: 3600 = 1 hour)
   * @returns A signed URL for accessing the document
   */
  static async getSignedUrl(filePath: string, expiresIn = 3600): Promise<string | null> {
    try {
      const { data, error } = await supabase.storage
        .from('documents')
        .createSignedUrl(filePath, expiresIn);
        
      if (error) throw error;
      
      return data?.signedUrl || null;
    } catch (error) {
      console.error('Error creating signed URL:', error);
      return null;
    }
  }
  
  /**
   * Delete a document and its associated file
   * @param documentId The ID of the document to delete
   * @returns True if deletion was successful
   */
  static async deleteDocument(documentId: string): Promise<boolean> {
    try {
      // First get the document to retrieve the file path
      const document = await this.getDocumentById(documentId);
      
      if (!document || !document.file_path) {
        throw new Error('Document not found or missing file path');
      }
      
      // Delete the file from storage
      const { error: storageError } = await supabase.storage
        .from('documents')
        .remove([document.file_path]);
        
      if (storageError) {
        console.warn('Error deleting file from storage:', storageError);
        // Continue anyway to ensure DB record is removed
      }
      
      // Delete the record from the database
      const { error: dbError } = await supabase
        .from('client_documents')
        .delete()
        .eq('id', documentId);
        
      if (dbError) throw dbError;
      
      return true;
    } catch (error) {
      console.error('Error deleting document:', error);
      throw error;
    }
  }
  
  /**
   * Process a document to extract relevant data
   * @param documentId The ID of the document to process
   * @returns The updated document with extracted data
   */
  static async processDocument(documentId: string): Promise<ClientDocument> {
    try {
      // Get the document
      const document = await this.getDocumentById(documentId);
      
      if (!document) {
        throw new Error('Document not found');
      }
      
      // Call the serverless function to process the document
      const response = await fetch('/.netlify/functions/process-document', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          documentId,
          clientId: document.client_id,
          filePath: document.file_path,
        }),
      });
      
      if (!response.ok) {
        throw new Error(`Document processing failed: ${response.statusText}`);
      }
      
      const result = await response.json();
      
      if (result.error) {
        throw new Error(result.error);
      }
      
      // Update the document in the database
      const { data, error } = await supabase
        .from('client_documents')
        .update({
          processed: true,
          processed_date: new Date().toISOString(),
          document_type: result.documentType,
          extracted_data: result.extractedData
        })
        .eq('id', documentId)
        .select()
        .single();
        
      if (error) throw error;
      
      return data;
    } catch (error) {
      console.error('Error processing document:', error);
      throw error;
    }
  }
  
  /**
   * Apply extracted document data to a client's profile
   * @param clientId The ID of the client
   * @param documentId The ID of the document
   * @param extractedData The data extracted from the document
   * @returns Success status
   */
  static async applyExtractedData(
    clientId: string, 
    documentId: string, 
    extractedData: ExtractedDocumentData,
    documentType?: string
  ): Promise<boolean> {
    try {
      // Call the serverless function to apply the extracted data
      const response = await fetch('/.netlify/functions/apply-extracted-data', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          clientId,
          documentId,
          extractedData,
          documentType
        }),
      });
      
      if (!response.ok) {
        throw new Error(`Failed to apply data: ${response.statusText}`);
      }
      
      const result = await response.json();
      
      if (result.error) {
        throw new Error(result.error);
      }
      
      return true;
    } catch (error) {
      console.error('Error applying extracted data:', error);
      throw error;
    }
  }
  
  /**
   * Upload a document for a client
   * @param file The file to upload
   * @param clientId The ID of the client the document belongs to
   * @param uploaderId The ID of the user uploading the document
   * @param documentType Optional document type
   * @param notes Optional notes about the document
   * @returns The created document record
   */
  static async uploadDocument(
    file: File, 
    clientId: string, 
    uploaderId: string,
    documentType?: string,
    notes?: string
  ): Promise<ClientDocument> {
    try {
      // Create a unique file path
      const fileExtension = file.name.split('.').pop() || '';
      const timestamp = new Date().getTime();
      const filePath = `${clientId}/${timestamp}_${file.name}`;
      
      // Upload file to storage
      const { data: uploadData, error: uploadError } = await supabase.storage
        .from('documents')
        .upload(filePath, file, {
          cacheControl: '3600',
          upsert: false
        });
        
      if (uploadError) throw uploadError;
      
      // Create a signed URL for access
      const { data: signedUrlData, error: signedUrlError } = await supabase.storage
        .from('documents')
        .createSignedUrl(filePath, 3600);
        
      if (signedUrlError) {
        console.warn('Error creating signed URL:', signedUrlError);
        // Continue anyway as the file was uploaded successfully
      }
      
      // Insert document record
      const { data, error } = await supabase
        .from('client_documents')
        .insert({
          client_id: clientId,
          file_name: file.name,
          file_type: fileExtension,
          file_path: filePath,
          file_url: signedUrlData?.signedUrl || '',
          upload_date: new Date().toISOString(),
          uploaded_by: uploaderId,
          processed: false,
          document_type: documentType || null,
          notes: notes || null
        })
        .select()
        .single();
      
      if (error) throw error;
      if (!data) throw new Error('Failed to create document record');
      
      return data;
    } catch (error) {
      console.error('Error uploading document:', error);
      throw error;
    }
  }
}
</file>

<file path="src/services/supabaseClient.ts">
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = process.env.REACT_APP_SUPABASE_DATABASE_URL!;
const supabaseAnonKey = process.env.REACT_APP_SUPABASE_ANON_KEY!;

export const supabase = createClient(supabaseUrl, supabaseAnonKey,
{
    auth: {
      persistSession: true, // Enable session persistence
      autoRefreshToken: false, // Disable auto-refreshing the token
      storageKey: 'app-auth',
      detectSessionInUrl: true,
      storage: localStorage // Use localStorage for session storage
    },
    db: {
        schema: 'public'
    }
  }
)
</file>

<file path="src/services/supabaseOps.ts">
// supabaseOps.ts
import { supabase } from './supabaseClient'; 

// Fetch all clients for an adviser
    export const fetchClients = async (adviserId: string) => {
        const { data, error } = await supabase
        .from('clients')
        .select('*')
        .eq('adviser_id', adviserId);
    
        if (error) throw error;
        return data;
    };
    
    // Fetch client data
    export const fetchClientData = async (clientId: string) => {
        const { data, error } = await supabase
        .from('client_data')
        .select('*')
        .eq('client_id', clientId)
        .single();
    
        if (error) throw error;
        return data;
    };

    // Insert new client
    export const insertClient = async (client: {
        name: string;
        email: string;
        adviser_id: string;
    }) => {
        const { error } = await supabase.from('clients').insert([client]);
        if (error) throw error;
    };
  
    // Insert client financial data
    export const insertClientData = async (data: {
        client_id: string;
        income: number;
        expenses: number;
        assets: number;
        liabilities: number;
        goals: string;
    }) => {
        const { error } = await supabase.from('client_data').insert([data]);
        if (error) throw error;
    };
  
  // Update client data
  export const updateClientData = async (
        clientId: string,
        updatedData: Partial<{
        income: number;
        expenses: number;
        assets: number;
        liabilities: number;
        goals: string;
        }>
    ) => {
        const { error } = await supabase
        .from('client_data')
        .update(updatedData)
        .eq('client_id', clientId);
    
        if (error) throw error;
    };

// Delete a client
    export const deleteClient = async (clientId: string) => {
        const { error } = await supabase.from('clients').delete().eq('id', clientId);
        if (error) throw error;
    };
    
    // Delete client data
    export const deleteClientData = async (clientId: string) => {
        const { error } = await supabase.from('client_data').delete().eq('client_id', clientId);
        if (error) throw error;
    };
</file>

<file path="src/styles/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;
</file>

<file path="src/utils/riskAssessment/constants.ts">
export const RISK_CATEGORIES = {
    VERY_CONSERVATIVE: 'Very Conservative',
    CONSERVATIVE: 'Conservative',
    MODERATE_CONSERVATIVE: 'Moderate Conservative',
    MODERATE: 'Moderate',
    MODERATE_AGGRESSIVE: 'Moderate Aggressive',
    AGGRESSIVE: 'Aggressive'
  } as const;
  
  export const ASSET_ALLOCATIONS = {
    [RISK_CATEGORIES.VERY_CONSERVATIVE]: { equities: 20, bonds: 60, cash: 20, other: 0 },
    // ... other allocations
  };
</file>

<file path="src/utils/riskAssessment/index.ts">
export * from './types';
export * from './questions';
export * from './riskCalculations';
export * from './constants';
</file>

<file path="src/utils/riskAssessment/questions.ts">
// Risk Profile Questions and Scoring System
// src/utils/riskAssessment/questions.ts

import { RiskQuestion } from './types';
  
  export const riskProfileQuestions: RiskQuestion[] = [
    // Investment Knowledge & Experience
    {
      id: 'knowledge_1',
      question: 'How would you rate your investment knowledge?',
      category: 'knowledge',
      answers: [
        { text: 'None - I have no knowledge of investments', score: 1 },
        { text: 'Basic - I understand the main asset classes', score: 2 },
        { text: 'Good - I understand different investment strategies', score: 3 },
        { text: 'Extensive - I have detailed investment knowledge', score: 4 }
      ]
    },
    {
      id: 'knowledge_2',
      question: 'Which investments have you held in the past?',
      category: 'knowledge',
      answers: [
        { text: 'Only cash savings', score: 1 },
        { text: 'Cash and bonds', score: 2 },
        { text: 'Stocks and shares', score: 3 },
        { text: 'Complex investments (options, alternatives, etc.)', score: 4 }
      ]
    },
  
    // Risk Attitude
    {
      id: 'attitude_1',
      question: 'If your investments fell 20% in one month, what would you do?',
      category: 'attitude',
      answers: [
        { text: 'Sell everything immediately', score: 1 },
        { text: 'Sell some investments', score: 2 },
        { text: 'Do nothing', score: 3 },
        { text: 'Buy more while prices are low', score: 4 }
      ]
    },
    {
      id: 'attitude_2',
      question: 'Which statement best describes your investment approach?',
      category: 'attitude',
      answers: [
        { text: 'I want to minimize risk of any losses', score: 1 },
        { text: 'I want to balance risk and returns', score: 2 },
        { text: 'I am comfortable with some volatility to achieve better returns', score: 3 },
        { text: 'I aim to maximize returns and can accept significant volatility', score: 4 }
      ]
    },
  
    // Risk Capacity
    {
      id: 'capacity_1',
      question: 'How stable is your employment income?',
      category: 'capacity',
      answers: [
        { text: 'Very unstable/temporary', score: 1 },
        { text: 'Somewhat unstable', score: 2 },
        { text: 'Stable', score: 3 },
        { text: 'Very stable/permanent', score: 4 }
      ]
    },
    {
      id: 'capacity_2',
      question: 'How many months of expenses could you cover from emergency savings?',
      category: 'capacity',
      answers: [
        { text: 'Less than 3 months', score: 1 },
        { text: '3-6 months', score: 2 },
        { text: '6-12 months', score: 3 },
        { text: 'More than 12 months', score: 4 }
      ]
    },
  
    // Investment Timeframe
    {
      id: 'timeframe_1',
      question: 'When do you expect to need to access most of your investments?',
      category: 'timeframe',
      answers: [
        { text: 'Within 3 years', score: 1 },
        { text: '3-5 years', score: 2 },
        { text: '5-10 years', score: 3 },
        { text: 'More than 10 years', score: 4 }
      ]
    }
  ];
</file>

<file path="src/utils/riskAssessment/riskCalculations.ts">
// utils/riskAssessments/riskCalculations

import { financialCalculations } from '../financialcalculationMetrics';
import { Income, Expenditure, Asset, Liability, Goal } from '../../@types/financial';
import { FinancialMetrics, CapacityScore, RiskScores } from './types';


export const calculateFinancialMetricsForRisk = (
    incomes: Income[],
    expenditures: Expenditure[],
    assets: Asset[],
    liabilities: Liability[],
    goals: Goal[],
    dateOfBirth?: string
  ): FinancialMetrics => {
    const monthlyIncome = financialCalculations.calculateMonthlyIncome(incomes);
    const monthlyExpenses = financialCalculations.calculateMonthlyExpenditure(expenditures);
    const totalAssets = financialCalculations.calculateTotalAssets(assets);
    const totalLiabilities = financialCalculations.calculateTotalLiabilities(liabilities);
    
    // Calculate net worth
    const netWorth = totalAssets - totalLiabilities;

    const totalIncome = incomes.reduce(
      (sum, inc) => sum + (inc.frequency === 'Annual' ? inc.amount : inc.amount * 12),
      0
    );
  
    // Calculate annual debt service
    const annualDebtService = liabilities.reduce((sum, liability) => { // Fixed: 'data.liabilities' -> 'liabilities'
      if (['Loan', 'Mortgage'].includes(liability.type) && liability.term && liability.interest_rate) {
        const annualRate = liability.interest_rate / 100;
        const payment =
          (liability.amount * annualRate) / (1 - Math.pow(1 + annualRate, -liability.term));
        return sum + payment;
      }
      return sum + liability.amount; // Fallback for non-term debts
    }, 0);
    // Calculate liquid assets (assets marked as Cash, Savings, or Investments)
    const liquidAssets = assets.reduce((sum, asset) => {
      const isLiquid = ['Cash', 'Savings', 'Investments'].includes(asset.type);
      return sum + (isLiquid ? Number(asset.value) : 0);
    }, 0);

    console.log('Total liquid assets calculated:', liquidAssets);
    
  
    // Calculate age and years to retirement
    const age = dateOfBirth ? financialCalculations.calculateAge(dateOfBirth) : 0;
    
    // Find retirement goal
    const retirementGoal = goals.find(goal => 
      goal.goal.toLowerCase().includes('retirement'));
    const yearsToRetirement = retirementGoal ? Number(retirementGoal.time_horizon) : null;
    
    // Log the final metrics
    console.log('Final financial metrics:', {
      monthlyIncome,
      monthlyExpenses,
      totalAssets,
      totalLiabilities,
      liquidAssets,
      age,
      yearsToRetirement, 
      netWorth,
      annualDebtService,
      totalIncome
    });

    console.log('Liquid Assets Calculation Debug:', {
      totalAssets: assets.length,
      liquidAssetsValue: liquidAssets,
      assets: assets.map(asset => ({
        type: asset.type,
        value: asset.value
      }))
    });
  

    return {
      monthlyIncome,
      monthlyExpenses,
      totalAssets,
      totalLiabilities,
      liquidAssets,
      age,
      yearsToRetirement, 
      netWorth,
      annualDebtService,
      totalIncome

    };
  };


export const calculateCapacityForLoss = (
    metrics: FinancialMetrics): CapacityScore => {
    const factors: { factor: string; score: number; explanation: string }[] = [];
    let totalScore = 0;
  
    // 1. Emergency Fund Ratio
    const monthlyExpenses = metrics.monthlyExpenses;
    const emergencyFundRatio = metrics.liquidAssets / monthlyExpenses;
    let emergencyFundScore = 0;
  
    if (emergencyFundRatio >= 6) emergencyFundScore = 4;
    else if (emergencyFundRatio >= 3) emergencyFundScore = 3;
    else if (emergencyFundRatio >= 1) emergencyFundScore = 2;
    else emergencyFundScore = 1;
  
    factors.push({
      factor: 'Emergency Fund',
      score: emergencyFundScore,
      explanation: `Has ${emergencyFundRatio.toFixed(1)} months of expenses covered`
    });
    totalScore += emergencyFundScore;
  
    // 2. Debt Service Ratio
    const monthlyIncome = metrics.monthlyIncome;
    const debtServiceRatio = metrics.totalLiabilities / (monthlyIncome * 12);
    let debtScore = 0;
  
    if (debtServiceRatio <= 0.2) debtScore = 4;
    else if (debtServiceRatio <= 0.35) debtScore = 3;
    else if (debtServiceRatio <= 0.5) debtScore = 2;
    else debtScore = 1;
  
    factors.push({
      factor: 'Debt Service',
      score: debtScore,
      explanation: `Debt service ratio is ${(debtServiceRatio * 100).toFixed(1)}%`
    });
    totalScore += debtScore;
  
    // 3. Net Worth Ratio
    const netWorthRatio = metrics.totalAssets / Math.max(metrics.totalLiabilities, 1);
    let netWorthScore = 0;
  
    if (netWorthRatio >= 5) netWorthScore = 4;
    else if (netWorthRatio >= 3) netWorthScore = 3;
    else if (netWorthRatio >= 1) netWorthScore = 2;
    else netWorthScore = 1;
  
    factors.push({
      factor: 'Net Worth',
      score: netWorthScore,
      explanation: `Net worth ratio is ${netWorthRatio.toFixed(1)}x liabilities`
    });
    totalScore += netWorthScore;
    
    // Income Stability
    const surplusRatio = (metrics.monthlyIncome - metrics.monthlyExpenses) / metrics.monthlyIncome;
    let surplusScore = 0;
    if (surplusRatio >= 0.3) surplusScore = 4;
    else if (surplusRatio >= 0.2) surplusScore = 3;
    else if (surplusRatio >= 0.1) surplusScore = 2;
    else surplusScore = 1;

    factors.push({
        factor: 'Income Stability',
        score: surplusScore,
        explanation: `Monthly surplus ratio is ${(surplusRatio * 100).toFixed(1)}%`
    });
    totalScore += surplusScore;


    const finalScore = totalScore / 4;
    let category: string;
    if (finalScore >= 3.5) category = 'High';
    else if (finalScore >= 2.5) category = 'Medium';
    else if (finalScore >= 1.5) category = 'Low';
    else category = 'Very Low';

    return {
        score: finalScore,
        category,
        factors
    };
    };

    

    export const calculateRiskScores = (
    responses: Record<string, number>,
    metrics: FinancialMetrics
    ): RiskScores => {
    const calculateAverage = (questions: string[]) => {
        const scores = questions.map(q => Number(responses[q]) || 0);
        return scores.reduce((a, b) => a + b, 0) / scores.length;
    };

    const knowledgeScore = calculateAverage(['knowledge_1', 'knowledge_2']);
    const attitudeScore = calculateAverage(['attitude_1', 'attitude_2']);
    const capacityScore = calculateAverage(['capacity_1', 'capacity_2']);
    const timeframeScore = calculateAverage(['timeframe_1']);

    const capacityForLoss = calculateCapacityForLoss(metrics);

    const overallScore = (
        knowledgeScore * 0.20 +
        attitudeScore * 0.25 +
        capacityScore * 0.20 +
        timeframeScore * 0.15 +
        capacityForLoss.score * 0.20
    );

    const getRiskCategory = (score: number): string => {
        if (score <= 1.5) return 'Very Conservative';
        if (score <= 2.0) return 'Conservative';
        if (score <= 2.5) return 'Moderate Conservative';
        if (score <= 3.0) return 'Moderate';
        if (score <= 3.5) return 'Moderate Aggressive';
        return 'Aggressive';
    };

    return {
        knowledgeScore,
        attitudeScore,
        capacityScore,
        timeframeScore,
        overallScore,
        riskCategory: getRiskCategory(overallScore),
        capacityForLoss
    };
    };
</file>

<file path="src/utils/riskAssessment/types.ts">
// src/utils/riskAssessment/types.ts


export interface RiskQuestion {
    id: string;
    question: string;
    answers: {
      text: string;
      score: number;
    }[];
    category: 'knowledge' | 'attitude' | 'capacity' | 'timeframe';
  }
  
  export interface FinancialMetrics {
    monthlyIncome: number;
    monthlyExpenses: number;
    totalAssets: number;
    totalLiabilities: number;
    liquidAssets: number;
    age: number;
    yearsToRetirement: number | null;
    netWorth: number;
    annualDebtService: number; // Added
    totalIncome: number; // Added (assuming annual total income)
  }
  


  export interface CapacityScore {
    score: number;
    category: string;
    factors: {
      factor: string;
      score: number;
      explanation: string;
    }[];
  }

  export interface RiskScores {
    knowledgeScore: number;
    attitudeScore: number;
    capacityScore: number;
    timeframeScore: number;
    overallScore: number;
    riskCategory: string;
    capacityForLoss: CapacityScore;
  }
  
  export interface RiskProfileResultsProps {
    riskData: RiskScores;
  }
</file>

<file path="src/utils/fileNoteUtils.ts">
// src/utils/fileNoteUtils.ts
import { supabase } from '../services/supabaseClient';
import { ExtractedData } from '../@types/fileNote';

export const updateClientDetails = async (clientId: string, extractedData: ExtractedData) => {
  try {
    // Prepare batch updates for different tables
    const updates: Promise<any>[] = [];

    // Update personal details
    if (extractedData.personalDetails) {
      updates.push(
        Promise.resolve(
          supabase
            .from('kyc_data')
            .upsert({
              profile_id: clientId,
              ...extractedData.personalDetails
            })
        )
      );
    }

    // Update income
    if (extractedData.income) {
      const incomeEntries = Object.entries(extractedData.income).map(([type, amount]) => ({
        client_id: clientId,
        type,
        amount,
        frequency: 'Monthly' // Default, can be made more dynamic
      }));

      updates.push(
        Promise.resolve(
          supabase
            .from('incomes')
            .upsert(incomeEntries)
        )
      );
    }

    // Update expenses
    if (extractedData.expenses) {
      const expenditureEntries = Object.entries(extractedData.expenses).map(([category, amount]) => ({
        client_id: clientId,
        category,
        amount,
        frequency: 'Monthly' // Default, can be made more dynamic
      }));

      updates.push(
        Promise.resolve(
          supabase
            .from('expenditures')
            .upsert(expenditureEntries)
        )
      );
    }

    // Update assets
    if (extractedData.assets) {
      const assetEntries = Object.entries(extractedData.assets).map(([type, details]) => ({
        client_id: clientId,
        type,
        value: details.value,
        description: details.description || ''
      }));

      updates.push(
        Promise.resolve(
          supabase
            .from('assets')
            .upsert(assetEntries)
        )
      );
    }

    // Update liabilities
    if (extractedData.liabilities) {
      const liabilityEntries = Object.entries(extractedData.liabilities).map(([type, details]) => ({
        client_id: clientId,
        type,
        amount: details.amount,
        description: details.description || '',
        interest_rate: details.interest_rate
      }));

      updates.push(
        Promise.resolve(
          supabase
            .from('liabilities')
            .upsert(liabilityEntries)
        )
      );
    }

    // Update goals
    if (extractedData.financialGoals) {
      const goalEntries = Object.entries(extractedData.financialGoals).map(([goal, details]) => ({
        client_id: clientId,
        goal,
        target_amount: details.target_amount,
        time_horizon: details.time_horizon
      }));

      updates.push(
        Promise.resolve(
          supabase
            .from('goals')
            .upsert(goalEntries)
        )
      );
    }

    // Execute all updates
    const results = await Promise.all(updates);

    // Check for any errors
    const hasErrors = results.some(result => result.error);
    
    if (hasErrors) {
      console.error('Partial update errors:', results);
      return { 
        success: false, 
        message: 'Some updates failed' 
      };
    }

    return { 
      success: true, 
      message: 'Client details updated successfully' 
    };

  } catch (error) {
    console.error('Error updating client details:', error);
    return { 
      success: false, 
      message: error instanceof Error ? error.message : 'Unknown error' 
    };
  }
};
</file>

<file path="src/utils/financialcalculationMetrics.ts">
// src/utils/financialCalculationMetrics.ts
import { calculateAge } from 'components/Chat/Calculate';
import { 
    Income, 
    Expenditure, 
    Asset, 
    Liability, 
    Goal,
    FinancialData 
  } from '../@types/financial';
  
  export const financialCalculations = {
    toMonthly: (amount: number, frequency: string = 'monthly'): number => {
      return frequency.toLowerCase() === 'annual' ? amount / 12 : amount;
    },
  
    toAnnual: (amount: number, frequency: string = 'monthly'): number => {
      return frequency.toLowerCase() === 'monthly' ? amount * 12 : amount;
    },
  
    calculateMonthlyIncome: (incomes: Income[]): number => {
      return incomes.reduce((sum, income) => 
        sum + financialCalculations.toMonthly(Number(income.amount), income.frequency), 0);
    },
  
    calculateAnnualIncome: (incomes: Income[]): number => {
      return incomes.reduce((sum, income) => 
        sum + financialCalculations.toAnnual(Number(income.amount), income.frequency), 0);
    },
  
    calculateMonthlyExpenditure: (expenditures: Expenditure[]): number => {
      return expenditures.reduce((sum, exp) => 
        sum + financialCalculations.toMonthly(Number(exp.amount), exp.frequency), 0);
    },
  
    calculateAnnualExpenditure: (expenditures: Expenditure[]): number => {
      return expenditures.reduce((sum, exp) => 
        sum + financialCalculations.toAnnual(Number(exp.amount), exp.frequency), 0);
    },
  
    calculateTotalAssets: (assets: Asset[]): number => {
      return assets.reduce((sum, asset) => sum + Number(asset.value), 0);
    },
  
    calculateTotalLiabilities: (liabilities: Liability[]): number => {
      return liabilities.reduce((sum, liability) => sum + Number(liability.amount), 0);
    },
  
    calculateNetWorth: (assets: Asset[], liabilities: Liability[]): number => {
      return financialCalculations.calculateTotalAssets(assets) - 
             financialCalculations.calculateTotalLiabilities(liabilities);
    },
  
    calculateFinancialSummary: (data: FinancialData) => {
      // Calculate annual debt service for loans and mortgages
      const annualDebtService = data.liabilities.reduce((sum, liability) => {
        if (['Loan', 'Mortgage'].includes(liability.type) && liability.term && liability.interest_rate) {
          const annualRate = liability.interest_rate / 100;
          const payment = 
            (liability.amount * annualRate) / (1 - Math.pow(1 + annualRate, -liability.term));
          return sum + payment;
        }
        // For other liabilities, just add the minimum payments (estimated as 5% of balance)
        return sum + (liability.amount * 0.05);
      }, 0);

      // Calculate total annual income
      const totalIncome = financialCalculations.calculateAnnualIncome(data.incomes);
      
      return {
        monthlyIncome: financialCalculations.calculateMonthlyIncome(data.incomes),
        annualIncome: financialCalculations.calculateAnnualIncome(data.incomes),
        monthlyExpenditure: financialCalculations.calculateMonthlyExpenditure(data.expenditures),
        annualExpenditure: financialCalculations.calculateAnnualExpenditure(data.expenditures),
        totalAssets: financialCalculations.calculateTotalAssets(data.assets),
        totalLiabilities: financialCalculations.calculateTotalLiabilities(data.liabilities),
        netWorth: financialCalculations.calculateNetWorth(data.assets, data.liabilities),
        annualDebtService: annualDebtService,
        totalIncome: totalIncome
      };
    },
  
    formatCurrency: (amount: number): string => {
      return new Intl.NumberFormat('en-GB', {
        style: 'currency',
        currency: 'GBP',
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
      }).format(amount);
    },
  
    calculatePercentage: (amount: number, total: number): number => {
      if (total === 0) return 0;
      return Number(((amount / total) * 100).toFixed(1));
    },

    calculateAge: (birthDate: string): number => {
      if (!birthDate) return 0;

      const today = new Date();
      const birth = new Date(birthDate);

      let age = today.getFullYear() - birth.getFullYear();
      const monthDiff = today.getMonth() - birth.getMonth();

      if (monthDiff < 0 || (monthDiff === 0 && today.getDate() <birth.getDate())) {
        age--;
      }

      return age;
    },

      // You might also want to add related calculations like:
    calculateRetirementAge: (birthDate: string, targetRetirementYear: number): number => {
      const currentAge = financialCalculations.calculateAge(birthDate);
      return targetRetirementYear - new Date().getFullYear() + currentAge;
    },

    calculateYearsUntilRetirement: (birthDate: string, targetRetirementAge: number): number => {
      const currentAge = financialCalculations.calculateAge(birthDate);
      return targetRetirementAge - currentAge;
    }

  };
</file>

<file path="src/App.css">
.App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}
</file>

<file path="src/App.test.tsx">
import React from 'react';
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});
</file>

<file path="src/App.tsx">
// src/App.tsx
import React from 'react';
import ProtectedRoute from './components/ProtectedRoute';
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import SignIn from './components/Auth/SignIn';
import SignUp from './components/Auth/SignUp';
import Navbar from './components/Navbar';
import AdviserDashboard from './components/Adviser/Dashboard';
import Insights from './components/Adviser/Insights';
import Reports from './components/Adviser/Reports';
import CreateClient from './components/Adviser/CreateClient';
import ClientDashboard from './components/Client/Dashboard';
import { AuthProvider } from './context/AuthContext';
import IncomeForm from './components/Client/IncomeForm';
import ExpenditureForm from './components/Client/ExpenditureForm';
import AssetsForm from './components/Client/AssetsForm';
import LiabilitiesForm from './components/Client/LiabilitiesForm';
import GoalsForm from './components/Client/GoalsForm';
import ClientDetails from './components/Adviser/ClientDetails';
import ProfileForm from './components/Client/ProfileForm';
import DocumentsPage from 'components/Client/Documents/DocumentsPage';
import AdviserDocumentsPage from 'components/Adviser/Documents/AdviserDocumentsPage';
import SuitabilityReportGenerator from './components/Adviser/SuitabilityReportGenerator';
import './styles.css';
import './styles/globals.css';
import Chatbot from './components/Chat/Chat';
import RiskAssessmentForm from 'components/Client/Risk/RiskAssessmentForm';
import { Toaster } from 'react-hot-toast';



  const App: React.FC = () => {

    return (
      <AuthProvider>
        <BrowserRouter>
          <Navbar />
          <Routes>
            <Route path="/" element={<SignIn />} />
            <Route path="/signup" element={<SignUp />} />
            <Route path="/adviser/adviser-dashboard" element={<ProtectedRoute requiredRole = "adviser"> <AdviserDashboard /> </ProtectedRoute>} />
            <Route path="/adviser/create-client" element={<ProtectedRoute requiredRole = "adviser"> <CreateClient /></ProtectedRoute>} />
            <Route
              path="/adviser/client/:clientId"
              element={
                <ProtectedRoute requiredRole="adviser">
                  <ClientDetails />
                </ProtectedRoute>
              }
            />
            <Route
              path="/adviser/client/:clientId/insights"
              element={
                <ProtectedRoute requiredRole="adviser">
                  <Insights />
                </ProtectedRoute>
              }
            />
            <Route
              path="/adviser/client/:clientId/reports"
              element={
                <ProtectedRoute requiredRole="adviser">
                  <Reports />
                </ProtectedRoute>
              }
            />
            <Route
              path="/adviser/client/:clientId/suitability-report"
              element={
                <ProtectedRoute requiredRole="adviser">
                  <SuitabilityReportGenerator />
                </ProtectedRoute>
              }
            />
            <Route
              path="/adviser/client/:clientId/documents"
              element={
                <ProtectedRoute requiredRole="adviser">
                  <AdviserDocumentsPage />
                </ProtectedRoute>
              }
            />
            <Route path="/client/client-dashboard" element={<ProtectedRoute requiredRole = "client"><ClientDashboard /></ProtectedRoute>} />
            <Route
              path="/client/income"
              element={
                <ProtectedRoute requiredRole="client">
                  <IncomeForm />
                </ProtectedRoute>
              }
            />
            <Route
              path="/client/expenditure"
              element={
                <ProtectedRoute requiredRole="client">
                  <ExpenditureForm />
                </ProtectedRoute>
              }
            />
            <Route
              path="/client/profile"
              element={
                <ProtectedRoute requiredRole="client">
                  <ProfileForm />
                </ProtectedRoute>
              }
            />
            <Route
              path="/client/assets"
              element={
                <ProtectedRoute requiredRole="client">
                  <AssetsForm />
                </ProtectedRoute>
              }
            />
            <Route
              path="/client/liabilities"
              element={
                <ProtectedRoute requiredRole="client">
                  <LiabilitiesForm />
                </ProtectedRoute>
              }
            />
            <Route
              path="/client/liabilities:id"
              element={
                <ProtectedRoute requiredRole="client">
                  <LiabilitiesForm />
                </ProtectedRoute>
              }
            />
            <Route
              path="/client/goals"
              element={
                <ProtectedRoute requiredRole="client">
                  <GoalsForm />
                </ProtectedRoute>
              }
            />
            <Route
              path="/chat/chat"
              element={
                <ProtectedRoute requiredRole="client">
                  <Chatbot /> 
                </ProtectedRoute>
              }
            />
            <Route
              path="/client/risk-assessment"
              element={
                <ProtectedRoute requiredRole="client">
                  <RiskAssessmentForm />
                </ProtectedRoute>
              }
            />
            <Route
              path="/client/documents"
              element={
                <ProtectedRoute requiredRole="client">
                  <DocumentsPage />
                </ProtectedRoute>
              }
            />
          </Routes>
        </BrowserRouter>
      </AuthProvider>
      
    );
  };

  export default App;
</file>

<file path="src/index.css">
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}
</file>

<file path="src/index.tsx">
import React from 'react';
import {createRoot} from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const container = document.getElementById('root');
if (!container) throw new Error('Failed to find the root element');
const root = createRoot(container);

root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();
</file>

<file path="src/logo.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 841.9 595.3"><g fill="#61DAFB"><path d="M666.3 296.5c0-32.5-40.7-63.3-103.1-82.4 14.4-63.6 8-114.2-20.2-130.4-6.5-3.8-14.1-5.6-22.4-5.6v22.3c4.6 0 8.3.9 11.4 2.6 13.6 7.8 19.5 37.5 14.9 75.7-1.1 9.4-2.9 19.3-5.1 29.4-19.6-4.8-41-8.5-63.5-10.9-13.5-18.5-27.5-35.3-41.6-50 32.6-30.3 63.2-46.9 84-46.9V78c-27.5 0-63.5 19.6-99.9 53.6-36.4-33.8-72.4-53.2-99.9-53.2v22.3c20.7 0 51.4 16.5 84 46.6-14 14.7-28 31.4-41.3 49.9-22.6 2.4-44 6.1-63.6 11-2.3-10-4-19.7-5.2-29-4.7-38.2 1.1-67.9 14.6-75.8 3-1.8 6.9-2.6 11.5-2.6V78.5c-8.4 0-16 1.8-22.6 5.6-28.1 16.2-34.4 66.7-19.9 130.1-62.2 19.2-102.7 49.9-102.7 82.3 0 32.5 40.7 63.3 103.1 82.4-14.4 63.6-8 114.2 20.2 130.4 6.5 3.8 14.1 5.6 22.5 5.6 27.5 0 63.5-19.6 99.9-53.6 36.4 33.8 72.4 53.2 99.9 53.2 8.4 0 16-1.8 22.6-5.6 28.1-16.2 34.4-66.7 19.9-130.1 62-19.1 102.5-49.9 102.5-82.3zm-130.2-66.7c-3.7 12.9-8.3 26.2-13.5 39.5-4.1-8-8.4-16-13.1-24-4.6-8-9.5-15.8-14.4-23.4 14.2 2.1 27.9 4.7 41 7.9zm-45.8 106.5c-7.8 13.5-15.8 26.3-24.1 38.2-14.9 1.3-30 2-45.2 2-15.1 0-30.2-.7-45-1.9-8.3-11.9-16.4-24.6-24.2-38-7.6-13.1-14.5-26.4-20.8-39.8 6.2-13.4 13.2-26.8 20.7-39.9 7.8-13.5 15.8-26.3 24.1-38.2 14.9-1.3 30-2 45.2-2 15.1 0 30.2.7 45 1.9 8.3 11.9 16.4 24.6 24.2 38 7.6 13.1 14.5 26.4 20.8 39.8-6.3 13.4-13.2 26.8-20.7 39.9zm32.3-13c5.4 13.4 10 26.8 13.8 39.8-13.1 3.2-26.9 5.9-41.2 8 4.9-7.7 9.8-15.6 14.4-23.7 4.6-8 8.9-16.1 13-24.1zM421.2 430c-9.3-9.6-18.6-20.3-27.8-32 9 .4 18.2.7 27.5.7 9.4 0 18.7-.2 27.8-.7-9 11.7-18.3 22.4-27.5 32zm-74.4-58.9c-14.2-2.1-27.9-4.7-41-7.9 3.7-12.9 8.3-26.2 13.5-39.5 4.1 8 8.4 16 13.1 24 4.7 8 9.5 15.8 14.4 23.4zM420.7 163c9.3 9.6 18.6 20.3 27.8 32-9-.4-18.2-.7-27.5-.7-9.4 0-18.7.2-27.8.7 9-11.7 18.3-22.4 27.5-32zm-74 58.9c-4.9 7.7-9.8 15.6-14.4 23.7-4.6 8-8.9 16-13 24-5.4-13.4-10-26.8-13.8-39.8 13.1-3.1 26.9-5.8 41.2-7.9zm-90.5 125.2c-35.4-15.1-58.3-34.9-58.3-50.6 0-15.7 22.9-35.6 58.3-50.6 8.6-3.7 18-7 27.7-10.1 5.7 19.6 13.2 40 22.5 60.9-9.2 20.8-16.6 41.1-22.2 60.6-9.9-3.1-19.3-6.5-28-10.2zM310 490c-13.6-7.8-19.5-37.5-14.9-75.7 1.1-9.4 2.9-19.3 5.1-29.4 19.6 4.8 41 8.5 63.5 10.9 13.5 18.5 27.5 35.3 41.6 50-32.6 30.3-63.2 46.9-84 46.9-4.5-.1-8.3-1-11.3-2.7zm237.2-76.2c4.7 38.2-1.1 67.9-14.6 75.8-3 1.8-6.9 2.6-11.5 2.6-20.7 0-51.4-16.5-84-46.6 14-14.7 28-31.4 41.3-49.9 22.6-2.4 44-6.1 63.6-11 2.3 10.1 4.1 19.8 5.2 29.1zm38.5-66.7c-8.6 3.7-18 7-27.7 10.1-5.7-19.6-13.2-40-22.5-60.9 9.2-20.8 16.6-41.1 22.2-60.6 9.9 3.1 19.3 6.5 28.1 10.2 35.4 15.1 58.3 34.9 58.3 50.6-.1 15.7-23 35.6-58.4 50.6zM320.8 78.4z"/><circle cx="420.9" cy="296.5" r="45.7"/><path d="M520.5 78.1z"/></g></svg>
</file>

<file path="src/react-app-env.d.ts">
/// <reference types="react-scripts" />
</file>

<file path="src/reportWebVitals.ts">
import { ReportHandler } from 'web-vitals';

const reportWebVitals = (onPerfEntry?: ReportHandler) => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;
</file>

<file path="src/setupTests.ts">
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';
</file>

<file path="src/styles.css">
/* styles.css */

:root {
    --primary-color: #0077ff;
    --secondary-color: #f4f4f4;
    --text-color: #333333;
    --background-color: #ffffff;
    --font-family: 'Roboto', sans-serif;
  }
  
  body {
    height: 100%;
    margin: 0;
    padding: 0;
    font-family: var(--font-family);
    background-color: var(--background-color);
    color: var(--text-color);
  }
  
  /* Utility classes */
  .container {
    width: 90%;
    max-width: 1400px;
    margin: 0 auto;
    padding: 20px;
  }

  .grid {
    display: grid;
    width: 100%;
  }
  
  .flex {
    display: flex;
    gap: 20px;
  }
  
  .flex-column {
    flex-direction: column;
  }
  
  .align-center {
    align-items: center;
  }
  
  .justify-center {
    justify-content: center;
  }
  
  /* Typography */
  h1, h2, h3, h4, h5, h6 {
    margin: 0 0 10px;
    font-weight: 600;
  }
  
  p {
    margin: 0 0 10px;
    line-height: 1.5;
  }
  
  /* Buttons */
  button {
    background-color: var(--primary-color);
    color: #ffffff;
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    transition: background-color 0.3s ease;
  }
  
  button:hover {
    background-color: #005bb5;
  }
  
  /* Inputs */
  input, select, textarea {
    width: 100%;
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 5px;
    font-size: 16px;
    margin-bottom: 15px;
  }
  
  input:focus, select:focus, textarea:focus {
    border-color: var(--primary-color);
    outline: none;
  }
  
  /* Lists */
  ul {
    list-style: none;
    padding: 0;
    margin: 0;
  }
  
  ul li {
    padding: 10px 0;
    border-bottom: 1px solid #e0e0e0;
  }
  
  ul li:last-child {
    border-bottom: none;
  }
  
  /* Cards */
  .card {
    border: 1px solid #e0e0e0;
    border-radius: 10px;
    padding: 20px;
    background-color: var(--secondary-color);
    box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.1);
  }
  
  /* Headers */
  header {
    background-color: var(--primary-color);
    color: #ffffff;
    padding: 20px 0;
  }
  
  header h1 {
    text-align: center;
    font-size: 24px;
  }
  
  .flex {
    flex-wrap: wrap;
  }
  
  @media (max-width: 600px) {
    .flex {
      flex-direction: column;
      gap: 10px;
    }
  }
  
  /* Better grid structure for the dashboard */
.md\:grid-cols-3 {
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

.md\:grid-cols-2 {
  grid-template-columns: repeat(2, minmax(0, 1fr));
}

/* Fix card spacing and alignment */
.rounded-lg {
  border-radius: 0.5rem;
}

.shadow-lg {
  box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
}

.p-6 {
  padding: 1.5rem;
}

.mb-8 {
  margin-bottom: 2rem;
}

.gap-6 {
  gap: 1.5rem;
}

/* Ensure text doesn't get cut off */
h3 {
  white-space: normal;
  overflow: visible;
  text-overflow: clip;
  width: 100%;
}

/* Fix for Income Sources and Risk Profile section */
.income-risk-container {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 1.5rem;
  margin-bottom: 2rem;
  width: 100%;
}

.income-risk-container > div {
  min-width: 100%;
}

/* Make sure chart containers have enough room */
.h-64 {
  height: 16rem;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .md\:grid-cols-3,
  .md\:grid-cols-2,
  .income-risk-container {
    grid-template-columns: 1fr;
  }
  
  .gap-6 {
    gap: 1rem;
  }
}

/* Risk profile specific styling */
.risk-profile-container {
  display: flex;
  flex-direction: column;
  height: 100%;
}

.risk-category {
  display: inline-block;
  padding: 0.5rem 1rem;
  border-radius: 9999px;
  font-weight: 500;
  margin-top: 0.5rem;
  background-color: #ecfdf5;
  color: #065f46;
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# production
/build

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

npm-debug.log*
yarn-debug.log*
yarn-error.log*

.env
*.env*
# Local Netlify folder
.netlify
</file>

<file path=".node-version">
18.17.0
</file>

<file path=".nvmrc">
18.17.0
</file>

<file path="netlify.toml">
[build]
  command = "CI=false npm install && npm run build"
  publish = "dist" # For Vite
  functions = ".netlify/functions"

[build.environment]
  NODE_VERSION = "18"
  NPM_VERSION = "10.8.2"
  CI = "false"
  SECRETS_SCAN_ENABLED = "false"

[[redirects]]
  from = "/api/*"
  to = "/.netlify/functions/:splat"
  status = 200
  force = true

[[redirects]]
  from = "/*"
  to = "index.html"
  status = 200
  force = true

[functions]
  node_bundler = "esbuild"
  external_node_modules = ["@supabase/supabase-js", "openai", "@anthropic-ai/sdk"]
  directory = "netlify/functions"
  
  [functions.chatbot]
  timeout = "30"

[dev]
  framework = "vite"
  targetPort = 5173

# Add proper MIME type headers
[[headers]]
  for = "/assets/*.js"
[headers.values]
  Content-Type = "text/plain"

[[headers]]
  for = "/assets/*.css"
[headers.values]
  Content-Type = "text/css"

[[headers]]
  for = "/*"
[headers.values]
  X-Frame-Options = "DENY"
  X-XSS-Protection = "1; mode=block"
  X-Content-Type-Options = "nosniff"
  Referrer-Policy = "strict-origin-when-cross-origin"
  Access-Control-Allow-Origin = "*"
  Access-Control-Allow-Methods = "GET, POST, OPTIONS"
  Access-Control-Allow-Headers = "Content-Type"
</file>

<file path="package.json">
{
  "name": "workflow",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@anthropic-ai/sdk": "^0.36.3",
    "@netlify/functions": "^2.8.2",
    "@supabase/supabase-js": "^2.46.1",
    "@tailwindcss/forms": "^0.5.3",
    "@testing-library/jest-dom": "^5.17.0",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "@types/jest": "^27.5.2",
    "@types/node": "^16.18.120",
    "@types/react": "^18.3.12",
    "@types/react-dom": "^18.3.1",
    "@types/react-router-dom": "^5.3.3",
    "@types/recharts": "^1.8.29",
    "ajv": "^8.12.0",
    "ajv-keywords": "^5.1.0",
    "chart.js": "^4.4.6",
    "json2csv": "^6.0.0-alpha.2",
    "lucide-react": "^0.468.0",
    "next": "^15.0.3",
    "node-fetch": "^3.3.2",
    "openai": "^4.74.0",
    "react": "^18.2.0",
    "react-chartjs-2": "^5.2.0",
    "react-dom": "^18.2.0",
    "react-hot-toast": "^2.5.2",
    "react-router-dom": "^6.20.0",
    "react-scripts": "^5.0.1",
    "recharts": "^2.15.1",
    "vite": "^4.x.x",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "NODE_OPTIONS='--openssl-legacy-provider' react-scripts start",
    "build": "NODE_OPTIONS='--openssl-legacy-provider' npm run build:app && npm run build:functions",
    "build:app": "react-scripts build",
    "build:functions": "tsc -p netlify/functions/tsconfig.functions.json && echo 'Functions built to .netlify/functions-build' && ls .netlify/functions-build",
    "test": "react-scripts test",
    "eject": "react-scripts eject",
    "clean": "rm -rf build .netlify/functions-build && echo 'Cleaned build folders'",
    "netlify:build": "netlify build"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "@babel/plugin-proposal-private-property-in-object": "^7.21.11",
    "@types/node": "^22.10.1",
    "@types/react": "^18.3.12",
    "@types/react-dom": "^18.3.1",
    "autoprefixer": "^10.4.20",
    "esbuild": "^0.24.0",
    "postcss": "^8.4.49",
    "tailwindcss": "^3.4.15",
    "typescript": "^4.9.5"
  },
  "resolutions": {
    "nth-check": "^2.0.1",
    "postcss": "^8.4.31",
    "svgo": "^3.0.0"
  }
}
</file>

<file path="postcss.config.js">
module.exports = {
    plugins: {
      tailwindcss: {},
      autoprefixer: {},
    },
  }
</file>

<file path="README.md">
# Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in the browser.

The page will reload if you make edits.\
You will also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can’t go back!**

If you aren’t satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you’re on your own.

You don’t have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn’t feel obligated to use this feature. However we understand that this tool wouldn’t be useful if you couldn’t customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).
# workflow
# rd
</file>

<file path="supabase.txt">
-- Supabase AI is experimental and may produce incorrect answers
-- Always verify the output before executing

-- Enable the pgcrypto extension for UUID generation
create extension if not exists "pgcrypto";

-- First drop child tables (those with foreign key references)
DROP TABLE IF EXISTS public.goals;
DROP TABLE IF EXISTS public.liabilities;
DROP TABLE IF EXISTS public.assets;
DROP TABLE IF EXISTS public.expenditures;
DROP TABLE IF EXISTS public.incomes;
-- Drop the parent table last since other tables reference it
DROP TABLE IF EXISTS public.profiles;



-- Create the profiles table
create table if not exists
  public.profiles (
    id uuid primary key references auth.users (id) on delete cascade,
    name text,
    email text unique,
    role text check (role in ('adviser', 'client')),
    adviser_id uuid references public.profiles (id),
    created_at timestamp with time zone default timezone ('utc', now())
  );

-- Drop the existing incomes table if it exists
drop table if exists public.incomes;

-- Create the incomes table
create table
  public.incomes (
    id uuid primary key default gen_random_uuid (),
    client_id uuid references public.profiles (id) on delete cascade,
    type text,
    amount numeric,
    frequency text,
    created_at timestamp with time zone default timezone ('utc', now())
  );

-- Create the expenditures table
create table
  public.expenditures (
    id uuid primary key default gen_random_uuid (),
    client_id uuid references public.profiles (id) on delete cascade,
    category text,
    amount numeric,
    frequency text,
    created_at timestamp with time zone default timezone ('utc', now())
  );

-- Create the assets table
create table
  public.assets (
    id uuid primary key default gen_random_uuid (),
    client_id uuid references public.profiles (id) on delete cascade,
    type text,
    description text,
    value numeric,
    created_at timestamp with time zone default timezone ('utc', now())
  );

-- Create the liabilities table
create table
  public.liabilities (
    id uuid primary key default gen_random_uuid (),
    client_id uuid references public.profiles (id) on delete cascade,
    type text,
    description text,
    amount numeric,
    interest_rate numeric,
    created_at timestamp with time zone default timezone ('utc', now())
  );

-- Create the goals table
create table
  public.goals (
    id uuid primary key default gen_random_uuid (),
    client_id uuid references public.profiles (id) on delete cascade,
    goal text,
    target_amount numeric,
    time_horizon integer, -- in months or years
    created_at timestamp with time zone default timezone ('utc', now())
  );

-- Enable RLS on all tables
alter table public.profiles enable row level security;

alter table public.incomes enable row level security;

alter table public.expenditures enable row level security;

alter table public.assets enable row level security;

alter table public.liabilities enable row level security;

alter table public.goals enable row level security;

ALTER TABLE public.profiles DISABLE ROW LEVEL SECURITY;

-- Drop ALL existing policies for profiles
DROP POLICY IF EXISTS "Allow users to select their own profile" ON public.profiles;
DROP POLICY IF EXISTS "Advisers can select their clients' profiles" ON public.profiles;
DROP POLICY IF EXISTS "Allow users to insert their own profile" ON public.profiles;
DROP POLICY IF EXISTS "Allow users to update their own profile" ON public.profiles;
DROP POLICY IF EXISTS "Allow reading adviser profiles" ON public.profiles;
DROP POLICY IF EXISTS "Allow users to read own profile" ON public.profiles;
DROP POLICY IF EXISTS "Allow profile creation" ON public.profiles;

-- Re-enable RLS
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Create the only policies we need
CREATE POLICY "Allow reading adviser profiles"
ON public.profiles
FOR SELECT
USING (role = 'adviser');

CREATE POLICY "Allow users to read own profile"
ON public.profiles
FOR SELECT
USING (id = auth.uid());

CREATE POLICY "Allow profile creation"
ON public.profiles
FOR INSERT
WITH CHECK (true);  -- Allow any insert during signup

CREATE POLICY "Allow users to update own profile"
ON public.profiles
FOR UPDATE
USING (id = auth.uid());


-- RLS Policies for profiles table



-- RLS Policies for incomes table
-- Clients can manage their own data
create policy "Clients can manage their own data" on public.incomes for all using (client_id = auth.uid ());

-- Advisers can access their clients' data
create policy "Advisers can access their clients' data" on public.incomes for all using (
  exists (
    select
      1
    from
      profiles
    where
      profiles.id = incomes.client_id
      and profiles.adviser_id = auth.uid ()
      and (
        select
          role
        from
          profiles
        where
          id = auth.uid ()
      ) = 'adviser'
  )
);

-- Repeat the above policies for expenditures, assets, liabilities, and goals tables
-- Replace {table_name} with expenditures, assets, liabilities, goals
-- For expenditures table
create policy "Clients can manage their own data" on public.expenditures for all using (client_id = auth.uid ());

create policy "Advisers can access their clients' data" on public.expenditures for all using (
  exists (
    select
      1
    from
      public.profiles as client_profile
    where
      client_profile.id = client_id
      and client_profile.adviser_id = auth.uid ()
  )
);

-- For assets table
create policy "Clients can manage their own data" on public.assets for all using (client_id = auth.uid ());

create policy "Advisers can access their clients' data" on public.assets for all using (
  exists (
    select
      1
    from
      public.profiles as client_profile
    where
      client_profile.id = client_id
      and client_profile.adviser_id = auth.uid ()
  )
);

-- For liabilities table
create policy "Clients can manage their own data" on public.liabilities for all using (client_id = auth.uid ());

create policy "Advisers can access their clients' data" on public.liabilities for all using (
  exists (
    select
      1
    from
      public.profiles as client_profile
    where
      client_profile.id = client_id
      and client_profile.adviser_id = auth.uid ()
  )
);

-- For goals table
create policy "Clients can manage their own data" on public.goals for all using (client_id = auth.uid ());

create policy "Advisers can access their clients' data" on public.goals for all using (
  exists (
    select
      1
    from
      public.profiles as client_profile
    where
      client_profile.id = client_id
      and client_profile.adviser_id = auth.uid ()
  )
);
</file>

<file path="supabaseaccescontrolpolicies.txt">
-- Drop existing policies for profiles
DO $$ 
BEGIN
    DROP POLICY IF EXISTS "profiles_policy" ON public.profiles;
    DROP POLICY IF EXISTS "Allow profile creation and management" ON public.profiles;
END $$;

-- Create new policies for profiles
CREATE POLICY "Allow users to read their own profile"
ON public.profiles
FOR SELECT
TO authenticated
USING (id = auth.uid());

CREATE POLICY "Allow advisers to read their clients' profiles"
ON public.profiles
FOR SELECT
TO authenticated
USING (adviser_id = auth.uid());

CREATE POLICY "Allow advisers to read all profiles"
ON public.profiles
FOR SELECT
TO authenticated
USING (role = 'adviser');

CREATE POLICY "Allow profile creation"
ON public.profiles
FOR INSERT
TO authenticated
WITH CHECK (auth.uid() = id);

CREATE POLICY "Allow profile updates"
ON public.profiles
FOR UPDATE
TO authenticated
USING (id = auth.uid())
WITH CHECK (id = auth.uid());

CREATE POLICY "Allow profile deletion"
ON public.profiles
FOR DELETE
TO authenticated
USING (id = auth.uid());
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
module.exports = {
    // Files to scan for class names
    content: [
      "./src/**/*.{js,jsx,ts,tsx}",
      "./pages/**/*.{js,jsx,ts,tsx}",
      "./components/**/*.{js,jsx,ts,tsx}",
    ],
    theme: {
      extend: {
        // Custom colors for your financial app
        colors: {
          // UI colors
          primary: {
            DEFAULT: '#4F46E5', // Indigo
            dark: '#4338CA',
            light: '#818CF8',
          },
          secondary: {
            DEFAULT: '#10B981', // Emerald
            dark: '#059669',
            light: '#34D399',
          },
          danger: {
            DEFAULT: '#EF4444', // Red
            dark: '#DC2626',
            light: '#F87171',
          },
          // Financial indicator colors
          profit: '#10B981',    // Green for positive numbers
          loss: '#EF4444',      // Red for negative numbers
          neutral: '#6B7280',   // Gray for neutral values
        },
        // Custom spacing if needed
        spacing: {
          '72': '18rem',
          '84': '21rem',
          '96': '24rem',
        },
        // Custom border radius
        borderRadius: {
          '4xl': '2rem',
        },
        // Font settings
        fontFamily: {
          sans: ['Inter', 'system-ui', 'sans-serif'],
        },
        // Box shadows
        boxShadow: {
          'card': '0 0 0 1px rgba(0, 0, 0, 0.05), 0 4px 6px -1px rgba(0, 0, 0, 0.1)',
        },
        extend: {
          backgroundImage: {
            'gradient-linear': 'linear-gradient(to right, var(--tw-gradient-stops))',
          },
        },
      },
    },
    plugins: [
      require('@tailwindcss/forms'), // For better form styling
    ],
    // Important to ensure styles are applied correctly
    important: true,
  }
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "es2020",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "node",
    "rootDir": ".",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "preserve",
    "types": [
      "react",
      "react-dom",
      "node"
    ],
    "typeRoots": [
      "./node_modules/@types",
      "./src/@types"
    ],
    "outDir": "./dist",
    "baseUrl": "src"
  },
  "include": [
    "src",
    "netlify/functions"
  ],
  "exclude": [
    "node_modules",
    "build",
    "dist"
  ]
}
</file>

</files>
